/* tslint:disable */
/* eslint-disable */
/**
 * Openfort API
 * Complete Openfort API references and guides can be found at: https://openfort.xyz/docs
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: founders@openfort.xyz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Abi
 */
export interface Abi {
    /**
     * 
     * @type {string}
     * @memberof Abi
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Abi
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Abi
     */
    'anonymous'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Abi
     */
    'payable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Abi
     */
    'constant'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Abi
     */
    'stateMutability'?: string;
    /**
     * 
     * @type {string}
     * @memberof Abi
     */
    'gas'?: string;
    /**
     * 
     * @type {Array<AbiType>}
     * @memberof Abi
     */
    'inputs'?: Array<AbiType>;
    /**
     * 
     * @type {Array<AbiType>}
     * @memberof Abi
     */
    'outputs'?: Array<AbiType>;
}
/**
 * 
 * @export
 * @interface AbiType
 */
export interface AbiType {
    /**
     * 
     * @type {string}
     * @memberof AbiType
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AbiType
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AbiType
     */
    'indexed'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof AbiType
     */
    'internalType'?: any;
    /**
     * 
     * @type {Array<AbiType>}
     * @memberof AbiType
     */
    'components'?: Array<AbiType>;
}
/**
 * Accelbyte oauth configuration
 * @export
 * @interface AccelbyteOAuthConfig
 */
export interface AccelbyteOAuthConfig {
    /**
     * Enable OAuth provider.
     * @type {boolean}
     * @memberof AccelbyteOAuthConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {OAuthProviderACCELBYTE}
     * @memberof AccelbyteOAuthConfig
     */
    'provider': OAuthProviderACCELBYTE;
    /**
     * Base URI of your accelbyte gaming service environment. E.g. https://mygame.dev.gamingservices.accelbyte.io/
     * @type {string}
     * @memberof AccelbyteOAuthConfig
     */
    'baseUrl': string;
    /**
     * Client ID of your accelbyte gaming service environment.
     * @type {string}
     * @memberof AccelbyteOAuthConfig
     */
    'clientId': string;
    /**
     * Secret of your confidential IAM client.
     * @type {string}
     * @memberof AccelbyteOAuthConfig
     */
    'clientSecret': string;
}


/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeACCOUNT}
     * @memberof Account
     */
    'object': EntityTypeACCOUNT;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'ownerAddress': string;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'deployed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'custodial': boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof Account
     */
    'chainId': number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'accountType': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'pendingOwnerAddress'?: string;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof Account
     */
    'transactionIntents'?: Array<EntityIdResponse>;
}


/**
 * 
 * @export
 * @interface AccountInventoryListQueries
 */
export interface AccountInventoryListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof AccountInventoryListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof AccountInventoryListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof AccountInventoryListQueries
     */
    'order'?: SortOrder;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountInventoryListQueries
     */
    'contractId'?: Array<string>;
}


/**
 * 
 * @export
 * @interface AccountListQueries
 */
export interface AccountListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof AccountListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof AccountListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof AccountListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the fields to expand in the response.
     * @type {Array<AccountResponseExpandable>}
     * @memberof AccountListQueries
     */
    'expand'?: Array<AccountResponseExpandable>;
    /**
     * Specifies the unique player ID (starts with pla_)
     * @type {string}
     * @memberof AccountListQueries
     */
    'player': string;
}


/**
 * 
 * @export
 * @interface AccountListResponse
 */
export interface AccountListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof AccountListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof AccountListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<AccountResponse>}
     * @memberof AccountListResponse
     */
    'data': Array<AccountResponse>;
    /**
     * 
     * @type {number}
     * @memberof AccountListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof AccountListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof AccountListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface AccountPolicyRuleResponse
 */
export interface AccountPolicyRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountPolicyRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof AccountPolicyRuleResponse
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {number}
     * @memberof AccountPolicyRuleResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {PolicyRuleTypeACCOUNT}
     * @memberof AccountPolicyRuleResponse
     */
    'type': PolicyRuleTypeACCOUNT;
}


/**
 * 
 * @export
 * @interface AccountResponse
 */
export interface AccountResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeACCOUNT}
     * @memberof AccountResponse
     */
    'object': EntityTypeACCOUNT;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'ownerAddress': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountResponse
     */
    'deployed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountResponse
     */
    'custodial': boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof AccountResponse
     */
    'chainId': number;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'accountType': string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'pendingOwnerAddress'?: string;
    /**
     * 
     * @type {Array<PlayerResponseTransactionIntentsInner>}
     * @memberof AccountResponse
     */
    'transactionIntents'?: Array<PlayerResponseTransactionIntentsInner>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AccountResponseExpandable = {
    TransactionIntents: 'transactionIntents'
} as const;

export type AccountResponseExpandable = typeof AccountResponseExpandable[keyof typeof AccountResponseExpandable];


/**
 * 
 * @export
 * @interface ApiAuthorizedNetworkListResponse
 */
export interface ApiAuthorizedNetworkListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof ApiAuthorizedNetworkListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof ApiAuthorizedNetworkListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<ApiAuthorizedNetworkResponse>}
     * @memberof ApiAuthorizedNetworkListResponse
     */
    'data': Array<ApiAuthorizedNetworkResponse>;
    /**
     * 
     * @type {number}
     * @memberof ApiAuthorizedNetworkListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAuthorizedNetworkListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAuthorizedNetworkListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface ApiAuthorizedNetworkResponse
 */
export interface ApiAuthorizedNetworkResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiAuthorizedNetworkResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAuthorizedNetworkResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ApiAuthorizedNetworkResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiAuthorizedNetworkResponse
     */
    'network': string;
}
/**
 * 
 * @export
 * @interface ApiKeyResponse
 */
export interface ApiKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiKeyResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ApiKeyResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiKeyResponse
     */
    'livemode': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ApiKeyType = {
    Pk: 'pk',
    Sk: 'sk'
} as const;

export type ApiKeyType = typeof ApiKeyType[keyof typeof ApiKeyType];


/**
 * 
 * @export
 * @interface AssetInventory
 */
export interface AssetInventory {
    /**
     * 
     * @type {AssetType}
     * @memberof AssetInventory
     */
    'assetType': AssetType;
    /**
     * 
     * @type {string}
     * @memberof AssetInventory
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetInventory
     */
    'tokenId'?: number;
    /**
     * amount in Wei
     * @type {string}
     * @memberof AssetInventory
     */
    'amount'?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetInventory
     */
    'lastTransferredAt'?: number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AssetType = {
    Eth: 'ETH',
    Erc20: 'ERC20',
    Erc721: 'ERC721',
    Erc1155: 'ERC1155'
} as const;

export type AssetType = typeof AssetType[keyof typeof AssetType];


/**
 * 
 * @export
 * @interface AuthPlayerListQueries
 */
export interface AuthPlayerListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof AuthPlayerListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof AuthPlayerListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof AuthPlayerListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the email address of the user.
     * @type {string}
     * @memberof AuthPlayerListQueries
     */
    'email'?: string;
}


/**
 * 
 * @export
 * @interface AuthPlayerListResponse
 */
export interface AuthPlayerListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof AuthPlayerListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof AuthPlayerListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<AuthPlayerResponse>}
     * @memberof AuthPlayerListResponse
     */
    'data': Array<AuthPlayerResponse>;
    /**
     * 
     * @type {number}
     * @memberof AuthPlayerListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof AuthPlayerListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof AuthPlayerListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface AuthPlayerResponse
 */
export interface AuthPlayerResponse {
    /**
     * 
     * @type {AuthPlayerResponsePlayer}
     * @memberof AuthPlayerResponse
     */
    'player'?: AuthPlayerResponsePlayer;
    /**
     * 
     * @type {string}
     * @memberof AuthPlayerResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePLAYER}
     * @memberof AuthPlayerResponse
     */
    'object': EntityTypePLAYER;
    /**
     * 
     * @type {number}
     * @memberof AuthPlayerResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof AuthPlayerResponse
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthPlayerResponse
     */
    'updatedAt': number;
    /**
     * 
     * @type {number}
     * @memberof AuthPlayerResponse
     */
    'lastSignInAt'?: number;
    /**
     * 
     * @type {PrismaInputJsonValue}
     * @memberof AuthPlayerResponse
     */
    'rawAppMetaData'?: PrismaInputJsonValue;
}


/**
 * 
 * @export
 * @interface AuthPlayerResponsePlayer
 */
export interface AuthPlayerResponsePlayer {
    /**
     * 
     * @type {string}
     * @memberof AuthPlayerResponsePlayer
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePLAYER}
     * @memberof AuthPlayerResponsePlayer
     */
    'object': EntityTypePLAYER;
    /**
     * 
     * @type {number}
     * @memberof AuthPlayerResponsePlayer
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof AuthPlayerResponsePlayer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AuthPlayerResponsePlayer
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: PlayerMetadataValue; }}
     * @memberof AuthPlayerResponsePlayer
     */
    'metadata'?: { [key: string]: PlayerMetadataValue; };
    /**
     * 
     * @type {Array<PlayerResponseTransactionIntentsInner>}
     * @memberof AuthPlayerResponsePlayer
     */
    'transactionIntents'?: Array<PlayerResponseTransactionIntentsInner>;
    /**
     * 
     * @type {Array<PlayerResponseAccountsInner>}
     * @memberof AuthPlayerResponsePlayer
     */
    'accounts'?: Array<PlayerResponseAccountsInner>;
}


/**
 * 
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * Player\'s identifier.
     * @type {string}
     * @memberof AuthResponse
     */
    'playerId': string;
    /**
     * JWT token.
     * @type {string}
     * @memberof AuthResponse
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface AuthenticatedPlayerResponse
 */
export interface AuthenticatedPlayerResponse {
    /**
     * Player\'s identifier.
     * @type {string}
     * @memberof AuthenticatedPlayerResponse
     */
    'playerId': string;
}
/**
 * 
 * @export
 * @interface AuthorizeWithOAuthToken200Response
 */
export interface AuthorizeWithOAuthToken200Response {
    /**
     * Player\'s identifier.
     * @type {string}
     * @memberof AuthorizeWithOAuthToken200Response
     */
    'playerId': string;
    /**
     * JWT token.
     * @type {string}
     * @memberof AuthorizeWithOAuthToken200Response
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface BalanceResponse
 */
export interface BalanceResponse {
    /**
     * 
     * @type {Money}
     * @memberof BalanceResponse
     */
    'balance': Money;
    /**
     * 
     * @type {Money}
     * @memberof BalanceResponse
     */
    'expenses': Money;
    /**
     * 
     * @type {Money}
     * @memberof BalanceResponse
     */
    'payments': Money;
}
/**
 * 
 * @export
 * @interface CancelTransferOwnershipRequest
 */
export interface CancelTransferOwnershipRequest {
    /**
     * The policy ID (starts with pol_)
     * @type {string}
     * @memberof CancelTransferOwnershipRequest
     */
    'policy': string;
}
/**
 * 
 * @export
 * @interface ChargeCustomTokenPolicyStrategy
 */
export interface ChargeCustomTokenPolicyStrategy {
    /**
     * 
     * @type {SponsorSchemaCHARGECUSTOMTOKENS}
     * @memberof ChargeCustomTokenPolicyStrategy
     */
    'sponsorSchema': SponsorSchemaCHARGECUSTOMTOKENS;
    /**
     * 
     * @type {string}
     * @memberof ChargeCustomTokenPolicyStrategy
     */
    'depositor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChargeCustomTokenPolicyStrategy
     */
    'tokenContract': string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCustomTokenPolicyStrategy
     */
    'tokenContractAmount': string;
}


/**
 * 
 * @export
 * @interface CheckoutRequest
 */
export interface CheckoutRequest {
    /**
     * Amount in cents
     * @type {number}
     * @memberof CheckoutRequest
     */
    'amount': number;
    /**
     * 
     * @type {Currency}
     * @memberof CheckoutRequest
     */
    'currency': Currency;
    /**
     * 
     * @type {string}
     * @memberof CheckoutRequest
     */
    'cancelUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutRequest
     */
    'successUrl'?: string;
}


/**
 * 
 * @export
 * @interface CheckoutResponse
 */
export interface CheckoutResponse {
    /**
     * 
     * @type {string}
     * @memberof CheckoutResponse
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface CompleteRecoveryRequest
 */
export interface CompleteRecoveryRequest {
    /**
     * Address of the new owner
     * @type {string}
     * @memberof CompleteRecoveryRequest
     */
    'newOwnerAddress': string;
    /**
     * Signatures
     * @type {Array<string>}
     * @memberof CompleteRecoveryRequest
     */
    'signatures'?: Array<string>;
    /**
     * The policy ID (starts with pol_)
     * @type {string}
     * @memberof CompleteRecoveryRequest
     */
    'policy': string;
}
/**
 * 
 * @export
 * @interface ContractDeleteResponse
 */
export interface ContractDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof ContractDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeCONTRACT}
     * @memberof ContractDeleteResponse
     */
    'object': EntityTypeCONTRACT;
    /**
     * 
     * @type {boolean}
     * @memberof ContractDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface ContractListQueries
 */
export interface ContractListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof ContractListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof ContractListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof ContractListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the name of the contract.
     * @type {string}
     * @memberof ContractListQueries
     */
    'name'?: string;
    /**
     * Specifies whether to include deleted contracts.
     * @type {boolean}
     * @memberof ContractListQueries
     */
    'deleted'?: boolean;
    /**
     * The chain ID of the contract.
     * @type {number}
     * @memberof ContractListQueries
     */
    'chainId'?: number;
    /**
     * Specifies the address of the contract.
     * @type {string}
     * @memberof ContractListQueries
     */
    'address'?: string;
}


/**
 * 
 * @export
 * @interface ContractListResponse
 */
export interface ContractListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof ContractListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof ContractListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<ContractResponse>}
     * @memberof ContractListResponse
     */
    'data': Array<ContractResponse>;
    /**
     * 
     * @type {number}
     * @memberof ContractListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof ContractListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof ContractListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface ContractPolicyRuleResponse
 */
export interface ContractPolicyRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof ContractPolicyRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof ContractPolicyRuleResponse
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {number}
     * @memberof ContractPolicyRuleResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {PolicyRuleTypeCONTRACT}
     * @memberof ContractPolicyRuleResponse
     */
    'type': PolicyRuleTypeCONTRACT;
    /**
     * 
     * @type {ContractPolicyRuleResponseContract}
     * @memberof ContractPolicyRuleResponse
     */
    'contract': ContractPolicyRuleResponseContract;
    /**
     * 
     * @type {string}
     * @memberof ContractPolicyRuleResponse
     */
    'functionName': string;
}


/**
 * 
 * @export
 * @interface ContractPolicyRuleResponseContract
 */
export interface ContractPolicyRuleResponseContract {
    /**
     * 
     * @type {string}
     * @memberof ContractPolicyRuleResponseContract
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeCONTRACT}
     * @memberof ContractPolicyRuleResponseContract
     */
    'object': EntityTypeCONTRACT;
    /**
     * 
     * @type {number}
     * @memberof ContractPolicyRuleResponseContract
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ContractPolicyRuleResponseContract
     */
    'name': string | null;
    /**
     * The chain ID.
     * @type {number}
     * @memberof ContractPolicyRuleResponseContract
     */
    'chainId': number;
    /**
     * 
     * @type {string}
     * @memberof ContractPolicyRuleResponseContract
     */
    'address': string;
    /**
     * 
     * @type {boolean}
     * @memberof ContractPolicyRuleResponseContract
     */
    'deleted': boolean;
    /**
     * 
     * @type {Array<Abi>}
     * @memberof ContractPolicyRuleResponseContract
     */
    'abi': Array<Abi>;
    /**
     * 
     * @type {boolean}
     * @memberof ContractPolicyRuleResponseContract
     */
    'publicVerification': boolean;
}


/**
 * 
 * @export
 * @interface ContractReadQueries
 */
export interface ContractReadQueries {
    /**
     * The function name of the contract.
     * @type {string}
     * @memberof ContractReadQueries
     */
    'functionName': string;
    /**
     * The function arguments of the contract.
     * @type {Array<any>}
     * @memberof ContractReadQueries
     */
    'functionArgs'?: Array<any>;
}
/**
 * 
 * @export
 * @interface ContractReadResponse
 */
export interface ContractReadResponse {
    /**
     * 
     * @type {string}
     * @memberof ContractReadResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeREADCONTRACT}
     * @memberof ContractReadResponse
     */
    'object': EntityTypeREADCONTRACT;
    /**
     * 
     * @type {number}
     * @memberof ContractReadResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ContractReadResponse
     */
    'functionName': string;
    /**
     * 
     * @type {any}
     * @memberof ContractReadResponse
     */
    'result': any;
}


/**
 * 
 * @export
 * @interface ContractResponse
 */
export interface ContractResponse {
    /**
     * 
     * @type {string}
     * @memberof ContractResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeCONTRACT}
     * @memberof ContractResponse
     */
    'object': EntityTypeCONTRACT;
    /**
     * 
     * @type {number}
     * @memberof ContractResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ContractResponse
     */
    'name': string | null;
    /**
     * The chain ID.
     * @type {number}
     * @memberof ContractResponse
     */
    'chainId': number;
    /**
     * 
     * @type {string}
     * @memberof ContractResponse
     */
    'address': string;
    /**
     * 
     * @type {boolean}
     * @memberof ContractResponse
     */
    'deleted': boolean;
    /**
     * 
     * @type {Array<Abi>}
     * @memberof ContractResponse
     */
    'abi': Array<Abi>;
    /**
     * 
     * @type {boolean}
     * @memberof ContractResponse
     */
    'publicVerification': boolean;
}


/**
 * 
 * @export
 * @interface CountPerIntervalLimitPolicyRuleResponse
 */
export interface CountPerIntervalLimitPolicyRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {number}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {PolicyRuleTypeRATELIMIT}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'type': PolicyRuleTypeRATELIMIT;
    /**
     * 
     * @type {PolicyRateLimitCOUNTPERINTERVAL}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'functionName': PolicyRateLimitCOUNTPERINTERVAL;
    /**
     * 
     * @type {number}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'countLimit': number;
    /**
     * 
     * @type {TimeIntervalType}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'timeIntervalType': TimeIntervalType;
    /**
     * 
     * @type {number}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'timeIntervalValue': number;
}


/**
 * 
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
    /**
     * The chain id
     * @type {number}
     * @memberof CreateAccountRequest
     */
    'chainId': number;
    /**
     * The address of the external owner
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'externalOwnerAddress'?: string;
    /**
     * 
     * @type {DataAccountTypes}
     * @memberof CreateAccountRequest
     */
    'accountType'?: DataAccountTypes;
    /**
     * If ERC6551, the NFT contract to use
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'tokenContract'?: string;
    /**
     * If ERC6551, the tokenID to serve as owner
     * @type {number}
     * @memberof CreateAccountRequest
     */
    'tokenId'?: number;
    /**
     * The player ID (starts with pla_)
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'player': string;
}


/**
 * 
 * @export
 * @interface CreateApiAuthorizedNetworkRequest
 */
export interface CreateApiAuthorizedNetworkRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateApiAuthorizedNetworkRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateApiAuthorizedNetworkRequest
     */
    'network': string;
}
/**
 * 
 * @export
 * @interface CreateContractRequest
 */
export interface CreateContractRequest {
    /**
     * Specifies the name of the contract (Only for display purposes).
     * @type {string}
     * @memberof CreateContractRequest
     */
    'name': string;
    /**
     * Specifies the chain ID of the contract.
     * @type {number}
     * @memberof CreateContractRequest
     */
    'chainId': number;
    /**
     * Specifies the address of the contract.
     * @type {string}
     * @memberof CreateContractRequest
     */
    'address': string;
    /**
     * Specifies the ABI of the contract.
     * @type {Array<Abi>}
     * @memberof CreateContractRequest
     */
    'abi'?: Array<Abi>;
    /**
     * Specifies whether to verify the contract publicly.
     * @type {boolean}
     * @memberof CreateContractRequest
     */
    'publicVerification'?: boolean;
}
/**
 * 
 * @export
 * @interface CreatePlayerAccountRequest
 */
export interface CreatePlayerAccountRequest {
    /**
     * The chain id
     * @type {number}
     * @memberof CreatePlayerAccountRequest
     */
    'chainId': number;
    /**
     * The address of the external owner
     * @type {string}
     * @memberof CreatePlayerAccountRequest
     */
    'externalOwnerAddress'?: string;
    /**
     * 
     * @type {DataAccountTypes}
     * @memberof CreatePlayerAccountRequest
     */
    'accountType'?: DataAccountTypes;
    /**
     * If ERC6551, the NFT contract to use
     * @type {string}
     * @memberof CreatePlayerAccountRequest
     */
    'tokenContract'?: string;
    /**
     * If ERC6551, the tokenID to serve as owner
     * @type {number}
     * @memberof CreatePlayerAccountRequest
     */
    'tokenId'?: number;
}


/**
 * 
 * @export
 * @interface CreatePlayerSessionRequest
 */
export interface CreatePlayerSessionRequest {
    /**
     * The address of the session key.
     * @type {string}
     * @memberof CreatePlayerSessionRequest
     */
    'address': string;
    /**
     * The chain ID.
     * @type {number}
     * @memberof CreatePlayerSessionRequest
     */
    'chainId': number;
    /**
     * If no account exists for a given player, create one with this address.
     * @type {string}
     * @memberof CreatePlayerSessionRequest
     */
    'externalOwnerAddress'?: string;
    /**
     * Maximum number of times the session key can be used.
     * @type {number}
     * @memberof CreatePlayerSessionRequest
     */
    'limit'?: number;
    /**
     * Whether the transactionIntent is optimistic (resolve before it arrives on chain) or not.
     * @type {boolean}
     * @memberof CreatePlayerSessionRequest
     */
    'optimistic'?: boolean;
    /**
     * The policy ID (starts with pol_).
     * @type {string}
     * @memberof CreatePlayerSessionRequest
     */
    'policy'?: string;
    /**
     * The unix timestamp in seconds when the session key becomes valid.
     * @type {number}
     * @memberof CreatePlayerSessionRequest
     */
    'validAfter': number;
    /**
     * The unix timestamp in seconds when the session key expires.
     * @type {number}
     * @memberof CreatePlayerSessionRequest
     */
    'validUntil': number;
    /**
     * The list of whitelisted addresses (contracts the session key can interact with).
     * @type {Array<string>}
     * @memberof CreatePlayerSessionRequest
     */
    'whitelist'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreatePolicyAllowFunctionRequest
 */
export interface CreatePolicyAllowFunctionRequest {
    /**
     * 
     * @type {PolicyRuleType}
     * @memberof CreatePolicyAllowFunctionRequest
     */
    'type': PolicyRuleType;
    /**
     * Name of the function in the contract to allow.
     * @type {string}
     * @memberof CreatePolicyAllowFunctionRequest
     */
    'functionName'?: string | null;
    /**
     * Contract ID to allow.
     * @type {string}
     * @memberof CreatePolicyAllowFunctionRequest
     */
    'contract'?: string | null;
    /**
     * Gas limit in WEI.
     * @type {string}
     * @memberof CreatePolicyAllowFunctionRequest
     */
    'gasLimit'?: string;
    /**
     * Number of times the function will be sponsored.
     * @type {number}
     * @memberof CreatePolicyAllowFunctionRequest
     */
    'countLimit'?: number;
    /**
     * 
     * @type {TimeIntervalType}
     * @memberof CreatePolicyAllowFunctionRequest
     */
    'timeIntervalType'?: TimeIntervalType;
    /**
     * Time interval value.
     * @type {number}
     * @memberof CreatePolicyAllowFunctionRequest
     */
    'timeIntervalValue'?: number;
}


/**
 * 
 * @export
 * @interface CreatePolicyRequest
 */
export interface CreatePolicyRequest {
    /**
     * Specifies the name of the policy.
     * @type {string}
     * @memberof CreatePolicyRequest
     */
    'name': string;
    /**
     * The chain ID of the policy.
     * @type {number}
     * @memberof CreatePolicyRequest
     */
    'chainId': number;
    /**
     * 
     * @type {PolicyStrategyRequest}
     * @memberof CreatePolicyRequest
     */
    'strategy': PolicyStrategyRequest;
}
/**
 * 
 * @export
 * @interface CreatePolicyRuleRequest
 */
export interface CreatePolicyRuleRequest {
    /**
     * 
     * @type {PolicyRuleType}
     * @memberof CreatePolicyRuleRequest
     */
    'type': PolicyRuleType;
    /**
     * Name of the function in the contract to allow.
     * @type {string}
     * @memberof CreatePolicyRuleRequest
     */
    'functionName'?: string | null;
    /**
     * Contract ID to allow.
     * @type {string}
     * @memberof CreatePolicyRuleRequest
     */
    'contract'?: string | null;
    /**
     * Gas limit in WEI.
     * @type {string}
     * @memberof CreatePolicyRuleRequest
     */
    'gasLimit'?: string;
    /**
     * Number of times the function will be sponsored.
     * @type {number}
     * @memberof CreatePolicyRuleRequest
     */
    'countLimit'?: number;
    /**
     * 
     * @type {TimeIntervalType}
     * @memberof CreatePolicyRuleRequest
     */
    'timeIntervalType'?: TimeIntervalType;
    /**
     * Time interval value.
     * @type {number}
     * @memberof CreatePolicyRuleRequest
     */
    'timeIntervalValue'?: number;
    /**
     * The unique Policy ID to add the rule to.
     * @type {string}
     * @memberof CreatePolicyRuleRequest
     */
    'policy': string;
}


/**
 * 
 * @export
 * @interface CreateProjectApiKeyRequest
 */
export interface CreateProjectApiKeyRequest {
    /**
     * 
     * @type {ApiKeyType}
     * @memberof CreateProjectApiKeyRequest
     */
    'type': ApiKeyType;
}


/**
 * 
 * @export
 * @interface CreateProjectRequest
 */
export interface CreateProjectRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateProjectRequest
     */
    'name': string;
    /**
     * 
     * @type {PrivateKeyPolicy}
     * @memberof CreateProjectRequest
     */
    'pkPolicy'?: PrivateKeyPolicy;
}


/**
 * 
 * @export
 * @interface CreateSessionRequest
 */
export interface CreateSessionRequest {
    /**
     * The address of the session key.
     * @type {string}
     * @memberof CreateSessionRequest
     */
    'address': string;
    /**
     * The chain ID.
     * @type {number}
     * @memberof CreateSessionRequest
     */
    'chainId': number;
    /**
     * If no account exists for a given player, create one with this address.
     * @type {string}
     * @memberof CreateSessionRequest
     */
    'externalOwnerAddress'?: string;
    /**
     * Maximum number of times the session key can be used.
     * @type {number}
     * @memberof CreateSessionRequest
     */
    'limit'?: number;
    /**
     * Whether the transactionIntent is optimistic (resolve before it arrives on chain) or not.
     * @type {boolean}
     * @memberof CreateSessionRequest
     */
    'optimistic'?: boolean;
    /**
     * The policy ID (starts with pol_).
     * @type {string}
     * @memberof CreateSessionRequest
     */
    'policy'?: string;
    /**
     * The unix timestamp in seconds when the session key becomes valid.
     * @type {number}
     * @memberof CreateSessionRequest
     */
    'validAfter': number;
    /**
     * The unix timestamp in seconds when the session key expires.
     * @type {number}
     * @memberof CreateSessionRequest
     */
    'validUntil': number;
    /**
     * The list of whitelisted addresses (contracts the session key can interact with).
     * @type {Array<string>}
     * @memberof CreateSessionRequest
     */
    'whitelist'?: Array<string>;
    /**
     * The player ID (starts with pla_).
     * @type {string}
     * @memberof CreateSessionRequest
     */
    'player': string;
}
/**
 * 
 * @export
 * @interface CreateTransactionIntentRequest
 */
export interface CreateTransactionIntentRequest {
    /**
     * The player ID (starts with pla_).
     * @type {string}
     * @memberof CreateTransactionIntentRequest
     */
    'player': string;
    /**
     * The chain ID.
     * @type {number}
     * @memberof CreateTransactionIntentRequest
     */
    'chainId': number;
    /**
     * The policy ID (starts with pol_).
     * @type {string}
     * @memberof CreateTransactionIntentRequest
     */
    'policy'?: string;
    /**
     * If no account exists for a given player, create one with this address.
     * @type {string}
     * @memberof CreateTransactionIntentRequest
     */
    'externalOwnerAddress'?: string;
    /**
     * Whether the transactionIntent is optimistic (resolve before it arrives on chain) or not.
     * @type {boolean}
     * @memberof CreateTransactionIntentRequest
     */
    'optimistic': boolean;
    /**
     * Specify the number of blocks after the block with transaction to be assured that transaction is in block
     * @type {number}
     * @memberof CreateTransactionIntentRequest
     */
    'confirmationBlocks'?: number;
    /**
     * 
     * @type {Array<Interaction>}
     * @memberof CreateTransactionIntentRequest
     */
    'interactions': Array<Interaction>;
}
/**
 * 
 * @export
 * @interface CreateWeb3ConnectionRequest
 */
export interface CreateWeb3ConnectionRequest {
    /**
     * The player ID (starts with pla_).
     * @type {string}
     * @memberof CreateWeb3ConnectionRequest
     */
    'player': string;
    /**
     * The chain ID.
     * @type {number}
     * @memberof CreateWeb3ConnectionRequest
     */
    'chainId': number;
    /**
     * Specifies the URI of the web3Connection.
     * @type {string}
     * @memberof CreateWeb3ConnectionRequest
     */
    'uri': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Currency = {
    Usd: 'usd'
} as const;

export type Currency = typeof Currency[keyof typeof Currency];


/**
 * 
 * @export
 * @enum {string}
 */

export const DataAccountTypes = {
    Upgradeable: 'Upgradeable',
    Managed: 'Managed',
    Erc6551: 'ERC6551',
    Recoverable: 'Recoverable'
} as const;

export type DataAccountTypes = typeof DataAccountTypes[keyof typeof DataAccountTypes];


/**
 * 
 * @export
 * @interface DomainData
 */
export interface DomainData {
    /**
     * The chain ID.
     * @type {number}
     * @memberof DomainData
     */
    'chainId': number;
    /**
     * 
     * @type {string}
     * @memberof DomainData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainData
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainData
     */
    'verifyingContract'?: string;
}
/**
 * 
 * @export
 * @interface EntityIdResponse
 */
export interface EntityIdResponse {
    /**
     * 
     * @type {string}
     * @memberof EntityIdResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeACCOUNT = {
    Account: 'account'
} as const;

export type EntityTypeACCOUNT = typeof EntityTypeACCOUNT[keyof typeof EntityTypeACCOUNT];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeCONTRACT = {
    Contract: 'contract'
} as const;

export type EntityTypeCONTRACT = typeof EntityTypeCONTRACT[keyof typeof EntityTypeCONTRACT];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeINVENTORY = {
    Inventory: 'inventory'
} as const;

export type EntityTypeINVENTORY = typeof EntityTypeINVENTORY[keyof typeof EntityTypeINVENTORY];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypePAYMASTERDEPOSITOR = {
    PaymasterDepositor: 'paymasterDepositor'
} as const;

export type EntityTypePAYMASTERDEPOSITOR = typeof EntityTypePAYMASTERDEPOSITOR[keyof typeof EntityTypePAYMASTERDEPOSITOR];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypePLAYER = {
    Player: 'player'
} as const;

export type EntityTypePLAYER = typeof EntityTypePLAYER[keyof typeof EntityTypePLAYER];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypePOLICY = {
    Policy: 'policy'
} as const;

export type EntityTypePOLICY = typeof EntityTypePOLICY[keyof typeof EntityTypePOLICY];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypePOLICYRULE = {
    PolicyRule: 'policyRule'
} as const;

export type EntityTypePOLICYRULE = typeof EntityTypePOLICYRULE[keyof typeof EntityTypePOLICYRULE];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypePROJECT = {
    Project: 'project'
} as const;

export type EntityTypePROJECT = typeof EntityTypePROJECT[keyof typeof EntityTypePROJECT];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeREADCONTRACT = {
    ReadContract: 'readContract'
} as const;

export type EntityTypeREADCONTRACT = typeof EntityTypeREADCONTRACT[keyof typeof EntityTypeREADCONTRACT];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeSESSION = {
    Session: 'session'
} as const;

export type EntityTypeSESSION = typeof EntityTypeSESSION[keyof typeof EntityTypeSESSION];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeSIGNATURE = {
    Signature: 'signature'
} as const;

export type EntityTypeSIGNATURE = typeof EntityTypeSIGNATURE[keyof typeof EntityTypeSIGNATURE];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeTRANSACTIONINTENT = {
    TransactionIntent: 'transactionIntent'
} as const;

export type EntityTypeTRANSACTIONINTENT = typeof EntityTypeTRANSACTIONINTENT[keyof typeof EntityTypeTRANSACTIONINTENT];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeUSER = {
    User: 'user'
} as const;

export type EntityTypeUSER = typeof EntityTypeUSER[keyof typeof EntityTypeUSER];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeWEB3ACTION = {
    Web3Action: 'web3Action'
} as const;

export type EntityTypeWEB3ACTION = typeof EntityTypeWEB3ACTION[keyof typeof EntityTypeWEB3ACTION];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeWEB3CONNECTION = {
    Web3Connection: 'web3Connection'
} as const;

export type EntityTypeWEB3CONNECTION = typeof EntityTypeWEB3CONNECTION[keyof typeof EntityTypeWEB3CONNECTION];


/**
 * 
 * @export
 * @enum {string}
 */

export const ErrorTypeINVALIDREQUESTERROR = {
    InvalidRequestError: 'invalid_request_error'
} as const;

export type ErrorTypeINVALIDREQUESTERROR = typeof ErrorTypeINVALIDREQUESTERROR[keyof typeof ErrorTypeINVALIDREQUESTERROR];


/**
 * return value from estimateTransactionIntentCost
 * @export
 * @interface EstimateTransactionIntentGasResult
 */
export interface EstimateTransactionIntentGasResult {
    /**
     * the preVerification gas used by this UserOperation.
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'preVerificationGas': string;
    /**
     * gas used for validation of this UserOperation, including account creation
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'verificationGas': string;
    /**
     * the deadline after which this UserOperation is invalid (not a gas estimation parameter, but returned by validation
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'validUntil'?: string;
    /**
     * the deadline after which this UserOperation is valid (not a gas estimation parameter, but returned by validation
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'validAfter'?: string;
    /**
     * estimated cost of calling the account with the given callData
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'callGasLimit': string;
    /**
     * returned by some bundlers (e.g. Biconomy\'s)
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'verificationGasLimit'?: string;
    /**
     * estimated TX gas cost
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'estimatedTXGas': string;
    /**
     * estimated TX gas cost in the chain native token (WEI)
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'estimatedTXGasFee': string;
    /**
     * estimated TX gas cost in USD
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'estimatedTXGasFeeUSD': string;
    /**
     * when using a policy, the estimated TX gas cost in the ERC-20 token defined in the strategy (WEI)
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'estimatedTXGasFeeToken'?: string;
    /**
     * gas price used for the estimation
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'gasPrice': string;
}
/**
 * 
 * @export
 * @interface FieldErrorsValue
 */
export interface FieldErrorsValue {
    /**
     * 
     * @type {any}
     * @memberof FieldErrorsValue
     */
    'value'?: any;
    /**
     * 
     * @type {string}
     * @memberof FieldErrorsValue
     */
    'message': string;
}
/**
 * Firebase configuration
 * @export
 * @interface FirebaseOAuthConfig
 */
export interface FirebaseOAuthConfig {
    /**
     * Enable OAuth provider.
     * @type {boolean}
     * @memberof FirebaseOAuthConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {OAuthProviderFIREBASE}
     * @memberof FirebaseOAuthConfig
     */
    'provider': OAuthProviderFIREBASE;
    /**
     * Project ID of your Firebase service environment.
     * @type {string}
     * @memberof FirebaseOAuthConfig
     */
    'projectId': string;
}


/**
 * 
 * @export
 * @interface FixedRateTokenPolicyStrategy
 */
export interface FixedRateTokenPolicyStrategy {
    /**
     * 
     * @type {SponsorSchemaFIXEDRATE}
     * @memberof FixedRateTokenPolicyStrategy
     */
    'sponsorSchema': SponsorSchemaFIXEDRATE;
    /**
     * 
     * @type {string}
     * @memberof FixedRateTokenPolicyStrategy
     */
    'depositor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FixedRateTokenPolicyStrategy
     */
    'tokenContract': string;
    /**
     * 
     * @type {string}
     * @memberof FixedRateTokenPolicyStrategy
     */
    'tokenContractAmount': string;
}


/**
 * 
 * @export
 * @interface GasPerIntervalLimitPolicyRuleResponse
 */
export interface GasPerIntervalLimitPolicyRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {number}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {PolicyRuleTypeRATELIMIT}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'type': PolicyRuleTypeRATELIMIT;
    /**
     * 
     * @type {PolicyRateLimitGASPERINTERVAL}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'functionName': PolicyRateLimitGASPERINTERVAL;
    /**
     * 
     * @type {string}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'gasLimit': string;
    /**
     * 
     * @type {TimeIntervalType}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'timeIntervalType': TimeIntervalType;
    /**
     * 
     * @type {number}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'timeIntervalValue': number;
}


/**
 * 
 * @export
 * @interface GasPerTransactionLimitPolicyRuleResponse
 */
export interface GasPerTransactionLimitPolicyRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof GasPerTransactionLimitPolicyRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof GasPerTransactionLimitPolicyRuleResponse
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {number}
     * @memberof GasPerTransactionLimitPolicyRuleResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {PolicyRuleTypeRATELIMIT}
     * @memberof GasPerTransactionLimitPolicyRuleResponse
     */
    'type': PolicyRuleTypeRATELIMIT;
    /**
     * 
     * @type {PolicyRateLimitGASPERTRANSACTION}
     * @memberof GasPerTransactionLimitPolicyRuleResponse
     */
    'functionName': PolicyRateLimitGASPERTRANSACTION;
    /**
     * 
     * @type {string}
     * @memberof GasPerTransactionLimitPolicyRuleResponse
     */
    'gasLimit': string;
}


/**
 * 
 * @export
 * @interface GasReport
 */
export interface GasReport {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof GasReport
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {Array<GasReportDataInner>}
     * @memberof GasReport
     */
    'data': Array<GasReportDataInner>;
}


/**
 * 
 * @export
 * @interface GasReportDataInner
 */
export interface GasReportDataInner {
    /**
     * 
     * @type {Array<GasReportDataInnerTransactionIntentsInner>}
     * @memberof GasReportDataInner
     */
    'transactionIntents': Array<GasReportDataInnerTransactionIntentsInner>;
    /**
     * 
     * @type {string}
     * @memberof GasReportDataInner
     */
    'totalTransactionFeeInUSD': string;
    /**
     * 
     * @type {string}
     * @memberof GasReportDataInner
     */
    'totalTransactionFee': string;
    /**
     * 
     * @type {string}
     * @memberof GasReportDataInner
     */
    'averageTransactionFee': string;
    /**
     * 
     * @type {GasReportDataInnerPeriod}
     * @memberof GasReportDataInner
     */
    'period': GasReportDataInnerPeriod;
    /**
     * 
     * @type {number}
     * @memberof GasReportDataInner
     */
    'periodNumber': number;
}
/**
 * 
 * @export
 * @interface GasReportDataInnerPeriod
 */
export interface GasReportDataInnerPeriod {
    /**
     * 
     * @type {number}
     * @memberof GasReportDataInnerPeriod
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof GasReportDataInnerPeriod
     */
    'start': number;
}
/**
 * 
 * @export
 * @interface GasReportDataInnerTransactionIntentsInner
 */
export interface GasReportDataInnerTransactionIntentsInner {
    /**
     * 
     * @type {string}
     * @memberof GasReportDataInnerTransactionIntentsInner
     */
    'gasFeeInUSD': string;
    /**
     * 
     * @type {string}
     * @memberof GasReportDataInnerTransactionIntentsInner
     */
    'gasUsed': string;
    /**
     * 
     * @type {string}
     * @memberof GasReportDataInnerTransactionIntentsInner
     */
    'gasPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GasReportDataInnerTransactionIntentsInner
     */
    'gasFee': string;
    /**
     * 
     * @type {string}
     * @memberof GasReportDataInnerTransactionIntentsInner
     */
    'transactionIntentId': string;
}
/**
 * 
 * @export
 * @interface GetSigninUrlResponse
 */
export interface GetSigninUrlResponse {
    /**
     * 
     * @type {string}
     * @memberof GetSigninUrlResponse
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof GetSigninUrlResponse
     */
    'key': string;
}
/**
 * Google oauth configuration
 * @export
 * @interface GoogleOAuthConfig
 */
export interface GoogleOAuthConfig {
    /**
     * Enable OAuth provider.
     * @type {boolean}
     * @memberof GoogleOAuthConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {OAuthProviderGOOGLE}
     * @memberof GoogleOAuthConfig
     */
    'provider': OAuthProviderGOOGLE;
    /**
     * Google API client ID.
     * @type {string}
     * @memberof GoogleOAuthConfig
     */
    'clientId': string;
    /**
     * Google API client secret.
     * @type {string}
     * @memberof GoogleOAuthConfig
     */
    'clientSecret': string;
    /**
     * The URI to redirect to after completing the auth request. You can use Openfort redirect URL: https://openfort.xyz/auth/v1/google/callback
     * @type {string}
     * @memberof GoogleOAuthConfig
     */
    'redirectUri': string;
}


/**
 * 
 * @export
 * @interface Interaction
 */
export interface Interaction {
    /**
     * The address of the contract.
     * @type {string}
     * @memberof Interaction
     */
    'to'?: string;
    /**
     * The contract interacting with
     * @type {string}
     * @memberof Interaction
     */
    'contract'?: string;
    /**
     * The value of the transaction.
     * @type {string}
     * @memberof Interaction
     */
    'value'?: string;
    /**
     * The function name of the contract.
     * @type {string}
     * @memberof Interaction
     */
    'functionName'?: string;
    /**
     * The function arguments of the contract.
     * @type {Array<any>}
     * @memberof Interaction
     */
    'functionArgs'?: Array<any>;
}
/**
 * 
 * @export
 * @interface InvalidRequestError
 */
export interface InvalidRequestError {
    /**
     * 
     * @type {ErrorTypeINVALIDREQUESTERROR}
     * @memberof InvalidRequestError
     */
    'type': ErrorTypeINVALIDREQUESTERROR;
    /**
     * 
     * @type {string}
     * @memberof InvalidRequestError
     */
    'message': string;
    /**
     * 
     * @type {{ [key: string]: FieldErrorsValue; }}
     * @memberof InvalidRequestError
     */
    'details'?: { [key: string]: FieldErrorsValue; };
}


/**
 * 
 * @export
 * @interface InvalidRequestErrorResponse
 */
export interface InvalidRequestErrorResponse {
    /**
     * 
     * @type {InvalidRequestError}
     * @memberof InvalidRequestErrorResponse
     */
    'error': InvalidRequestError;
}
/**
 * 
 * @export
 * @interface InventoryListResponse
 */
export interface InventoryListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof InventoryListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof InventoryListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<AssetInventory>}
     * @memberof InventoryListResponse
     */
    'data': Array<AssetInventory>;
    /**
     * 
     * @type {number}
     * @memberof InventoryListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof InventoryListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof InventoryListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface InventoryResponse
 */
export interface InventoryResponse {
    /**
     * 
     * @type {EntityTypeINVENTORY}
     * @memberof InventoryResponse
     */
    'object': EntityTypeINVENTORY;
    /**
     * 
     * @type {string}
     * @memberof InventoryResponse
     */
    'url': string;
    /**
     * 
     * @type {AssetInventory}
     * @memberof InventoryResponse
     */
    'data': AssetInventory;
}


/**
 * 
 * @export
 * @interface Log
 */
export interface Log {
    /**
     * 
     * @type {number}
     * @memberof Log
     */
    'blockNumber': number;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'blockHash': string;
    /**
     * 
     * @type {number}
     * @memberof Log
     */
    'transactionIndex': number;
    /**
     * 
     * @type {boolean}
     * @memberof Log
     */
    'removed': boolean;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'data': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Log
     */
    'topics': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'transactionHash': string;
    /**
     * 
     * @type {number}
     * @memberof Log
     */
    'logIndex': number;
    /**
     * 
     * @type {boolean}
     * @memberof Log
     */
    'orphaned'?: boolean;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * The email address of the user.
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * The password of the user.
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Money
 */
export interface Money {
    /**
     * Amount in cents
     * @type {number}
     * @memberof Money
     */
    'amount': number;
    /**
     * 
     * @type {Currency}
     * @memberof Money
     */
    'currency': Currency;
}


/**
 * 
 * @export
 * @interface NextActionPayload
 */
export interface NextActionPayload {
    /**
     * 
     * @type {any}
     * @memberof NextActionPayload
     */
    'userOp'?: any;
    /**
     * 
     * @type {string}
     * @memberof NextActionPayload
     */
    'userOpHash'?: string;
}
/**
 * 
 * @export
 * @interface NextActionResponse
 */
export interface NextActionResponse {
    /**
     * 
     * @type {NextActionType}
     * @memberof NextActionResponse
     */
    'type': NextActionType;
    /**
     * 
     * @type {NextActionPayload}
     * @memberof NextActionResponse
     */
    'payload': NextActionPayload;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const NextActionType = {
    SignWithWallet: 'sign_with_wallet'
} as const;

export type NextActionType = typeof NextActionType[keyof typeof NextActionType];


/**
 * 
 * @export
 * @interface OAuthConfig
 */
export interface OAuthConfig {
    /**
     * Enable OAuth provider.
     * @type {boolean}
     * @memberof OAuthConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {OAuthProviderFIREBASE}
     * @memberof OAuthConfig
     */
    'provider': OAuthProviderFIREBASE;
    /**
     * Base URI of your accelbyte gaming service environment. E.g. https://mygame.dev.gamingservices.accelbyte.io/
     * @type {string}
     * @memberof OAuthConfig
     */
    'baseUrl': string;
    /**
     * Google API client ID.
     * @type {string}
     * @memberof OAuthConfig
     */
    'clientId': string;
    /**
     * Google API client secret.
     * @type {string}
     * @memberof OAuthConfig
     */
    'clientSecret': string;
    /**
     * The URI to redirect to after completing the auth request. You can use Openfort redirect URL: https://openfort.xyz/auth/v1/google/callback
     * @type {string}
     * @memberof OAuthConfig
     */
    'redirectUri': string;
    /**
     * Title ID of your Play Fab gaming service environment.
     * @type {string}
     * @memberof OAuthConfig
     */
    'titleId': string;
    /**
     * Project ID of your Firebase service environment.
     * @type {string}
     * @memberof OAuthConfig
     */
    'projectId': string;
}


/**
 * Response for the OAuth config list method.
 * @export
 * @interface OAuthConfigListResponse
 */
export interface OAuthConfigListResponse {
    /**
     * List of the OAuth providers configurations
     * @type {Array<OAuthConfig>}
     * @memberof OAuthConfigListResponse
     */
    'data': Array<OAuthConfig>;
}
/**
 * Enum of the supporting OAuth providers.
 * @export
 * @enum {string}
 */

export const OAuthProvider = {
    Accelbyte: 'accelbyte',
    Firebase: 'firebase',
    Google: 'google',
    Playfab: 'playfab'
} as const;

export type OAuthProvider = typeof OAuthProvider[keyof typeof OAuthProvider];


/**
 * 
 * @export
 * @enum {string}
 */

export const OAuthProviderACCELBYTE = {
    Accelbyte: 'accelbyte'
} as const;

export type OAuthProviderACCELBYTE = typeof OAuthProviderACCELBYTE[keyof typeof OAuthProviderACCELBYTE];


/**
 * 
 * @export
 * @enum {string}
 */

export const OAuthProviderFIREBASE = {
    Firebase: 'firebase'
} as const;

export type OAuthProviderFIREBASE = typeof OAuthProviderFIREBASE[keyof typeof OAuthProviderFIREBASE];


/**
 * 
 * @export
 * @enum {string}
 */

export const OAuthProviderGOOGLE = {
    Google: 'google'
} as const;

export type OAuthProviderGOOGLE = typeof OAuthProviderGOOGLE[keyof typeof OAuthProviderGOOGLE];


/**
 * 
 * @export
 * @enum {string}
 */

export const OAuthProviderPLAYFAB = {
    Playfab: 'playfab'
} as const;

export type OAuthProviderPLAYFAB = typeof OAuthProviderPLAYFAB[keyof typeof OAuthProviderPLAYFAB];


/**
 * The request to verify access token
 * @export
 * @interface OAuthRequest
 */
export interface OAuthRequest {
    /**
     * Access token to be verified
     * @type {string}
     * @memberof OAuthRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ObsoleteAssetInventory
 */
export interface ObsoleteAssetInventory {
    /**
     * 
     * @type {ObsoleteAssetType}
     * @memberof ObsoleteAssetInventory
     * @deprecated
     */
    'assetType': ObsoleteAssetType;
    /**
     * 
     * @type {string}
     * @memberof ObsoleteAssetInventory
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof ObsoleteAssetInventory
     */
    'tokenId'?: number;
    /**
     * amount in Wei
     * @type {string}
     * @memberof ObsoleteAssetInventory
     */
    'amount'?: string;
    /**
     * 
     * @type {number}
     * @memberof ObsoleteAssetInventory
     */
    'lastTransferredAt'?: number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ObsoleteAssetType = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type ObsoleteAssetType = typeof ObsoleteAssetType[keyof typeof ObsoleteAssetType];


/**
 * 
 * @export
 * @interface ObsoleteInventoryResponse
 */
export interface ObsoleteInventoryResponse {
    /**
     * 
     * @type {EntityTypeINVENTORY}
     * @memberof ObsoleteInventoryResponse
     */
    'object': EntityTypeINVENTORY;
    /**
     * 
     * @type {Array<ObsoleteAssetInventory>}
     * @memberof ObsoleteInventoryResponse
     */
    'nftAssets'?: Array<ObsoleteAssetInventory>;
    /**
     * 
     * @type {ObsoleteAssetInventory}
     * @memberof ObsoleteInventoryResponse
     * @deprecated
     */
    'nativeAsset'?: ObsoleteAssetInventory;
    /**
     * 
     * @type {Array<ObsoleteAssetInventory>}
     * @memberof ObsoleteInventoryResponse
     */
    'tokenAssets'?: Array<ObsoleteAssetInventory>;
}


/**
 * 
 * @export
 * @interface PayForUserPolicyStrategy
 */
export interface PayForUserPolicyStrategy {
    /**
     * 
     * @type {SponsorSchemaPAYFORUSER}
     * @memberof PayForUserPolicyStrategy
     */
    'sponsorSchema': SponsorSchemaPAYFORUSER;
    /**
     * 
     * @type {string}
     * @memberof PayForUserPolicyStrategy
     */
    'depositor'?: string | null;
}


/**
 * 
 * @export
 * @interface PaymasterDepositorCreateRequest
 */
export interface PaymasterDepositorCreateRequest {
    /**
     * Paymaster depositor address.
     * @type {string}
     * @memberof PaymasterDepositorCreateRequest
     */
    'depositorAddress': string;
    /**
     * Signature to verify the account ownership.
     * @type {string}
     * @memberof PaymasterDepositorCreateRequest
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface PaymasterDepositorDeleteResponse
 */
export interface PaymasterDepositorDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof PaymasterDepositorDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePAYMASTERDEPOSITOR}
     * @memberof PaymasterDepositorDeleteResponse
     */
    'object': EntityTypePAYMASTERDEPOSITOR;
    /**
     * 
     * @type {boolean}
     * @memberof PaymasterDepositorDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface PaymasterDepositorGetMessageResponse
 */
export interface PaymasterDepositorGetMessageResponse {
    /**
     * 
     * @type {string}
     * @memberof PaymasterDepositorGetMessageResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof PaymasterDepositorGetMessageResponse
     */
    'depositorAddress': string;
}
/**
 * 
 * @export
 * @interface PaymasterDepositorListResponse
 */
export interface PaymasterDepositorListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof PaymasterDepositorListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof PaymasterDepositorListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<PaymasterDepositorResponse>}
     * @memberof PaymasterDepositorListResponse
     */
    'data': Array<PaymasterDepositorResponse>;
    /**
     * 
     * @type {number}
     * @memberof PaymasterDepositorListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof PaymasterDepositorListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof PaymasterDepositorListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface PaymasterDepositorResponse
 */
export interface PaymasterDepositorResponse {
    /**
     * 
     * @type {string}
     * @memberof PaymasterDepositorResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymasterDepositorResponse
     */
    'depositorAddress': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickContractResponseId
 */
export interface PickContractResponseId {
    /**
     * 
     * @type {string}
     * @memberof PickContractResponseId
     */
    'id': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPlayerResponseId
 */
export interface PickPlayerResponseId {
    /**
     * 
     * @type {string}
     * @memberof PickPlayerResponseId
     */
    'id': string;
}
/**
 * PlayFab oauth configuration
 * @export
 * @interface PlayFabOAuthConfig
 */
export interface PlayFabOAuthConfig {
    /**
     * Enable OAuth provider.
     * @type {boolean}
     * @memberof PlayFabOAuthConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {OAuthProviderPLAYFAB}
     * @memberof PlayFabOAuthConfig
     */
    'provider': OAuthProviderPLAYFAB;
    /**
     * Title ID of your Play Fab gaming service environment.
     * @type {string}
     * @memberof PlayFabOAuthConfig
     */
    'titleId': string;
}


/**
 * 
 * @export
 * @interface Player
 */
export interface Player {
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePLAYER}
     * @memberof Player
     */
    'object': EntityTypePLAYER;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: PlayerMetadataValue; }}
     * @memberof Player
     */
    'metadata'?: { [key: string]: PlayerMetadataValue; };
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof Player
     */
    'transactionIntents'?: Array<EntityIdResponse>;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof Player
     */
    'accounts'?: Array<EntityIdResponse>;
}


/**
 * 
 * @export
 * @interface PlayerCancelTransferOwnershipRequest
 */
export interface PlayerCancelTransferOwnershipRequest {
    /**
     * The policy ID (starts with pol_)
     * @type {string}
     * @memberof PlayerCancelTransferOwnershipRequest
     */
    'policy': string;
    /**
     * The chain id where the account is.
     * @type {number}
     * @memberof PlayerCancelTransferOwnershipRequest
     */
    'chainId': number;
}
/**
 * 
 * @export
 * @interface PlayerCreateRequest
 */
export interface PlayerCreateRequest {
    /**
     * Specifies the player name.
     * @type {string}
     * @memberof PlayerCreateRequest
     */
    'name': string;
    /**
     * Specifies the player description.
     * @type {string}
     * @memberof PlayerCreateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: PlayerMetadataValue; }}
     * @memberof PlayerCreateRequest
     */
    'metadata'?: { [key: string]: PlayerMetadataValue; };
}
/**
 * 
 * @export
 * @interface PlayerDeleteResponse
 */
export interface PlayerDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof PlayerDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePLAYER}
     * @memberof PlayerDeleteResponse
     */
    'object': EntityTypePLAYER;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface PlayerInventoryListQueries
 */
export interface PlayerInventoryListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof PlayerInventoryListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof PlayerInventoryListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof PlayerInventoryListQueries
     */
    'order'?: SortOrder;
    /**
     * Filter by contract ID (starts with con_).
     * @type {Array<string>}
     * @memberof PlayerInventoryListQueries
     */
    'contractId'?: Array<string>;
    /**
     * Filter by chain id.
     * @type {number}
     * @memberof PlayerInventoryListQueries
     */
    'chainId': number;
}


/**
 * 
 * @export
 * @interface PlayerInventoryQueries
 */
export interface PlayerInventoryQueries {
    /**
     * Filter by chain id.
     * @type {number}
     * @memberof PlayerInventoryQueries
     */
    'chainId': number;
}
/**
 * 
 * @export
 * @interface PlayerListQueries
 */
export interface PlayerListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof PlayerListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof PlayerListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof PlayerListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the fields to expand in the response.
     * @type {Array<PlayerResponseExpandable>}
     * @memberof PlayerListQueries
     */
    'expand'?: Array<PlayerResponseExpandable>;
    /**
     * Filter by player name.
     * @type {string}
     * @memberof PlayerListQueries
     */
    'name'?: string;
}


/**
 * 
 * @export
 * @interface PlayerListResponse
 */
export interface PlayerListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof PlayerListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof PlayerListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<PlayerResponse>}
     * @memberof PlayerListResponse
     */
    'data': Array<PlayerResponse>;
    /**
     * 
     * @type {number}
     * @memberof PlayerListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface PlayerMetadataValue
 */
export interface PlayerMetadataValue {
}
/**
 * 
 * @export
 * @interface PlayerResponse
 */
export interface PlayerResponse {
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePLAYER}
     * @memberof PlayerResponse
     */
    'object': EntityTypePLAYER;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: PlayerMetadataValue; }}
     * @memberof PlayerResponse
     */
    'metadata'?: { [key: string]: PlayerMetadataValue; };
    /**
     * 
     * @type {Array<PlayerResponseTransactionIntentsInner>}
     * @memberof PlayerResponse
     */
    'transactionIntents'?: Array<PlayerResponseTransactionIntentsInner>;
    /**
     * 
     * @type {Array<PlayerResponseAccountsInner>}
     * @memberof PlayerResponse
     */
    'accounts'?: Array<PlayerResponseAccountsInner>;
}


/**
 * 
 * @export
 * @interface PlayerResponseAccountsInner
 */
export interface PlayerResponseAccountsInner {
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseAccountsInner
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeACCOUNT}
     * @memberof PlayerResponseAccountsInner
     */
    'object': EntityTypeACCOUNT;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseAccountsInner
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseAccountsInner
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseAccountsInner
     */
    'ownerAddress': string;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerResponseAccountsInner
     */
    'deployed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerResponseAccountsInner
     */
    'custodial': boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof PlayerResponseAccountsInner
     */
    'chainId': number;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseAccountsInner
     */
    'accountType': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseAccountsInner
     */
    'pendingOwnerAddress'?: string;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof PlayerResponseAccountsInner
     */
    'transactionIntents'?: Array<EntityIdResponse>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PlayerResponseExpandable = {
    TransactionIntents: 'transactionIntents',
    Accounts: 'accounts'
} as const;

export type PlayerResponseExpandable = typeof PlayerResponseExpandable[keyof typeof PlayerResponseExpandable];


/**
 * 
 * @export
 * @interface PlayerResponseTransactionIntentsInner
 */
export interface PlayerResponseTransactionIntentsInner {
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeTRANSACTIONINTENT}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'object': EntityTypeTRANSACTIONINTENT;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'createdAt': number;
    /**
     * The unix timestamp in seconds when the transactionIntent was created.
     * @type {number}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'updatedAt': number;
    /**
     * The chain ID.
     * @type {number}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'chainId': number;
    /**
     * The hashed userOperation.
     * @type {string}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'userOperationHash'?: string;
    /**
     * 
     * @type {any}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'userOperation'?: any;
    /**
     * 
     * @type {ResponseResponse}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'response'?: ResponseResponse;
    /**
     * 
     * @type {Array<Interaction>}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'interactions'?: Array<Interaction>;
    /**
     * 
     * @type {NextActionResponse}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'nextAction'?: NextActionResponse;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'policy'?: EntityIdResponse;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'player': EntityIdResponse;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'account': EntityIdResponse;
}


/**
 * 
 * @export
 * @interface PlayerTransferOwnershipRequest
 */
export interface PlayerTransferOwnershipRequest {
    /**
     * The policy ID (starts with pol_)
     * @type {string}
     * @memberof PlayerTransferOwnershipRequest
     */
    'policy': string;
    /**
     * The chain id where the account is.
     * @type {number}
     * @memberof PlayerTransferOwnershipRequest
     */
    'chainId': number;
    /**
     * The address of the new owner
     * @type {string}
     * @memberof PlayerTransferOwnershipRequest
     */
    'newOwnerAddress': string;
    /**
     * The player ID (starts with pla_)
     * @type {string}
     * @memberof PlayerTransferOwnershipRequest
     */
    'player'?: string;
}
/**
 * 
 * @export
 * @interface PlayerUpdateRequest
 */
export interface PlayerUpdateRequest {
    /**
     * Specifies the player name.
     * @type {string}
     * @memberof PlayerUpdateRequest
     */
    'name'?: string;
    /**
     * Specifies the player description.
     * @type {string}
     * @memberof PlayerUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: PlayerMetadataValue; }}
     * @memberof PlayerUpdateRequest
     */
    'metadata'?: { [key: string]: PlayerMetadataValue; };
}
/**
 * 
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICY}
     * @memberof Policy
     */
    'object': EntityTypePOLICY;
    /**
     * 
     * @type {number}
     * @memberof Policy
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    'name': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Policy
     */
    'deleted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Policy
     */
    'enabled': boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof Policy
     */
    'chainId': number;
    /**
     * 
     * @type {PolicyStrategy}
     * @memberof Policy
     */
    'strategy': PolicyStrategy;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof Policy
     */
    'transactionIntents': Array<EntityIdResponse>;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof Policy
     */
    'policyRules': Array<EntityIdResponse>;
}


/**
 * 
 * @export
 * @interface PolicyDeleteResponse
 */
export interface PolicyDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICY}
     * @memberof PolicyDeleteResponse
     */
    'object': EntityTypePOLICY;
    /**
     * 
     * @type {boolean}
     * @memberof PolicyDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface PolicyListQueries
 */
export interface PolicyListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof PolicyListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof PolicyListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof PolicyListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the fields to expand in the response.
     * @type {Array<PolicyResponseExpandable>}
     * @memberof PolicyListQueries
     */
    'expand'?: Array<PolicyResponseExpandable>;
    /**
     * Specifies the name of the policy.
     * @type {string}
     * @memberof PolicyListQueries
     */
    'name'?: string;
    /**
     * Specifies whether to include deleted contracts.
     * @type {boolean}
     * @memberof PolicyListQueries
     */
    'deleted'?: boolean;
    /**
     * The chain ID of the policy.
     * @type {number}
     * @memberof PolicyListQueries
     */
    'chainId'?: number;
    /**
     * Specifies whether to include enabled contracts.
     * @type {boolean}
     * @memberof PolicyListQueries
     */
    'enabled'?: boolean;
}


/**
 * 
 * @export
 * @interface PolicyListResponse
 */
export interface PolicyListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof PolicyListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof PolicyListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<PolicyResponse>}
     * @memberof PolicyListResponse
     */
    'data': Array<PolicyResponse>;
    /**
     * 
     * @type {number}
     * @memberof PolicyListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRateLimit = {
    GasPerTransaction: 'gas_per_transaction',
    GasPerInterval: 'gas_per_interval',
    CountPerInterval: 'count_per_interval'
} as const;

export type PolicyRateLimit = typeof PolicyRateLimit[keyof typeof PolicyRateLimit];


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRateLimitCOUNTPERINTERVAL = {
    CountPerInterval: 'count_per_interval'
} as const;

export type PolicyRateLimitCOUNTPERINTERVAL = typeof PolicyRateLimitCOUNTPERINTERVAL[keyof typeof PolicyRateLimitCOUNTPERINTERVAL];


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRateLimitGASPERINTERVAL = {
    GasPerInterval: 'gas_per_interval'
} as const;

export type PolicyRateLimitGASPERINTERVAL = typeof PolicyRateLimitGASPERINTERVAL[keyof typeof PolicyRateLimitGASPERINTERVAL];


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRateLimitGASPERTRANSACTION = {
    GasPerTransaction: 'gas_per_transaction'
} as const;

export type PolicyRateLimitGASPERTRANSACTION = typeof PolicyRateLimitGASPERTRANSACTION[keyof typeof PolicyRateLimitGASPERTRANSACTION];


/**
 * 
 * @export
 * @interface PolicyResponse
 */
export interface PolicyResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICY}
     * @memberof PolicyResponse
     */
    'object': EntityTypePOLICY;
    /**
     * 
     * @type {number}
     * @memberof PolicyResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof PolicyResponse
     */
    'name': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PolicyResponse
     */
    'deleted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PolicyResponse
     */
    'enabled': boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof PolicyResponse
     */
    'chainId': number;
    /**
     * 
     * @type {PolicyStrategy}
     * @memberof PolicyResponse
     */
    'strategy': PolicyStrategy;
    /**
     * 
     * @type {Array<PlayerResponseTransactionIntentsInner>}
     * @memberof PolicyResponse
     */
    'transactionIntents': Array<PlayerResponseTransactionIntentsInner>;
    /**
     * 
     * @type {Array<PolicyResponsePolicyRulesInner>}
     * @memberof PolicyResponse
     */
    'policyRules': Array<PolicyResponsePolicyRulesInner>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyResponseExpandable = {
    TransactionIntents: 'transactionIntents',
    PolicyRules: 'policyRules'
} as const;

export type PolicyResponseExpandable = typeof PolicyResponseExpandable[keyof typeof PolicyResponseExpandable];


/**
 * 
 * @export
 * @interface PolicyResponsePolicyRulesInner
 */
export interface PolicyResponsePolicyRulesInner {
    /**
     * 
     * @type {string}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {number}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'createdAt': number;
    /**
     * 
     * @type {PolicyRuleTypeRATELIMIT}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'type': PolicyRuleTypeRATELIMIT;
    /**
     * 
     * @type {ContractPolicyRuleResponseContract}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'contract': ContractPolicyRuleResponseContract;
    /**
     * 
     * @type {PolicyRateLimitCOUNTPERINTERVAL}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'functionName': PolicyRateLimitCOUNTPERINTERVAL;
    /**
     * 
     * @type {string}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'gasLimit': string;
    /**
     * 
     * @type {TimeIntervalType}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'timeIntervalType': TimeIntervalType;
    /**
     * 
     * @type {number}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'timeIntervalValue': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'countLimit': number;
}


/**
 * 
 * @export
 * @interface PolicyRuleDeleteResponse
 */
export interface PolicyRuleDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof PolicyRuleDeleteResponse
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {boolean}
     * @memberof PolicyRuleDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface PolicyRuleListQueries
 */
export interface PolicyRuleListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof PolicyRuleListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof PolicyRuleListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof PolicyRuleListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the fields to expand in the response.
     * @type {Array<string>}
     * @memberof PolicyRuleListQueries
     */
    'expand'?: Array<PolicyRuleListQueriesExpandEnum>;
    /**
     * Specifies the unique policy ID (starts with pol_).
     * @type {string}
     * @memberof PolicyRuleListQueries
     */
    'policy': string;
}

export const PolicyRuleListQueriesExpandEnum = {
    Contract: 'contract'
} as const;

export type PolicyRuleListQueriesExpandEnum = typeof PolicyRuleListQueriesExpandEnum[keyof typeof PolicyRuleListQueriesExpandEnum];

/**
 * 
 * @export
 * @interface PolicyRuleListResponse
 */
export interface PolicyRuleListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof PolicyRuleListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<PolicyRuleResponse>}
     * @memberof PolicyRuleListResponse
     */
    'data': Array<PolicyRuleResponse>;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface PolicyRuleResponse
 */
export interface PolicyRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof PolicyRuleResponse
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {PolicyRuleTypeRATELIMIT}
     * @memberof PolicyRuleResponse
     */
    'type': PolicyRuleTypeRATELIMIT;
    /**
     * 
     * @type {ContractPolicyRuleResponseContract}
     * @memberof PolicyRuleResponse
     */
    'contract': ContractPolicyRuleResponseContract;
    /**
     * 
     * @type {PolicyRateLimitCOUNTPERINTERVAL}
     * @memberof PolicyRuleResponse
     */
    'functionName': PolicyRateLimitCOUNTPERINTERVAL;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleResponse
     */
    'gasLimit': string;
    /**
     * 
     * @type {TimeIntervalType}
     * @memberof PolicyRuleResponse
     */
    'timeIntervalType': TimeIntervalType;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleResponse
     */
    'timeIntervalValue': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleResponse
     */
    'countLimit': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRuleType = {
    ContractFunctions: 'contract_functions',
    AccountFunctions: 'account_functions',
    RateLimit: 'rate_limit'
} as const;

export type PolicyRuleType = typeof PolicyRuleType[keyof typeof PolicyRuleType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRuleTypeACCOUNT = {
    AccountFunctions: 'account_functions'
} as const;

export type PolicyRuleTypeACCOUNT = typeof PolicyRuleTypeACCOUNT[keyof typeof PolicyRuleTypeACCOUNT];


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRuleTypeCONTRACT = {
    ContractFunctions: 'contract_functions'
} as const;

export type PolicyRuleTypeCONTRACT = typeof PolicyRuleTypeCONTRACT[keyof typeof PolicyRuleTypeCONTRACT];


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRuleTypeRATELIMIT = {
    RateLimit: 'rate_limit'
} as const;

export type PolicyRuleTypeRATELIMIT = typeof PolicyRuleTypeRATELIMIT[keyof typeof PolicyRuleTypeRATELIMIT];


/**
 * 
 * @export
 * @interface PolicyStrategy
 */
export interface PolicyStrategy {
    /**
     * 
     * @type {SponsorSchemaFIXEDRATE}
     * @memberof PolicyStrategy
     */
    'sponsorSchema': SponsorSchemaFIXEDRATE;
    /**
     * 
     * @type {string}
     * @memberof PolicyStrategy
     */
    'depositor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PolicyStrategy
     */
    'tokenContract': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyStrategy
     */
    'tokenContractAmount': string;
}


/**
 * 
 * @export
 * @interface PolicyStrategyRequest
 */
export interface PolicyStrategyRequest {
    /**
     * 
     * @type {SponsorSchema}
     * @memberof PolicyStrategyRequest
     */
    'sponsorSchema': SponsorSchema;
    /**
     * If the user pays in custom tokens, the contract ID (starts with con_) of the token contract.
     * @type {string}
     * @memberof PolicyStrategyRequest
     */
    'tokenContract'?: string;
    /**
     * If the user pays in ERC20 tokens, this reflects either the exchange rate or the amount in WEI.
     * @type {string}
     * @memberof PolicyStrategyRequest
     */
    'tokenContractAmount'?: string;
    /**
     * If the you want to use your own native tokens to pay for gas, specify the depositor ID (starts with dep_)
     * @type {string}
     * @memberof PolicyStrategyRequest
     */
    'depositor'?: string;
}


/**
 * Matches any valid value that can be used as an input for operations like create and update as the value of a JSON field. Unlike `JsonValue`, this type allows read-only arrays and read-only object properties and disallows `null` at the top level.  `null` cannot be used as the value of a JSON field because its meaning would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or `Prisma.DbNull` to clear the JSON value and set the field to the database NULL value instead.
 * @export
 * @interface PrismaInputJsonValue
 */
export interface PrismaInputJsonValue {
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PrivateKeyPolicy = {
    Individual: 'INDIVIDUAL',
    Project: 'PROJECT'
} as const;

export type PrivateKeyPolicy = typeof PrivateKeyPolicy[keyof typeof PrivateKeyPolicy];


/**
 * 
 * @export
 * @interface ProjectListResponse
 */
export interface ProjectListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof ProjectListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof ProjectListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<ProjectResponse>}
     * @memberof ProjectListResponse
     */
    'data': Array<ProjectResponse>;
    /**
     * 
     * @type {number}
     * @memberof ProjectListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface ProjectLogs
 */
export interface ProjectLogs {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof ProjectLogs
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof ProjectLogs
     */
    'url': string;
    /**
     * 
     * @type {Array<Log>}
     * @memberof ProjectLogs
     */
    'data': Array<Log>;
    /**
     * 
     * @type {number}
     * @memberof ProjectLogs
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectLogs
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectLogs
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface ProjectResponse
 */
export interface ProjectResponse {
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePROJECT}
     * @memberof ProjectResponse
     */
    'object': EntityTypePROJECT;
    /**
     * 
     * @type {number}
     * @memberof ProjectResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectResponse
     */
    'updatedAt': number;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<ApiKeyResponse>}
     * @memberof ProjectResponse
     */
    'apikeys'?: Array<ApiKeyResponse>;
    /**
     * 
     * @type {Array<WebhookResponse>}
     * @memberof ProjectResponse
     */
    'webhook'?: Array<WebhookResponse>;
}


/**
 * 
 * @export
 * @interface ProjectWebhookRequest
 */
export interface ProjectWebhookRequest {
    /**
     * 
     * @type {string}
     * @memberof ProjectWebhookRequest
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectWebhookRequest
     */
    'apiKey'?: string;
}
/**
 * 
 * @export
 * @interface ResponseResponse
 */
export interface ResponseResponse {
    /**
     * The unix timestamp in seconds when the transactionIntent was created.
     * @type {number}
     * @memberof ResponseResponse
     */
    'createdAt': number;
    /**
     * The block height (number) of the block including the transaction of this log.
     * @type {number}
     * @memberof ResponseResponse
     */
    'blockNumber'?: number;
    /**
     * The transaction hash of the transaction of this log.
     * @type {string}
     * @memberof ResponseResponse
     */
    'transactionHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseResponse
     * @deprecated
     */
    'userOpHash'?: string;
    /**
     * The gas used by the transaction of this log.
     * @type {string}
     * @memberof ResponseResponse
     */
    'l1GasUsed'?: string;
    /**
     * The gas used by the transaction of this log.
     * @type {number}
     * @memberof ResponseResponse
     */
    'gasUsed'?: number;
    /**
     * The status of the transaction of this log.
     * @type {number}
     * @memberof ResponseResponse
     */
    'status'?: number;
    /**
     * The logs of the transaction of this log.
     * @type {Array<Log>}
     * @memberof ResponseResponse
     */
    'logs'?: Array<Log>;
    /**
     * The address of the contract of this log.
     * @type {string}
     * @memberof ResponseResponse
     */
    'to'?: string;
    /**
     * The error of the transaction of this log.
     * @type {any}
     * @memberof ResponseResponse
     */
    'error'?: any;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ResponseTypeLIST = {
    List: 'list'
} as const;

export type ResponseTypeLIST = typeof ResponseTypeLIST[keyof typeof ResponseTypeLIST];


/**
 * 
 * @export
 * @interface RevokeSessionPlayerRequest
 */
export interface RevokeSessionPlayerRequest {
    /**
     * The address of the session key to revoke.
     * @type {string}
     * @memberof RevokeSessionPlayerRequest
     */
    'address': string;
    /**
     * The policy ID (starts with pol_)
     * @type {string}
     * @memberof RevokeSessionPlayerRequest
     */
    'policy'?: string;
    /**
     * Whether the transactionIntent is optimistic (resolve before it arrives on chain) or not.
     * @type {boolean}
     * @memberof RevokeSessionPlayerRequest
     */
    'optimistic'?: boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof RevokeSessionPlayerRequest
     */
    'chainId': number;
}
/**
 * 
 * @export
 * @interface RevokeSessionRequest
 */
export interface RevokeSessionRequest {
    /**
     * The address of the session key to revoke.
     * @type {string}
     * @memberof RevokeSessionRequest
     */
    'address': string;
    /**
     * The policy ID (starts with pol_)
     * @type {string}
     * @memberof RevokeSessionRequest
     */
    'policy'?: string;
    /**
     * Whether the transactionIntent is optimistic (resolve before it arrives on chain) or not.
     * @type {boolean}
     * @memberof RevokeSessionRequest
     */
    'optimistic'?: boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof RevokeSessionRequest
     */
    'chainId': number;
    /**
     * The player ID (starts with pla_).
     * @type {string}
     * @memberof RevokeSessionRequest
     */
    'player': string;
}
/**
 * 
 * @export
 * @interface SessionListQueries
 */
export interface SessionListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof SessionListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof SessionListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof SessionListQueries
     */
    'order'?: SortOrder;
    /**
     * The player ID (starts with pla_)
     * @type {string}
     * @memberof SessionListQueries
     */
    'player': string;
    /**
     * Specifies the fields to expand in the response.
     * @type {Array<SessionResponseExpandable>}
     * @memberof SessionListQueries
     */
    'expand'?: Array<SessionResponseExpandable>;
}


/**
 * 
 * @export
 * @interface SessionListResponse
 */
export interface SessionListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof SessionListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof SessionListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<SessionResponse>}
     * @memberof SessionListResponse
     */
    'data': Array<SessionResponse>;
    /**
     * 
     * @type {number}
     * @memberof SessionListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof SessionListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof SessionListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface SessionResponse
 */
export interface SessionResponse {
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeSESSION}
     * @memberof SessionResponse
     */
    'object': EntityTypeSESSION;
    /**
     * 
     * @type {number}
     * @memberof SessionResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof SessionResponse
     */
    'updatedAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof SessionResponse
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'validAfter'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'validUntil'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SessionResponse
     */
    'whitelist'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SessionResponse
     */
    'limit'?: number;
    /**
     * 
     * @type {NextActionResponse}
     * @memberof SessionResponse
     */
    'nextAction'?: NextActionResponse;
    /**
     * 
     * @type {Array<PlayerResponseTransactionIntentsInner>}
     * @memberof SessionResponse
     */
    'transactionIntents'?: Array<PlayerResponseTransactionIntentsInner>;
}


/**
 * Contains list of the expandable fields for the session response
 * @export
 * @enum {string}
 */

export const SessionResponseExpandable = {
    TransactionIntents: 'transactionIntents'
} as const;

export type SessionResponseExpandable = typeof SessionResponseExpandable[keyof typeof SessionResponseExpandable];


/**
 * 
 * @export
 * @interface SettingsWebhookUpdateRequest
 */
export interface SettingsWebhookUpdateRequest {
    /**
     * The webhook url.
     * @type {string}
     * @memberof SettingsWebhookUpdateRequest
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface SignPayloadRequest
 */
export interface SignPayloadRequest {
    /**
     * 
     * @type {DomainData}
     * @memberof SignPayloadRequest
     */
    'domain': DomainData;
    /**
     * 
     * @type {{ [key: string]: Array<TypedDataField>; }}
     * @memberof SignPayloadRequest
     */
    'types': { [key: string]: Array<TypedDataField>; };
    /**
     * 
     * @type {string}
     * @memberof SignPayloadRequest
     */
    'primaryType': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SignPayloadRequest
     */
    'value': { [key: string]: any; };
    /**
     * Hash to verify and that will be signed
     * @type {string}
     * @memberof SignPayloadRequest
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface SignPayloadResponse
 */
export interface SignPayloadResponse {
    /**
     * 
     * @type {EntityTypeSIGNATURE}
     * @memberof SignPayloadResponse
     */
    'object': EntityTypeSIGNATURE;
    /**
     * 
     * @type {string}
     * @memberof SignPayloadResponse
     */
    'account': string;
    /**
     * 
     * @type {string}
     * @memberof SignPayloadResponse
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof SignPayloadResponse
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof SignPayloadResponse
     */
    'signature': string;
}


/**
 * 
 * @export
 * @interface SignatureRequest
 */
export interface SignatureRequest {
    /**
     * signed userOperationHash by the owner or valid session key
     * @type {string}
     * @memberof SignatureRequest
     */
    'signature': string;
    /**
     * Whether the transactionIntent is optimistic (resolve before it arrives on chain) or not.
     * @type {boolean}
     * @memberof SignatureRequest
     */
    'optimistic'?: boolean;
}
/**
 * 
 * @export
 * @interface SignupRequest
 */
export interface SignupRequest {
    /**
     * The email address of the user.
     * @type {string}
     * @memberof SignupRequest
     */
    'email': string;
    /**
     * The password of the user.
     * @type {string}
     * @memberof SignupRequest
     */
    'password': string;
    /**
     * The name of the user.
     * @type {string}
     * @memberof SignupRequest
     */
    'name': string;
    /**
     * The description of the user.
     * @type {string}
     * @memberof SignupRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SortOrder = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortOrder = typeof SortOrder[keyof typeof SortOrder];


/**
 * 
 * @export
 * @enum {string}
 */

export const SponsorSchema = {
    PayForUser: 'pay_for_user',
    ChargeCustomTokens: 'charge_custom_tokens',
    FixedRate: 'fixed_rate'
} as const;

export type SponsorSchema = typeof SponsorSchema[keyof typeof SponsorSchema];


/**
 * 
 * @export
 * @enum {string}
 */

export const SponsorSchemaCHARGECUSTOMTOKENS = {
    ChargeCustomTokens: 'charge_custom_tokens'
} as const;

export type SponsorSchemaCHARGECUSTOMTOKENS = typeof SponsorSchemaCHARGECUSTOMTOKENS[keyof typeof SponsorSchemaCHARGECUSTOMTOKENS];


/**
 * 
 * @export
 * @enum {string}
 */

export const SponsorSchemaFIXEDRATE = {
    FixedRate: 'fixed_rate'
} as const;

export type SponsorSchemaFIXEDRATE = typeof SponsorSchemaFIXEDRATE[keyof typeof SponsorSchemaFIXEDRATE];


/**
 * 
 * @export
 * @enum {string}
 */

export const SponsorSchemaPAYFORUSER = {
    PayForUser: 'pay_for_user'
} as const;

export type SponsorSchemaPAYFORUSER = typeof SponsorSchemaPAYFORUSER[keyof typeof SponsorSchemaPAYFORUSER];


/**
 * 
 * @export
 * @interface StartRecoveryRequest
 */
export interface StartRecoveryRequest {
    /**
     * Address of the new owner
     * @type {string}
     * @memberof StartRecoveryRequest
     */
    'newOwnerAddress': string;
    /**
     * The policy ID (starts with pol_)
     * @type {string}
     * @memberof StartRecoveryRequest
     */
    'policy': string;
}
/**
 * 
 * @export
 * @interface SubmitWeb3ActionRequest
 */
export interface SubmitWeb3ActionRequest {
    /**
     * True to approve the action, false to reject it.
     * @type {boolean}
     * @memberof SubmitWeb3ActionRequest
     */
    'approve': boolean;
    /**
     * The policy ID (starts with pol_)
     * @type {string}
     * @memberof SubmitWeb3ActionRequest
     */
    'policy'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TimeIntervalType = {
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;

export type TimeIntervalType = typeof TimeIntervalType[keyof typeof TimeIntervalType];


/**
 * 
 * @export
 * @interface TransactionIntent
 */
export interface TransactionIntent {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntent
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeTRANSACTIONINTENT}
     * @memberof TransactionIntent
     */
    'object': EntityTypeTRANSACTIONINTENT;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntent
     */
    'createdAt': number;
    /**
     * The unix timestamp in seconds when the transactionIntent was created.
     * @type {number}
     * @memberof TransactionIntent
     */
    'updatedAt': number;
    /**
     * The chain ID.
     * @type {number}
     * @memberof TransactionIntent
     */
    'chainId': number;
    /**
     * The hashed userOperation.
     * @type {string}
     * @memberof TransactionIntent
     */
    'userOperationHash'?: string;
    /**
     * 
     * @type {any}
     * @memberof TransactionIntent
     */
    'userOperation'?: any;
    /**
     * 
     * @type {ResponseResponse}
     * @memberof TransactionIntent
     */
    'response'?: ResponseResponse;
    /**
     * 
     * @type {Array<Interaction>}
     * @memberof TransactionIntent
     */
    'interactions'?: Array<Interaction>;
    /**
     * 
     * @type {NextActionResponse}
     * @memberof TransactionIntent
     */
    'nextAction'?: NextActionResponse;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof TransactionIntent
     */
    'policy'?: EntityIdResponse;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof TransactionIntent
     */
    'player': EntityIdResponse;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof TransactionIntent
     */
    'account': EntityIdResponse;
}


/**
 * 
 * @export
 * @interface TransactionIntentListQueries
 */
export interface TransactionIntentListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof TransactionIntentListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof TransactionIntentListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof TransactionIntentListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the fields to expand in the response.
     * @type {Array<TransactionIntentResponseExpandable>}
     * @memberof TransactionIntentListQueries
     */
    'expand'?: Array<TransactionIntentResponseExpandable>;
    /**
     * The chain ID.
     * @type {number}
     * @memberof TransactionIntentListQueries
     */
    'chainId'?: number;
    /**
     * Filter by account ID.
     * @type {Array<string>}
     * @memberof TransactionIntentListQueries
     */
    'accountId'?: Array<string>;
    /**
     * Filter by player ID (starts with pla_).
     * @type {Array<string>}
     * @memberof TransactionIntentListQueries
     */
    'playerId'?: Array<string>;
    /**
     * Filter by policy ID (starts with pol_).
     * @type {Array<string>}
     * @memberof TransactionIntentListQueries
     */
    'policyId'?: Array<string>;
}


/**
 * 
 * @export
 * @interface TransactionIntentListResponse
 */
export interface TransactionIntentListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof TransactionIntentListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<TransactionIntentResponse>}
     * @memberof TransactionIntentListResponse
     */
    'data': Array<TransactionIntentResponse>;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface TransactionIntentResponse
 */
export interface TransactionIntentResponse {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeTRANSACTIONINTENT}
     * @memberof TransactionIntentResponse
     */
    'object': EntityTypeTRANSACTIONINTENT;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponse
     */
    'createdAt': number;
    /**
     * The unix timestamp in seconds when the transactionIntent was created.
     * @type {number}
     * @memberof TransactionIntentResponse
     */
    'updatedAt': number;
    /**
     * The chain ID.
     * @type {number}
     * @memberof TransactionIntentResponse
     */
    'chainId': number;
    /**
     * The hashed userOperation.
     * @type {string}
     * @memberof TransactionIntentResponse
     */
    'userOperationHash'?: string;
    /**
     * 
     * @type {any}
     * @memberof TransactionIntentResponse
     */
    'userOperation'?: any;
    /**
     * 
     * @type {ResponseResponse}
     * @memberof TransactionIntentResponse
     */
    'response'?: ResponseResponse;
    /**
     * 
     * @type {Array<Interaction>}
     * @memberof TransactionIntentResponse
     */
    'interactions'?: Array<Interaction>;
    /**
     * 
     * @type {NextActionResponse}
     * @memberof TransactionIntentResponse
     */
    'nextAction'?: NextActionResponse;
    /**
     * 
     * @type {TransactionIntentResponsePolicy}
     * @memberof TransactionIntentResponse
     */
    'policy'?: TransactionIntentResponsePolicy;
    /**
     * 
     * @type {TransactionIntentResponsePlayer}
     * @memberof TransactionIntentResponse
     */
    'player': TransactionIntentResponsePlayer;
    /**
     * 
     * @type {TransactionIntentResponseAccount}
     * @memberof TransactionIntentResponse
     */
    'account': TransactionIntentResponseAccount;
}


/**
 * The account ID.
 * @export
 * @interface TransactionIntentResponseAccount
 */
export interface TransactionIntentResponseAccount {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponseAccount
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeACCOUNT}
     * @memberof TransactionIntentResponseAccount
     */
    'object': EntityTypeACCOUNT;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponseAccount
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponseAccount
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponseAccount
     */
    'ownerAddress': string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIntentResponseAccount
     */
    'deployed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIntentResponseAccount
     */
    'custodial': boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof TransactionIntentResponseAccount
     */
    'chainId': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponseAccount
     */
    'accountType': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponseAccount
     */
    'pendingOwnerAddress'?: string;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof TransactionIntentResponseAccount
     */
    'transactionIntents'?: Array<EntityIdResponse>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionIntentResponseExpandable = {
    NextAction: 'nextAction',
    Policy: 'policy',
    Player: 'player',
    Account: 'account'
} as const;

export type TransactionIntentResponseExpandable = typeof TransactionIntentResponseExpandable[keyof typeof TransactionIntentResponseExpandable];


/**
 * The player ID (starts with pla_).
 * @export
 * @interface TransactionIntentResponsePlayer
 */
export interface TransactionIntentResponsePlayer {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePlayer
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePLAYER}
     * @memberof TransactionIntentResponsePlayer
     */
    'object': EntityTypePLAYER;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponsePlayer
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePlayer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePlayer
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: PlayerMetadataValue; }}
     * @memberof TransactionIntentResponsePlayer
     */
    'metadata'?: { [key: string]: PlayerMetadataValue; };
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof TransactionIntentResponsePlayer
     */
    'transactionIntents'?: Array<EntityIdResponse>;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof TransactionIntentResponsePlayer
     */
    'accounts'?: Array<EntityIdResponse>;
}


/**
 * The policy ID (starts with pol_).
 * @export
 * @interface TransactionIntentResponsePolicy
 */
export interface TransactionIntentResponsePolicy {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePolicy
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICY}
     * @memberof TransactionIntentResponsePolicy
     */
    'object': EntityTypePOLICY;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponsePolicy
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePolicy
     */
    'name': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIntentResponsePolicy
     */
    'deleted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIntentResponsePolicy
     */
    'enabled': boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof TransactionIntentResponsePolicy
     */
    'chainId': number;
    /**
     * 
     * @type {PolicyStrategy}
     * @memberof TransactionIntentResponsePolicy
     */
    'strategy': PolicyStrategy;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof TransactionIntentResponsePolicy
     */
    'transactionIntents': Array<EntityIdResponse>;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof TransactionIntentResponsePolicy
     */
    'policyRules': Array<EntityIdResponse>;
}


/**
 * 
 * @export
 * @interface TransferOwnershipRequest
 */
export interface TransferOwnershipRequest {
    /**
     * The address of the new owner
     * @type {string}
     * @memberof TransferOwnershipRequest
     */
    'newOwnerAddress': string;
    /**
     * The policy ID (starts with pol_)
     * @type {string}
     * @memberof TransferOwnershipRequest
     */
    'policy': string;
}
/**
 * 
 * @export
 * @interface TypedDataField
 */
export interface TypedDataField {
    /**
     * 
     * @type {string}
     * @memberof TypedDataField
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TypedDataField
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface UpdateContractRequest
 */
export interface UpdateContractRequest {
    /**
     * Specifies the name of the contract (Only for display purposes).
     * @type {string}
     * @memberof UpdateContractRequest
     */
    'name'?: string;
    /**
     * Specifies the chain ID of the contract.
     * @type {number}
     * @memberof UpdateContractRequest
     */
    'chainId'?: number;
    /**
     * Specifies whether to delete the contract.
     * @type {boolean}
     * @memberof UpdateContractRequest
     */
    'deleted'?: boolean;
    /**
     * Specifies the address of the contract.
     * @type {string}
     * @memberof UpdateContractRequest
     */
    'address'?: string;
    /**
     * Specifies the ABI of the contract.
     * @type {Array<Abi>}
     * @memberof UpdateContractRequest
     */
    'abi'?: Array<Abi>;
    /**
     * Specifies whether to verify the contract publicly.
     * @type {boolean}
     * @memberof UpdateContractRequest
     */
    'publicVerification'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdatePolicyRequest
 */
export interface UpdatePolicyRequest {
    /**
     * Specifies the name of the policy.
     * @type {string}
     * @memberof UpdatePolicyRequest
     */
    'name'?: string;
    /**
     * The chain ID of the policy.
     * @type {number}
     * @memberof UpdatePolicyRequest
     */
    'chainId'?: number;
    /**
     * 
     * @type {PolicyStrategyRequest}
     * @memberof UpdatePolicyRequest
     */
    'strategy'?: PolicyStrategyRequest;
    /**
     * Specifies whether to delete the policy.
     * @type {boolean}
     * @memberof UpdatePolicyRequest
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdatePolicyRuleRequest
 */
export interface UpdatePolicyRuleRequest {
    /**
     * 
     * @type {PolicyRuleType}
     * @memberof UpdatePolicyRuleRequest
     */
    'type': PolicyRuleType;
    /**
     * Name of the function in the contract to allow.
     * @type {string}
     * @memberof UpdatePolicyRuleRequest
     */
    'functionName'?: string | null;
    /**
     * Contract ID to allow.
     * @type {string}
     * @memberof UpdatePolicyRuleRequest
     */
    'contract'?: string | null;
    /**
     * Gas limit in WEI.
     * @type {string}
     * @memberof UpdatePolicyRuleRequest
     */
    'gasLimit'?: string;
    /**
     * Number of times the function will be sponsored.
     * @type {number}
     * @memberof UpdatePolicyRuleRequest
     */
    'countLimit'?: number;
    /**
     * 
     * @type {TimeIntervalType}
     * @memberof UpdatePolicyRuleRequest
     */
    'timeIntervalType'?: TimeIntervalType;
    /**
     * Time interval value.
     * @type {number}
     * @memberof UpdatePolicyRuleRequest
     */
    'timeIntervalValue'?: number;
}


/**
 * 
 * @export
 * @interface UpdateProjectApiKeyRequest
 */
export interface UpdateProjectApiKeyRequest {
    /**
     * 
     * @type {ApiKeyType}
     * @memberof UpdateProjectApiKeyRequest
     */
    'type': ApiKeyType;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectApiKeyRequest
     */
    'uuid': string;
}


/**
 * 
 * @export
 * @interface UpdateProjectRequest
 */
export interface UpdateProjectRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UserProjectCreateRequest
 */
export interface UserProjectCreateRequest {
    /**
     * 
     * @type {UserProjectCreateRequestRole}
     * @memberof UserProjectCreateRequest
     */
    'role'?: UserProjectCreateRequestRole;
    /**
     * 
     * @type {string}
     * @memberof UserProjectCreateRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface UserProjectCreateRequestRole
 */
export interface UserProjectCreateRequestRole {
}
/**
 * 
 * @export
 * @interface UserProjectDeleteResponse
 */
export interface UserProjectDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof UserProjectDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeUSER}
     * @memberof UserProjectDeleteResponse
     */
    'object': EntityTypeUSER;
    /**
     * 
     * @type {boolean}
     * @memberof UserProjectDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface UserProjectListResponse
 */
export interface UserProjectListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof UserProjectListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof UserProjectListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<UserProjectResponse>}
     * @memberof UserProjectListResponse
     */
    'data': Array<UserProjectResponse>;
    /**
     * 
     * @type {number}
     * @memberof UserProjectListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof UserProjectListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof UserProjectListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface UserProjectResponse
 */
export interface UserProjectResponse {
    /**
     * 
     * @type {string}
     * @memberof UserProjectResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeUSER}
     * @memberof UserProjectResponse
     */
    'object': EntityTypeUSER;
    /**
     * 
     * @type {number}
     * @memberof UserProjectResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof UserProjectResponse
     */
    'updatedAt': number;
    /**
     * 
     * @type {string}
     * @memberof UserProjectResponse
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserProjectResponse
     */
    'lastName': string;
    /**
     * 
     * @type {UserProjectRole}
     * @memberof UserProjectResponse
     */
    'role': UserProjectRole;
    /**
     * 
     * @type {string}
     * @memberof UserProjectResponse
     */
    'email': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserProjectRole = {
    Owner: 'OWNER',
    Admin: 'ADMIN',
    Member: 'MEMBER'
} as const;

export type UserProjectRole = typeof UserProjectRole[keyof typeof UserProjectRole];


/**
 * 
 * @export
 * @enum {string}
 */

export const UserProjectRoleADMIN = {
    Admin: 'ADMIN'
} as const;

export type UserProjectRoleADMIN = typeof UserProjectRoleADMIN[keyof typeof UserProjectRoleADMIN];


/**
 * 
 * @export
 * @enum {string}
 */

export const UserProjectRoleMEMBER = {
    Member: 'MEMBER'
} as const;

export type UserProjectRoleMEMBER = typeof UserProjectRoleMEMBER[keyof typeof UserProjectRoleMEMBER];


/**
 * 
 * @export
 * @interface UserProjectUpdateRequest
 */
export interface UserProjectUpdateRequest {
    /**
     * 
     * @type {UserProjectCreateRequestRole}
     * @memberof UserProjectUpdateRequest
     */
    'role': UserProjectCreateRequestRole;
}
/**
 * 
 * @export
 * @interface Web3ActionListResponse
 */
export interface Web3ActionListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof Web3ActionListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof Web3ActionListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<Web3ActionResponse>}
     * @memberof Web3ActionListResponse
     */
    'data': Array<Web3ActionResponse>;
    /**
     * 
     * @type {number}
     * @memberof Web3ActionListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof Web3ActionListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof Web3ActionListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface Web3ActionResponse
 */
export interface Web3ActionResponse {
    /**
     * 
     * @type {string}
     * @memberof Web3ActionResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeWEB3ACTION}
     * @memberof Web3ActionResponse
     */
    'object': EntityTypeWEB3ACTION;
    /**
     * 
     * @type {number}
     * @memberof Web3ActionResponse
     */
    'createdAt': number;
    /**
     * The web3_connection ID (starts with web3_).
     * @type {string}
     * @memberof Web3ActionResponse
     */
    'web3_connection': string;
    /**
     * 
     * @type {Web3ActionStatusEnum}
     * @memberof Web3ActionResponse
     */
    'status': Web3ActionStatusEnum;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const Web3ActionStatusEnum = {
    Pending: 'Pending',
    Approved: 'Approved',
    Rejected: 'Rejected',
    Expired: 'Expired',
    Failed: 'Failed'
} as const;

export type Web3ActionStatusEnum = typeof Web3ActionStatusEnum[keyof typeof Web3ActionStatusEnum];


/**
 * 
 * @export
 * @interface Web3ConnectionListQueries
 */
export interface Web3ConnectionListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof Web3ConnectionListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof Web3ConnectionListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof Web3ConnectionListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the unique player ID (starts with pla_)
     * @type {string}
     * @memberof Web3ConnectionListQueries
     */
    'player': string;
    /**
     * Specifies connection status
     * @type {boolean}
     * @memberof Web3ConnectionListQueries
     */
    'disconnected'?: boolean;
}


/**
 * 
 * @export
 * @interface Web3ConnectionListResponse
 */
export interface Web3ConnectionListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof Web3ConnectionListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof Web3ConnectionListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<Web3ConnectionResponse>}
     * @memberof Web3ConnectionListResponse
     */
    'data': Array<Web3ConnectionResponse>;
    /**
     * 
     * @type {number}
     * @memberof Web3ConnectionListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof Web3ConnectionListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof Web3ConnectionListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface Web3ConnectionResponse
 */
export interface Web3ConnectionResponse {
    /**
     * 
     * @type {string}
     * @memberof Web3ConnectionResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeWEB3CONNECTION}
     * @memberof Web3ConnectionResponse
     */
    'object': EntityTypeWEB3CONNECTION;
    /**
     * 
     * @type {number}
     * @memberof Web3ConnectionResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof Web3ConnectionResponse
     */
    'disconnected': boolean;
    /**
     * 
     * @type {Web3ConnectionResponsePlayer}
     * @memberof Web3ConnectionResponse
     */
    'player': Web3ConnectionResponsePlayer;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const Web3ConnectionResponseExpandable = {
    Player: 'player'
} as const;

export type Web3ConnectionResponseExpandable = typeof Web3ConnectionResponseExpandable[keyof typeof Web3ConnectionResponseExpandable];


/**
 * The player ID (starts with pla_).
 * @export
 * @interface Web3ConnectionResponsePlayer
 */
export interface Web3ConnectionResponsePlayer {
    /**
     * 
     * @type {string}
     * @memberof Web3ConnectionResponsePlayer
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePLAYER}
     * @memberof Web3ConnectionResponsePlayer
     */
    'object': EntityTypePLAYER;
    /**
     * 
     * @type {number}
     * @memberof Web3ConnectionResponsePlayer
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof Web3ConnectionResponsePlayer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Web3ConnectionResponsePlayer
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: PlayerMetadataValue; }}
     * @memberof Web3ConnectionResponsePlayer
     */
    'metadata'?: { [key: string]: PlayerMetadataValue; };
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof Web3ConnectionResponsePlayer
     */
    'transactionIntents'?: Array<EntityIdResponse>;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof Web3ConnectionResponsePlayer
     */
    'accounts'?: Array<EntityIdResponse>;
}


/**
 * 
 * @export
 * @interface WebhookResponse
 */
export interface WebhookResponse {
    /**
     * 
     * @type {string}
     * @memberof WebhookResponse
     */
    'webhook': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookResponse
     */
    'livemode': boolean;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows you to cancel a pending transfer of ownership.
         * @summary Cancel request of ownership transfer of an account.
         * @param {string} id Specifies the unique account ID.
         * @param {CancelTransferOwnershipRequest} cancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransferOwnership: async (id: string, cancelTransferOwnershipRequest: CancelTransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelTransferOwnership', 'id', id)
            // verify required parameter 'cancelTransferOwnershipRequest' is not null or undefined
            assertParamExists('cancelTransferOwnership', 'cancelTransferOwnershipRequest', cancelTransferOwnershipRequest)
            const localVarPath = `/v1/accounts/{id}/cancel_transfer_ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelTransferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID.
         * @param {CompleteRecoveryRequest} completeRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeRecovery: async (id: string, completeRecoveryRequest: CompleteRecoveryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeRecovery', 'id', id)
            // verify required parameter 'completeRecoveryRequest' is not null or undefined
            assertParamExists('completeRecovery', 'completeRecoveryRequest', completeRecoveryRequest)
            const localVarPath = `/v1/accounts/{id}/complete_recovery`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeRecoveryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to add a new account to your Openfort player. Only one account can be active per chain per player.
         * @summary Create an account object.
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (createAccountRequest: CreateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountRequest' is not null or undefined
            assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing account. Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
         * @summary Get existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {Array<AccountResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: string, expand?: Array<AccountResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of accounts for the given player. The accounts are returned sorted by creation date, with the most recently created accounts appearing first. By default, a maximum of ten accounts are shown per page.
         * @summary List accounts of a player.
         * @param {string} player Specifies the unique player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<AccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<AccountResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'player' is not null or undefined
            assertParamExists('getAccounts', 'player', player)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request ownership transfer of an account.
         * @param {string} id Specifies the unique account ID.
         * @param {TransferOwnershipRequest} transferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTransferOwnership: async (id: string, transferOwnershipRequest: TransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('requestTransferOwnership', 'id', id)
            // verify required parameter 'transferOwnershipRequest' is not null or undefined
            assertParamExists('requestTransferOwnership', 'transferOwnershipRequest', transferOwnershipRequest)
            const localVarPath = `/v1/accounts/{id}/request_transfer_ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign a given payload
         * @param {string} id Specifies the unique account ID.
         * @param {SignPayloadRequest} signPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signPayload: async (id: string, signPayloadRequest: SignPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signPayload', 'id', id)
            // verify required parameter 'signPayloadRequest' is not null or undefined
            assertParamExists('signPayload', 'signPayloadRequest', signPayloadRequest)
            const localVarPath = `/v1/accounts/{id}/sign_payload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID.
         * @param {StartRecoveryRequest} startRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecovery: async (id: string, startRecoveryRequest: StartRecoveryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startRecovery', 'id', id)
            // verify required parameter 'startRecoveryRequest' is not null or undefined
            assertParamExists('startRecovery', 'startRecoveryRequest', startRecoveryRequest)
            const localVarPath = `/v1/accounts/{id}/start_recovery`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startRecoveryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync account state with the blockchain
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('syncAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}/sync`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows you to cancel a pending transfer of ownership.
         * @summary Cancel request of ownership transfer of an account.
         * @param {string} id Specifies the unique account ID.
         * @param {CancelTransferOwnershipRequest} cancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTransferOwnership(id: string, cancelTransferOwnershipRequest: CancelTransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransferOwnership(id, cancelTransferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Complete a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID.
         * @param {CompleteRecoveryRequest} completeRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeRecovery(id: string, completeRecoveryRequest: CompleteRecoveryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeRecovery(id, completeRecoveryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to add a new account to your Openfort player. Only one account can be active per chain per player.
         * @summary Create an account object.
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(createAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing account. Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
         * @summary Get existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {Array<AccountResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: string, expand?: Array<AccountResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of accounts for the given player. The accounts are returned sorted by creation date, with the most recently created accounts appearing first. By default, a maximum of ten accounts are shown per page.
         * @summary List accounts of a player.
         * @param {string} player Specifies the unique player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<AccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<AccountResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(player, limit, skip, order, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request ownership transfer of an account.
         * @param {string} id Specifies the unique account ID.
         * @param {TransferOwnershipRequest} transferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestTransferOwnership(id: string, transferOwnershipRequest: TransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestTransferOwnership(id, transferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sign a given payload
         * @param {string} id Specifies the unique account ID.
         * @param {SignPayloadRequest} signPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signPayload(id: string, signPayloadRequest: SignPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignPayloadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signPayload(id, signPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID.
         * @param {StartRecoveryRequest} startRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRecovery(id: string, startRecoveryRequest: StartRecoveryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRecovery(id, startRecoveryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sync account state with the blockchain
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * This endpoint allows you to cancel a pending transfer of ownership.
         * @summary Cancel request of ownership transfer of an account.
         * @param {string} id Specifies the unique account ID.
         * @param {CancelTransferOwnershipRequest} cancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransferOwnership(id: string, cancelTransferOwnershipRequest: CancelTransferOwnershipRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.cancelTransferOwnership(id, cancelTransferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complete a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID.
         * @param {CompleteRecoveryRequest} completeRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeRecovery(id: string, completeRecoveryRequest: CompleteRecoveryRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.completeRecovery(id, completeRecoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to add a new account to your Openfort player. Only one account can be active per chain per player.
         * @summary Create an account object.
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(createAccountRequest: CreateAccountRequest, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.createAccount(createAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing account. Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
         * @summary Get existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {Array<AccountResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id: string, expand?: Array<AccountResponseExpandable>, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.getAccount(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of accounts for the given player. The accounts are returned sorted by creation date, with the most recently created accounts appearing first. By default, a maximum of ten accounts are shown per page.
         * @summary List accounts of a player.
         * @param {string} player Specifies the unique player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<AccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<AccountResponseExpandable>, options?: any): AxiosPromise<AccountListResponse> {
            return localVarFp.getAccounts(player, limit, skip, order, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request ownership transfer of an account.
         * @param {string} id Specifies the unique account ID.
         * @param {TransferOwnershipRequest} transferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTransferOwnership(id: string, transferOwnershipRequest: TransferOwnershipRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.requestTransferOwnership(id, transferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign a given payload
         * @param {string} id Specifies the unique account ID.
         * @param {SignPayloadRequest} signPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signPayload(id: string, signPayloadRequest: SignPayloadRequest, options?: any): AxiosPromise<SignPayloadResponse> {
            return localVarFp.signPayload(id, signPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID.
         * @param {StartRecoveryRequest} startRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecovery(id: string, startRecoveryRequest: StartRecoveryRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.startRecovery(id, startRecoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sync account state with the blockchain
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAccount(id: string, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.syncAccount(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * This endpoint allows you to cancel a pending transfer of ownership.
     * @summary Cancel request of ownership transfer of an account.
     * @param {string} id Specifies the unique account ID.
     * @param {CancelTransferOwnershipRequest} cancelTransferOwnershipRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public cancelTransferOwnership(id: string, cancelTransferOwnershipRequest: CancelTransferOwnershipRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).cancelTransferOwnership(id, cancelTransferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complete a recovery process of a recoverable account.
     * @param {string} id Specifies the unique account ID.
     * @param {CompleteRecoveryRequest} completeRecoveryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public completeRecovery(id: string, completeRecoveryRequest: CompleteRecoveryRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).completeRecovery(id, completeRecoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to add a new account to your Openfort player. Only one account can be active per chain per player.
     * @summary Create an account object.
     * @param {CreateAccountRequest} createAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(createAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing account. Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
     * @summary Get existing account.
     * @param {string} id Specifies the unique account ID.
     * @param {Array<AccountResponseExpandable>} [expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(id: string, expand?: Array<AccountResponseExpandable>, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of accounts for the given player. The accounts are returned sorted by creation date, with the most recently created accounts appearing first. By default, a maximum of ten accounts are shown per page.
     * @summary List accounts of a player.
     * @param {string} player Specifies the unique player ID (starts with pla_)
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<AccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<AccountResponseExpandable>, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccounts(player, limit, skip, order, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
     * @summary Request ownership transfer of an account.
     * @param {string} id Specifies the unique account ID.
     * @param {TransferOwnershipRequest} transferOwnershipRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public requestTransferOwnership(id: string, transferOwnershipRequest: TransferOwnershipRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).requestTransferOwnership(id, transferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign a given payload
     * @param {string} id Specifies the unique account ID.
     * @param {SignPayloadRequest} signPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public signPayload(id: string, signPayloadRequest: SignPayloadRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).signPayload(id, signPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a recovery process of a recoverable account.
     * @param {string} id Specifies the unique account ID.
     * @param {StartRecoveryRequest} startRecoveryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public startRecovery(id: string, startRecoveryRequest: StartRecoveryRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).startRecovery(id, startRecoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sync account state with the blockchain
     * @param {string} id Specifies the unique account ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public syncAccount(id: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).syncAccount(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login a player.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/iam/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign up a player.
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (signupRequest: SignupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupRequest' is not null or undefined
            assertParamExists('signup', 'signupRequest', signupRequest)
            const localVarPath = `/iam/v1/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify an auth token.
         * @param {string} token Specifies the auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAuthToken: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('verifyAuthToken', 'token', token)
            const localVarPath = `/iam/v1/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Login a player.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sign up a player.
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(signupRequest: SignupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signup(signupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Verify an auth token.
         * @param {string} token Specifies the auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyAuthToken(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyAuthToken(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Login a player.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: any): AxiosPromise<AuthResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign up a player.
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(signupRequest: SignupRequest, options?: any): AxiosPromise<AuthResponse> {
            return localVarFp.signup(signupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify an auth token.
         * @param {string} token Specifies the auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAuthToken(token: string, options?: any): AxiosPromise<PlayerResponse> {
            return localVarFp.verifyAuthToken(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Login a player.
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(loginRequest: LoginRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign up a player.
     * @param {SignupRequest} signupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signup(signupRequest: SignupRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).signup(signupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify an auth token.
     * @param {string} token Specifies the auth token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public verifyAuthToken(token: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).verifyAuthToken(token, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractsApi - axios parameter creator
 * @export
 */
export const ContractsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new contract to your project in Openfort
         * @summary Create contract object.
         * @param {CreateContractRequest} createContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract: async (createContractRequest: CreateContractRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createContractRequest' is not null or undefined
            assertParamExists('createContract', 'createContractRequest', createContractRequest)
            const localVarPath = `/v1/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createContractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a contract from the project by providing its contract id.
         * @summary Deletes a contract object.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContract: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteContract', 'id', id)
            const localVarPath = `/v1/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a contract by providing their contract id.
         * @summary Get a contract.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContract: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContract', 'id', id)
            const localVarPath = `/v1/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of all contracts per project. By default, a maximum of ten contracts are shown.
         * @summary List contracts.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [name] Specifies the name of the contract.
         * @param {boolean} [deleted] Specifies whether to include deleted contracts.
         * @param {number} [chainId] The chain ID of the contract.
         * @param {string} [address] Specifies the address of the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContracts: async (limit?: number, skip?: number, order?: SortOrder, name?: string, deleted?: boolean, chainId?: number, address?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Using this endpoint, you can get the data returned by any readable function listed in a contracts ABI. This could be things like querying the totalSupply of a currency contract, the number of owners of an items contract, and more.
         * @summary Read on chain contract data.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {string} functionName The function name of the contract.
         * @param {Array<any>} [functionArgs] The function arguments of the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readContract: async (id: string, functionName: string, functionArgs?: Array<any>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readContract', 'id', id)
            // verify required parameter 'functionName' is not null or undefined
            assertParamExists('readContract', 'functionName', functionName)
            const localVarPath = `/v1/contracts/{id}/read`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (functionName !== undefined) {
                localVarQueryParameter['functionName'] = functionName;
            }

            if (functionArgs) {
                localVarQueryParameter['functionArgs'] = functionArgs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a contract object.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {UpdateContractRequest} updateContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContract: async (id: string, updateContractRequest: UpdateContractRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateContract', 'id', id)
            // verify required parameter 'updateContractRequest' is not null or undefined
            assertParamExists('updateContract', 'updateContractRequest', updateContractRequest)
            const localVarPath = `/v1/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsApi - functional programming interface
 * @export
 */
export const ContractsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new contract to your project in Openfort
         * @summary Create contract object.
         * @param {CreateContractRequest} createContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContract(createContractRequest: CreateContractRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContract(createContractRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a contract from the project by providing its contract id.
         * @summary Deletes a contract object.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContract(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContract(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a contract by providing their contract id.
         * @summary Get a contract.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContract(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContract(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List of all contracts per project. By default, a maximum of ten contracts are shown.
         * @summary List contracts.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [name] Specifies the name of the contract.
         * @param {boolean} [deleted] Specifies whether to include deleted contracts.
         * @param {number} [chainId] The chain ID of the contract.
         * @param {string} [address] Specifies the address of the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContracts(limit?: number, skip?: number, order?: SortOrder, name?: string, deleted?: boolean, chainId?: number, address?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContracts(limit, skip, order, name, deleted, chainId, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Using this endpoint, you can get the data returned by any readable function listed in a contracts ABI. This could be things like querying the totalSupply of a currency contract, the number of owners of an items contract, and more.
         * @summary Read on chain contract data.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {string} functionName The function name of the contract.
         * @param {Array<any>} [functionArgs] The function arguments of the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readContract(id: string, functionName: string, functionArgs?: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractReadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readContract(id, functionName, functionArgs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates a contract object.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {UpdateContractRequest} updateContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContract(id: string, updateContractRequest: UpdateContractRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContract(id, updateContractRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractsApi - factory interface
 * @export
 */
export const ContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractsApiFp(configuration)
    return {
        /**
         * Add a new contract to your project in Openfort
         * @summary Create contract object.
         * @param {CreateContractRequest} createContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract(createContractRequest: CreateContractRequest, options?: any): AxiosPromise<ContractResponse> {
            return localVarFp.createContract(createContractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a contract from the project by providing its contract id.
         * @summary Deletes a contract object.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContract(id: string, options?: any): AxiosPromise<ContractDeleteResponse> {
            return localVarFp.deleteContract(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a contract by providing their contract id.
         * @summary Get a contract.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContract(id: string, options?: any): AxiosPromise<ContractResponse> {
            return localVarFp.getContract(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List of all contracts per project. By default, a maximum of ten contracts are shown.
         * @summary List contracts.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [name] Specifies the name of the contract.
         * @param {boolean} [deleted] Specifies whether to include deleted contracts.
         * @param {number} [chainId] The chain ID of the contract.
         * @param {string} [address] Specifies the address of the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContracts(limit?: number, skip?: number, order?: SortOrder, name?: string, deleted?: boolean, chainId?: number, address?: string, options?: any): AxiosPromise<ContractListResponse> {
            return localVarFp.getContracts(limit, skip, order, name, deleted, chainId, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Using this endpoint, you can get the data returned by any readable function listed in a contracts ABI. This could be things like querying the totalSupply of a currency contract, the number of owners of an items contract, and more.
         * @summary Read on chain contract data.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {string} functionName The function name of the contract.
         * @param {Array<any>} [functionArgs] The function arguments of the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readContract(id: string, functionName: string, functionArgs?: Array<any>, options?: any): AxiosPromise<ContractReadResponse> {
            return localVarFp.readContract(id, functionName, functionArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a contract object.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {UpdateContractRequest} updateContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContract(id: string, updateContractRequest: UpdateContractRequest, options?: any): AxiosPromise<ContractResponse> {
            return localVarFp.updateContract(id, updateContractRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractsApi - object-oriented interface
 * @export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI {
    /**
     * Add a new contract to your project in Openfort
     * @summary Create contract object.
     * @param {CreateContractRequest} createContractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public createContract(createContractRequest: CreateContractRequest, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).createContract(createContractRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a contract from the project by providing its contract id.
     * @summary Deletes a contract object.
     * @param {string} id Specifies the unique contract ID (starts with con_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public deleteContract(id: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).deleteContract(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a contract by providing their contract id.
     * @summary Get a contract.
     * @param {string} id Specifies the unique contract ID (starts with con_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getContract(id: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getContract(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of all contracts per project. By default, a maximum of ten contracts are shown.
     * @summary List contracts.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {string} [name] Specifies the name of the contract.
     * @param {boolean} [deleted] Specifies whether to include deleted contracts.
     * @param {number} [chainId] The chain ID of the contract.
     * @param {string} [address] Specifies the address of the contract.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getContracts(limit?: number, skip?: number, order?: SortOrder, name?: string, deleted?: boolean, chainId?: number, address?: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getContracts(limit, skip, order, name, deleted, chainId, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Using this endpoint, you can get the data returned by any readable function listed in a contracts ABI. This could be things like querying the totalSupply of a currency contract, the number of owners of an items contract, and more.
     * @summary Read on chain contract data.
     * @param {string} id Specifies the unique contract ID (starts with con_).
     * @param {string} functionName The function name of the contract.
     * @param {Array<any>} [functionArgs] The function arguments of the contract.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public readContract(id: string, functionName: string, functionArgs?: Array<any>, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).readContract(id, functionName, functionArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a contract object.
     * @param {string} id Specifies the unique contract ID (starts with con_).
     * @param {UpdateContractRequest} updateContractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public updateContract(id: string, updateContractRequest: UpdateContractRequest, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).updateContract(id, updateContractRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GoogleAuthenticationApi - axios parameter creator
 * @export
 */
export const GoogleAuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the google oauth signin url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSigninUrl: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iam/v1/oauth/google/signin_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the google oauth token.
         * @param {string} key Specifies the oauth key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getToken', 'key', key)
            const localVarPath = `/iam/v1/oauth/google/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleAuthenticationApi - functional programming interface
 * @export
 */
export const GoogleAuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoogleAuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the google oauth signin url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSigninUrl(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSigninUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSigninUrl(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the google oauth token.
         * @param {string} key Specifies the oauth key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GoogleAuthenticationApi - factory interface
 * @export
 */
export const GoogleAuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoogleAuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the google oauth signin url.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSigninUrl(options?: any): AxiosPromise<GetSigninUrlResponse> {
            return localVarFp.getSigninUrl(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the google oauth token.
         * @param {string} key Specifies the oauth key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(key: string, options?: any): AxiosPromise<AuthResponse> {
            return localVarFp.getToken(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoogleAuthenticationApi - object-oriented interface
 * @export
 * @class GoogleAuthenticationApi
 * @extends {BaseAPI}
 */
export class GoogleAuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Get the google oauth signin url.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAuthenticationApi
     */
    public getSigninUrl(options?: AxiosRequestConfig) {
        return GoogleAuthenticationApiFp(this.configuration).getSigninUrl(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the google oauth token.
     * @param {string} key Specifies the oauth key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAuthenticationApi
     */
    public getToken(key: string, options?: AxiosRequestConfig) {
        return GoogleAuthenticationApiFp(this.configuration).getToken(key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InventoriesApi - axios parameter creator
 * @export
 */
export const InventoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves the cryptocurrency assets of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCryptoCurrencyInventory: async (id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountCryptoCurrencyInventory', 'id', id)
            const localVarPath = `/v1/accounts/{id}/inventory/cryptocurrency`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (contractId) {
                localVarQueryParameter['contractId'] = contractId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get inventory of account.
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAccountInventory: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountInventory', 'id', id)
            const localVarPath = `/v1/accounts/{id}/inventory`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the native asset of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountNativeInventory: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountNativeInventory', 'id', id)
            const localVarPath = `/v1/accounts/{id}/inventory/native`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the NFT assets of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountNftInventory: async (id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountNftInventory', 'id', id)
            const localVarPath = `/v1/accounts/{id}/inventory/nft`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (contractId) {
                localVarQueryParameter['contractId'] = contractId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cryptocurrency list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] Filter by contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerCryptoCurrencyInventory: async (id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlayerCryptoCurrencyInventory', 'id', id)
            // verify required parameter 'chainId' is not null or undefined
            assertParamExists('getPlayerCryptoCurrencyInventory', 'chainId', chainId)
            const localVarPath = `/v1/players/{id}/inventory/cryptocurrency`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (contractId) {
                localVarQueryParameter['contractId'] = contractId;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get inventory of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPlayerInventory: async (id: string, chainId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlayerInventory', 'id', id)
            // verify required parameter 'chainId' is not null or undefined
            assertParamExists('getPlayerInventory', 'chainId', chainId)
            const localVarPath = `/v1/players/{id}/inventory`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get native token list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerNativeInventory: async (id: string, chainId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlayerNativeInventory', 'id', id)
            // verify required parameter 'chainId' is not null or undefined
            assertParamExists('getPlayerNativeInventory', 'chainId', chainId)
            const localVarPath = `/v1/players/{id}/inventory/native`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get NFTs list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] Filter by contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerNftInventory: async (id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlayerNftInventory', 'id', id)
            // verify required parameter 'chainId' is not null or undefined
            assertParamExists('getPlayerNftInventory', 'chainId', chainId)
            const localVarPath = `/v1/players/{id}/inventory/nft`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (contractId) {
                localVarQueryParameter['contractId'] = contractId;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoriesApi - functional programming interface
 * @export
 */
export const InventoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InventoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieves the cryptocurrency assets of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountCryptoCurrencyInventory(id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountCryptoCurrencyInventory(id, limit, skip, order, contractId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get inventory of account.
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getAccountInventory(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObsoleteInventoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountInventory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the native asset of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountNativeInventory(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountNativeInventory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the NFT assets of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountNftInventory(id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountNftInventory(id, limit, skip, order, contractId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get cryptocurrency list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] Filter by contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerCryptoCurrencyInventory(id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerCryptoCurrencyInventory(id, chainId, limit, skip, order, contractId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get inventory of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getPlayerInventory(id: string, chainId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObsoleteInventoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerInventory(id, chainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get native token list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerNativeInventory(id: string, chainId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerNativeInventory(id, chainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get NFTs list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] Filter by contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerNftInventory(id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerNftInventory(id, chainId, limit, skip, order, contractId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InventoriesApi - factory interface
 * @export
 */
export const InventoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InventoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieves the cryptocurrency assets of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCryptoCurrencyInventory(id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: any): AxiosPromise<InventoryListResponse> {
            return localVarFp.getAccountCryptoCurrencyInventory(id, limit, skip, order, contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get inventory of account.
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAccountInventory(id: string, options?: any): AxiosPromise<ObsoleteInventoryResponse> {
            return localVarFp.getAccountInventory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the native asset of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountNativeInventory(id: string, options?: any): AxiosPromise<InventoryResponse> {
            return localVarFp.getAccountNativeInventory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the NFT assets of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountNftInventory(id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: any): AxiosPromise<InventoryListResponse> {
            return localVarFp.getAccountNftInventory(id, limit, skip, order, contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cryptocurrency list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] Filter by contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerCryptoCurrencyInventory(id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: any): AxiosPromise<InventoryListResponse> {
            return localVarFp.getPlayerCryptoCurrencyInventory(id, chainId, limit, skip, order, contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get inventory of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPlayerInventory(id: string, chainId: number, options?: any): AxiosPromise<ObsoleteInventoryResponse> {
            return localVarFp.getPlayerInventory(id, chainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get native token list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerNativeInventory(id: string, chainId: number, options?: any): AxiosPromise<InventoryResponse> {
            return localVarFp.getPlayerNativeInventory(id, chainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get NFTs list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] Filter by contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerNftInventory(id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: any): AxiosPromise<InventoryListResponse> {
            return localVarFp.getPlayerNftInventory(id, chainId, limit, skip, order, contractId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InventoriesApi - object-oriented interface
 * @export
 * @class InventoriesApi
 * @extends {BaseAPI}
 */
export class InventoriesApi extends BaseAPI {
    /**
     * 
     * @summary Retrieves the cryptocurrency assets of an existing account.
     * @param {string} id Specifies the unique account ID.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<string>} [contractId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getAccountCryptoCurrencyInventory(id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getAccountCryptoCurrencyInventory(id, limit, skip, order, contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get inventory of account.
     * @param {string} id Specifies the unique account ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getAccountInventory(id: string, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getAccountInventory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the native asset of an existing account.
     * @param {string} id Specifies the unique account ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getAccountNativeInventory(id: string, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getAccountNativeInventory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the NFT assets of an existing account.
     * @param {string} id Specifies the unique account ID.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<string>} [contractId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getAccountNftInventory(id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getAccountNftInventory(id, limit, skip, order, contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cryptocurrency list of player.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {number} chainId Filter by chain id.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<string>} [contractId] Filter by contract ID (starts with con_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getPlayerCryptoCurrencyInventory(id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getPlayerCryptoCurrencyInventory(id, chainId, limit, skip, order, contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get inventory of player.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {number} chainId Filter by chain id.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getPlayerInventory(id: string, chainId: number, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getPlayerInventory(id, chainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get native token list of player.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {number} chainId Filter by chain id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getPlayerNativeInventory(id: string, chainId: number, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getPlayerNativeInventory(id, chainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get NFTs list of player.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {number} chainId Filter by chain id.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<string>} [contractId] Filter by contract ID (starts with con_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getPlayerNftInventory(id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getPlayerNftInventory(id, chainId, limit, skip, order, contractId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The endpoint verifies the token generated by OAuth provider, creates or retrieves a player based on his email, and returns the jwt token for the player together with the player id.
         * @summary Authorize player with token.
         * @param {OAuthProvider} provider OAuth provider
         * @param {OAuthRequest} oAuthRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeWithOAuthToken: async (provider: OAuthProvider, oAuthRequest: OAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('authorizeWithOAuthToken', 'provider', provider)
            // verify required parameter 'oAuthRequest' is not null or undefined
            assertParamExists('authorizeWithOAuthToken', 'oAuthRequest', oAuthRequest)
            const localVarPath = `/iam/v1/oauth/{provider}/authorize`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint creates oauth configuration for the current project environment.
         * @summary Create oauth configuration.
         * @param {OAuthConfig} body Specifies the oauth provider specific configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOAuthConfig: async (body: OAuthConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOAuthConfig', 'body', body)
            const localVarPath = `/iam/v1/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint deletes oauth configuration for specified provider for the current project environment.
         * @summary Delete oauth configuration.
         * @param {OAuthProvider} provider Specifies the oauth provider type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOAuthConfig: async (provider: OAuthProvider, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('deleteOAuthConfig', 'provider', provider)
            const localVarPath = `/iam/v1/oauth/{provider}/config`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint retrieves oauth configuration for specified provider for the current project environment.
         * @summary Get oauth configuration.
         * @param {OAuthProvider} provider Specifies the oauth provider type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthConfig: async (provider: OAuthProvider, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getOAuthConfig', 'provider', provider)
            const localVarPath = `/iam/v1/oauth/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the player based on his id in the external provider system.
         * @summary Retrieve player by external id.
         * @param {OAuthProvider} provider OAuth provider
         * @param {string} externalUserId External user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerByExternalId: async (provider: OAuthProvider, externalUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getPlayerByExternalId', 'provider', provider)
            // verify required parameter 'externalUserId' is not null or undefined
            assertParamExists('getPlayerByExternalId', 'externalUserId', externalUserId)
            const localVarPath = `/iam/v1/oauth/{provider}/user/{external_user_id}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)))
                .replace(`{${"external_user_id"}}`, encodeURIComponent(String(externalUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint retrieves the list of oauth configurations for the current project environment.
         * @summary List of oauth configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOAuthConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iam/v1/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint verifies the token generated by OAuth provider and retrieves a corresponding player.
         * @summary Retrieve player by token.
         * @param {OAuthProvider} provider OAuth provider
         * @param {OAuthRequest} oAuthRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOAuthToken: async (provider: OAuthProvider, oAuthRequest: OAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('verifyOAuthToken', 'provider', provider)
            // verify required parameter 'oAuthRequest' is not null or undefined
            assertParamExists('verifyOAuthToken', 'oAuthRequest', oAuthRequest)
            const localVarPath = `/iam/v1/oauth/{provider}/verify`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * The endpoint verifies the token generated by OAuth provider, creates or retrieves a player based on his email, and returns the jwt token for the player together with the player id.
         * @summary Authorize player with token.
         * @param {OAuthProvider} provider OAuth provider
         * @param {OAuthRequest} oAuthRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizeWithOAuthToken(provider: OAuthProvider, oAuthRequest: OAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizeWithOAuthToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeWithOAuthToken(provider, oAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The endpoint creates oauth configuration for the current project environment.
         * @summary Create oauth configuration.
         * @param {OAuthConfig} body Specifies the oauth provider specific configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOAuthConfig(body: OAuthConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOAuthConfig(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The endpoint deletes oauth configuration for specified provider for the current project environment.
         * @summary Delete oauth configuration.
         * @param {OAuthProvider} provider Specifies the oauth provider type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOAuthConfig(provider: OAuthProvider, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOAuthConfig(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The endpoint retrieves oauth configuration for specified provider for the current project environment.
         * @summary Get oauth configuration.
         * @param {OAuthProvider} provider Specifies the oauth provider type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOAuthConfig(provider: OAuthProvider, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOAuthConfig(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the player based on his id in the external provider system.
         * @summary Retrieve player by external id.
         * @param {OAuthProvider} provider OAuth provider
         * @param {string} externalUserId External user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerByExternalId(provider: OAuthProvider, externalUserId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerByExternalId(provider, externalUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The endpoint retrieves the list of oauth configurations for the current project environment.
         * @summary List of oauth configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOAuthConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthConfigListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOAuthConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The endpoint verifies the token generated by OAuth provider and retrieves a corresponding player.
         * @summary Retrieve player by token.
         * @param {OAuthProvider} provider OAuth provider
         * @param {OAuthRequest} oAuthRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyOAuthToken(provider: OAuthProvider, oAuthRequest: OAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyOAuthToken(provider, oAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthApiFp(configuration)
    return {
        /**
         * The endpoint verifies the token generated by OAuth provider, creates or retrieves a player based on his email, and returns the jwt token for the player together with the player id.
         * @summary Authorize player with token.
         * @param {OAuthProvider} provider OAuth provider
         * @param {OAuthRequest} oAuthRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeWithOAuthToken(provider: OAuthProvider, oAuthRequest: OAuthRequest, options?: any): AxiosPromise<AuthorizeWithOAuthToken200Response> {
            return localVarFp.authorizeWithOAuthToken(provider, oAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint creates oauth configuration for the current project environment.
         * @summary Create oauth configuration.
         * @param {OAuthConfig} body Specifies the oauth provider specific configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOAuthConfig(body: OAuthConfig, options?: any): AxiosPromise<OAuthConfig> {
            return localVarFp.createOAuthConfig(body, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint deletes oauth configuration for specified provider for the current project environment.
         * @summary Delete oauth configuration.
         * @param {OAuthProvider} provider Specifies the oauth provider type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOAuthConfig(provider: OAuthProvider, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOAuthConfig(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint retrieves oauth configuration for specified provider for the current project environment.
         * @summary Get oauth configuration.
         * @param {OAuthProvider} provider Specifies the oauth provider type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthConfig(provider: OAuthProvider, options?: any): AxiosPromise<OAuthConfig> {
            return localVarFp.getOAuthConfig(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the player based on his id in the external provider system.
         * @summary Retrieve player by external id.
         * @param {OAuthProvider} provider OAuth provider
         * @param {string} externalUserId External user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerByExternalId(provider: OAuthProvider, externalUserId: string, options?: any): AxiosPromise<PlayerResponse> {
            return localVarFp.getPlayerByExternalId(provider, externalUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint retrieves the list of oauth configurations for the current project environment.
         * @summary List of oauth configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOAuthConfig(options?: any): AxiosPromise<OAuthConfigListResponse> {
            return localVarFp.listOAuthConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint verifies the token generated by OAuth provider and retrieves a corresponding player.
         * @summary Retrieve player by token.
         * @param {OAuthProvider} provider OAuth provider
         * @param {OAuthRequest} oAuthRequest Request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOAuthToken(provider: OAuthProvider, oAuthRequest: OAuthRequest, options?: any): AxiosPromise<PlayerResponse> {
            return localVarFp.verifyOAuthToken(provider, oAuthRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
    /**
     * The endpoint verifies the token generated by OAuth provider, creates or retrieves a player based on his email, and returns the jwt token for the player together with the player id.
     * @summary Authorize player with token.
     * @param {OAuthProvider} provider OAuth provider
     * @param {OAuthRequest} oAuthRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public authorizeWithOAuthToken(provider: OAuthProvider, oAuthRequest: OAuthRequest, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).authorizeWithOAuthToken(provider, oAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint creates oauth configuration for the current project environment.
     * @summary Create oauth configuration.
     * @param {OAuthConfig} body Specifies the oauth provider specific configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public createOAuthConfig(body: OAuthConfig, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).createOAuthConfig(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint deletes oauth configuration for specified provider for the current project environment.
     * @summary Delete oauth configuration.
     * @param {OAuthProvider} provider Specifies the oauth provider type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public deleteOAuthConfig(provider: OAuthProvider, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).deleteOAuthConfig(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint retrieves oauth configuration for specified provider for the current project environment.
     * @summary Get oauth configuration.
     * @param {OAuthProvider} provider Specifies the oauth provider type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public getOAuthConfig(provider: OAuthProvider, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).getOAuthConfig(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the player based on his id in the external provider system.
     * @summary Retrieve player by external id.
     * @param {OAuthProvider} provider OAuth provider
     * @param {string} externalUserId External user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public getPlayerByExternalId(provider: OAuthProvider, externalUserId: string, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).getPlayerByExternalId(provider, externalUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint retrieves the list of oauth configurations for the current project environment.
     * @summary List of oauth configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public listOAuthConfig(options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).listOAuthConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint verifies the token generated by OAuth provider and retrieves a corresponding player.
     * @summary Retrieve player by token.
     * @param {OAuthProvider} provider OAuth provider
     * @param {OAuthRequest} oAuthRequest Request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public verifyOAuthToken(provider: OAuthProvider, oAuthRequest: OAuthRequest, options?: AxiosRequestConfig) {
        return OAuthApiFp(this.configuration).verifyOAuthToken(provider, oAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayersApi - axios parameter creator
 * @export
 */
export const PlayersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows you to cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {string} id 
         * @param {PlayerCancelTransferOwnershipRequest} playerCancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransferAccountOwnership: async (id: string, playerCancelTransferOwnershipRequest: PlayerCancelTransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelTransferAccountOwnership', 'id', id)
            // verify required parameter 'playerCancelTransferOwnershipRequest' is not null or undefined
            assertParamExists('cancelTransferAccountOwnership', 'playerCancelTransferOwnershipRequest', playerCancelTransferOwnershipRequest)
            const localVarPath = `/v1/players/{id}/cancel_transfer_ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerCancelTransferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new player to your player list in Openfort.
         * @summary Create a player object.
         * @param {PlayerCreateRequest} playerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayer: async (playerCreateRequest: PlayerCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playerCreateRequest' is not null or undefined
            assertParamExists('createPlayer', 'playerCreateRequest', playerCreateRequest)
            const localVarPath = `/v1/players`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create account object for a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {CreatePlayerAccountRequest} createPlayerAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayerAccount: async (id: string, createPlayerAccountRequest: CreatePlayerAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPlayerAccount', 'id', id)
            // verify required parameter 'createPlayerAccountRequest' is not null or undefined
            assertParamExists('createPlayerAccount', 'createPlayerAccountRequest', createPlayerAccountRequest)
            const localVarPath = `/v1/players/{id}/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPlayerAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create session object for a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {CreatePlayerSessionRequest} createPlayerSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayerSession: async (id: string, createPlayerSessionRequest: CreatePlayerSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPlayerSession', 'id', id)
            // verify required parameter 'createPlayerSessionRequest' is not null or undefined
            assertParamExists('createPlayerSession', 'createPlayerSessionRequest', createPlayerSessionRequest)
            const localVarPath = `/v1/players/{id}/sessions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPlayerSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a player object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlayer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePlayer', 'id', id)
            const localVarPath = `/v1/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the details of an existing player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {Array<PlayerResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer: async (id: string, expand?: Array<PlayerResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlayer', 'id', id)
            const localVarPath = `/v1/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of accounts of a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {Array<AccountResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerAccounts: async (id: string, expand?: Array<AccountResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlayerAccounts', 'id', id)
            const localVarPath = `/v1/players/{id}/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, a maximum of ten players are shown.
         * @summary List players.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<PlayerResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {string} [name] Filter by player name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayers: async (limit?: number, skip?: number, order?: SortOrder, expand?: Array<PlayerResponseExpandable>, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/players`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {string} id 
         * @param {PlayerCancelTransferOwnershipRequest} playerCancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        obsoleteCancelTransferAccountOwnership: async (id: string, playerCancelTransferOwnershipRequest: PlayerCancelTransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('obsoleteCancelTransferAccountOwnership', 'id', id)
            // verify required parameter 'playerCancelTransferOwnershipRequest' is not null or undefined
            assertParamExists('obsoleteCancelTransferAccountOwnership', 'playerCancelTransferOwnershipRequest', playerCancelTransferOwnershipRequest)
            const localVarPath = `/v1/players/{id}/cancel-transfer-ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerCancelTransferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        obsoleteRequestTransferAccountOwnership: async (id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('obsoleteRequestTransferAccountOwnership', 'id', id)
            // verify required parameter 'playerTransferOwnershipRequest' is not null or undefined
            assertParamExists('obsoleteRequestTransferAccountOwnership', 'playerTransferOwnershipRequest', playerTransferOwnershipRequest)
            const localVarPath = `/v1/players/{id}/request-transfer-ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerTransferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTransferAccountOwnership: async (id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('requestTransferAccountOwnership', 'id', id)
            // verify required parameter 'playerTransferOwnershipRequest' is not null or undefined
            assertParamExists('requestTransferAccountOwnership', 'playerTransferOwnershipRequest', playerTransferOwnershipRequest)
            const localVarPath = `/v1/players/{id}/request_transfer_ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerTransferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke session object for a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {RevokeSessionPlayerRequest} revokeSessionPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePlayerSession: async (id: string, revokeSessionPlayerRequest: RevokeSessionPlayerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('revokePlayerSession', 'id', id)
            // verify required parameter 'revokeSessionPlayerRequest' is not null or undefined
            assertParamExists('revokePlayerSession', 'revokeSessionPlayerRequest', revokeSessionPlayerRequest)
            const localVarPath = `/v1/players/{id}/sessions/revoke`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revokeSessionPlayerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a player object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerUpdateRequest} playerUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer: async (id: string, playerUpdateRequest: PlayerUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePlayer', 'id', id)
            // verify required parameter 'playerUpdateRequest' is not null or undefined
            assertParamExists('updatePlayer', 'playerUpdateRequest', playerUpdateRequest)
            const localVarPath = `/v1/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayersApi - functional programming interface
 * @export
 */
export const PlayersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayersApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows you to cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {string} id 
         * @param {PlayerCancelTransferOwnershipRequest} playerCancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTransferAccountOwnership(id: string, playerCancelTransferOwnershipRequest: PlayerCancelTransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransferAccountOwnership(id, playerCancelTransferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new player to your player list in Openfort.
         * @summary Create a player object.
         * @param {PlayerCreateRequest} playerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlayer(playerCreateRequest: PlayerCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlayer(playerCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create account object for a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {CreatePlayerAccountRequest} createPlayerAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlayerAccount(id: string, createPlayerAccountRequest: CreatePlayerAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlayerAccount(id, createPlayerAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create session object for a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {CreatePlayerSessionRequest} createPlayerSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlayerSession(id: string, createPlayerSessionRequest: CreatePlayerSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlayerSession(id, createPlayerSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a player object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlayer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlayer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the details of an existing player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {Array<PlayerResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayer(id: string, expand?: Array<PlayerResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayer(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of accounts of a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {Array<AccountResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerAccounts(id: string, expand?: Array<AccountResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerAccounts(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * By default, a maximum of ten players are shown.
         * @summary List players.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<PlayerResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {string} [name] Filter by player name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayers(limit?: number, skip?: number, order?: SortOrder, expand?: Array<PlayerResponseExpandable>, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayers(limit, skip, order, expand, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {string} id 
         * @param {PlayerCancelTransferOwnershipRequest} playerCancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async obsoleteCancelTransferAccountOwnership(id: string, playerCancelTransferOwnershipRequest: PlayerCancelTransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obsoleteCancelTransferAccountOwnership(id, playerCancelTransferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async obsoleteRequestTransferAccountOwnership(id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obsoleteRequestTransferAccountOwnership(id, playerTransferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestTransferAccountOwnership(id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestTransferAccountOwnership(id, playerTransferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Revoke session object for a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {RevokeSessionPlayerRequest} revokeSessionPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokePlayerSession(id: string, revokeSessionPlayerRequest: RevokeSessionPlayerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokePlayerSession(id, revokeSessionPlayerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates a player object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerUpdateRequest} playerUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlayer(id: string, playerUpdateRequest: PlayerUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlayer(id, playerUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayersApi - factory interface
 * @export
 */
export const PlayersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayersApiFp(configuration)
    return {
        /**
         * This endpoint allows you to cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {string} id 
         * @param {PlayerCancelTransferOwnershipRequest} playerCancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransferAccountOwnership(id: string, playerCancelTransferOwnershipRequest: PlayerCancelTransferOwnershipRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.cancelTransferAccountOwnership(id, playerCancelTransferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new player to your player list in Openfort.
         * @summary Create a player object.
         * @param {PlayerCreateRequest} playerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayer(playerCreateRequest: PlayerCreateRequest, options?: any): AxiosPromise<PlayerResponse> {
            return localVarFp.createPlayer(playerCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create account object for a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {CreatePlayerAccountRequest} createPlayerAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayerAccount(id: string, createPlayerAccountRequest: CreatePlayerAccountRequest, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.createPlayerAccount(id, createPlayerAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create session object for a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {CreatePlayerSessionRequest} createPlayerSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayerSession(id: string, createPlayerSessionRequest: CreatePlayerSessionRequest, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.createPlayerSession(id, createPlayerSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a player object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlayer(id: string, options?: any): AxiosPromise<PlayerDeleteResponse> {
            return localVarFp.deletePlayer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the details of an existing player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {Array<PlayerResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer(id: string, expand?: Array<PlayerResponseExpandable>, options?: any): AxiosPromise<PlayerResponse> {
            return localVarFp.getPlayer(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of accounts of a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {Array<AccountResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerAccounts(id: string, expand?: Array<AccountResponseExpandable>, options?: any): AxiosPromise<AccountListResponse> {
            return localVarFp.getPlayerAccounts(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * By default, a maximum of ten players are shown.
         * @summary List players.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<PlayerResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {string} [name] Filter by player name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayers(limit?: number, skip?: number, order?: SortOrder, expand?: Array<PlayerResponseExpandable>, name?: string, options?: any): AxiosPromise<PlayerListResponse> {
            return localVarFp.getPlayers(limit, skip, order, expand, name, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {string} id 
         * @param {PlayerCancelTransferOwnershipRequest} playerCancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        obsoleteCancelTransferAccountOwnership(id: string, playerCancelTransferOwnershipRequest: PlayerCancelTransferOwnershipRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.obsoleteCancelTransferAccountOwnership(id, playerCancelTransferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        obsoleteRequestTransferAccountOwnership(id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.obsoleteRequestTransferAccountOwnership(id, playerTransferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTransferAccountOwnership(id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.requestTransferAccountOwnership(id, playerTransferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke session object for a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {RevokeSessionPlayerRequest} revokeSessionPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePlayerSession(id: string, revokeSessionPlayerRequest: RevokeSessionPlayerRequest, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.revokePlayerSession(id, revokeSessionPlayerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a player object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerUpdateRequest} playerUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer(id: string, playerUpdateRequest: PlayerUpdateRequest, options?: any): AxiosPromise<PlayerResponse> {
            return localVarFp.updatePlayer(id, playerUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayersApi - object-oriented interface
 * @export
 * @class PlayersApi
 * @extends {BaseAPI}
 */
export class PlayersApi extends BaseAPI {
    /**
     * This endpoint allows you to cancel a pending transfer of ownership.
     * @summary Cancel request to transfer ownership of an account.
     * @param {string} id 
     * @param {PlayerCancelTransferOwnershipRequest} playerCancelTransferOwnershipRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public cancelTransferAccountOwnership(id: string, playerCancelTransferOwnershipRequest: PlayerCancelTransferOwnershipRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).cancelTransferAccountOwnership(id, playerCancelTransferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new player to your player list in Openfort.
     * @summary Create a player object.
     * @param {PlayerCreateRequest} playerCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public createPlayer(playerCreateRequest: PlayerCreateRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).createPlayer(playerCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create account object for a player.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {CreatePlayerAccountRequest} createPlayerAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public createPlayerAccount(id: string, createPlayerAccountRequest: CreatePlayerAccountRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).createPlayerAccount(id, createPlayerAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create session object for a player.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {CreatePlayerSessionRequest} createPlayerSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public createPlayerSession(id: string, createPlayerSessionRequest: CreatePlayerSessionRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).createPlayerSession(id, createPlayerSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a player object.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public deletePlayer(id: string, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).deletePlayer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the details of an existing player.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {Array<PlayerResponseExpandable>} [expand] Specifies the expandable fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public getPlayer(id: string, expand?: Array<PlayerResponseExpandable>, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).getPlayer(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of accounts of a player.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {Array<AccountResponseExpandable>} [expand] Specifies the expandable fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public getPlayerAccounts(id: string, expand?: Array<AccountResponseExpandable>, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).getPlayerAccounts(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default, a maximum of ten players are shown.
     * @summary List players.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<PlayerResponseExpandable>} [expand] Specifies the fields to expand in the response.
     * @param {string} [name] Filter by player name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public getPlayers(limit?: number, skip?: number, order?: SortOrder, expand?: Array<PlayerResponseExpandable>, name?: string, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).getPlayers(limit, skip, order, expand, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to cancel a pending transfer of ownership.
     * @summary Cancel request to transfer ownership of an account.
     * @param {string} id 
     * @param {PlayerCancelTransferOwnershipRequest} playerCancelTransferOwnershipRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public obsoleteCancelTransferAccountOwnership(id: string, playerCancelTransferOwnershipRequest: PlayerCancelTransferOwnershipRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).obsoleteCancelTransferAccountOwnership(id, playerCancelTransferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
     * @summary Request transfer ownership of account.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public obsoleteRequestTransferAccountOwnership(id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).obsoleteRequestTransferAccountOwnership(id, playerTransferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
     * @summary Request transfer ownership of account.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public requestTransferAccountOwnership(id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).requestTransferAccountOwnership(id, playerTransferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke session object for a player.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {RevokeSessionPlayerRequest} revokeSessionPlayerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public revokePlayerSession(id: string, revokeSessionPlayerRequest: RevokeSessionPlayerRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).revokePlayerSession(id, revokeSessionPlayerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a player object.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {PlayerUpdateRequest} playerUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public updatePlayer(id: string, playerUpdateRequest: PlayerUpdateRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).updatePlayer(id, playerUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayersAuthenticationApi - axios parameter creator
 * @export
 */
export const PlayersAuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List authenticated players.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [email] Specifies the email address of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedPlayers: async (limit?: number, skip?: number, order?: SortOrder, email?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iam/v1/players`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayersAuthenticationApi - functional programming interface
 * @export
 */
export const PlayersAuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayersAuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List authenticated players.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [email] Specifies the email address of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthenticatedPlayers(limit?: number, skip?: number, order?: SortOrder, email?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthPlayerListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthenticatedPlayers(limit, skip, order, email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayersAuthenticationApi - factory interface
 * @export
 */
export const PlayersAuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayersAuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary List authenticated players.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [email] Specifies the email address of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthenticatedPlayers(limit?: number, skip?: number, order?: SortOrder, email?: string, options?: any): AxiosPromise<AuthPlayerListResponse> {
            return localVarFp.getAuthenticatedPlayers(limit, skip, order, email, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayersAuthenticationApi - object-oriented interface
 * @export
 * @class PlayersAuthenticationApi
 * @extends {BaseAPI}
 */
export class PlayersAuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary List authenticated players.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {string} [email] Specifies the email address of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersAuthenticationApi
     */
    public getAuthenticatedPlayers(limit?: number, skip?: number, order?: SortOrder, email?: string, options?: AxiosRequestConfig) {
        return PlayersAuthenticationApiFp(this.configuration).getAuthenticatedPlayers(limit, skip, order, email, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a policy object.
         * @param {CreatePolicyRequest} createPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy: async (createPolicyRequest: CreatePolicyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPolicyRequest' is not null or undefined
            assertParamExists('createPolicy', 'createPolicyRequest', createPolicyRequest)
            const localVarPath = `/v1/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPolicyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a policy rule object for a policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {CreatePolicyAllowFunctionRequest} createPolicyAllowFunctionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyAllowFunction: async (id: string, createPolicyAllowFunctionRequest: CreatePolicyAllowFunctionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPolicyAllowFunction', 'id', id)
            // verify required parameter 'createPolicyAllowFunctionRequest' is not null or undefined
            assertParamExists('createPolicyAllowFunction', 'createPolicyAllowFunctionRequest', createPolicyAllowFunctionRequest)
            const localVarPath = `/v1/policies/{id}/policy_rules`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPolicyAllowFunctionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePolicy', 'id', id)
            const localVarPath = `/v1/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disablePolicy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('disablePolicy', 'id', id)
            const localVarPath = `/v1/policies/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enablePolicy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enablePolicy', 'id', id)
            const localVarPath = `/v1/policies/{id}/enable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List policies.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {string} [name] Specifies the name of the policy.
         * @param {boolean} [deleted] Specifies whether to include deleted contracts.
         * @param {number} [chainId] The chain ID of the policy.
         * @param {boolean} [enabled] Specifies whether to include enabled contracts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies: async (limit?: number, skip?: number, order?: SortOrder, expand?: Array<PolicyResponseExpandable>, name?: string, deleted?: boolean, chainId?: number, enabled?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy: async (id: string, expand?: Array<PolicyResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPolicy', 'id', id)
            const localVarPath = `/v1/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List policy rules of a policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {Array<'contract'>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyAllowFunctions: async (id: string, expand?: Array<'contract'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPolicyAllowFunctions', 'id', id)
            const localVarPath = `/v1/policies/{id}/policy_rules`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all gas reports of a policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyTotalGasUsage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPolicyTotalGasUsage', 'id', id)
            const localVarPath = `/v1/policies/{id}/reports`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {UpdatePolicyRequest} updatePolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy: async (id: string, updatePolicyRequest: UpdatePolicyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePolicy', 'id', id)
            // verify required parameter 'updatePolicyRequest' is not null or undefined
            assertParamExists('updatePolicy', 'updatePolicyRequest', updatePolicyRequest)
            const localVarPath = `/v1/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePolicyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a policy rule object of a policy.
         * @param {string} policy 
         * @param {string} policyRule 
         * @param {UpdatePolicyRuleRequest} updatePolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyAllowFunction: async (policy: string, policyRule: string, updatePolicyRuleRequest: UpdatePolicyRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policy' is not null or undefined
            assertParamExists('updatePolicyAllowFunction', 'policy', policy)
            // verify required parameter 'policyRule' is not null or undefined
            assertParamExists('updatePolicyAllowFunction', 'policyRule', policyRule)
            // verify required parameter 'updatePolicyRuleRequest' is not null or undefined
            assertParamExists('updatePolicyAllowFunction', 'updatePolicyRuleRequest', updatePolicyRuleRequest)
            const localVarPath = `/v1/policies/{policy}/policy_rules/{policy_rule}`
                .replace(`{${"policy"}}`, encodeURIComponent(String(policy)))
                .replace(`{${"policy_rule"}}`, encodeURIComponent(String(policyRule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePolicyRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a policy object.
         * @param {CreatePolicyRequest} createPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicy(createPolicyRequest: CreatePolicyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicy(createPolicyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a policy rule object for a policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {CreatePolicyAllowFunctionRequest} createPolicyAllowFunctionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicyAllowFunction(id: string, createPolicyAllowFunctionRequest: CreatePolicyAllowFunctionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicyAllowFunction(id, createPolicyAllowFunctionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Disable a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disablePolicy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disablePolicy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Enable a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enablePolicy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enablePolicy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List policies.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {string} [name] Specifies the name of the policy.
         * @param {boolean} [deleted] Specifies whether to include deleted contracts.
         * @param {number} [chainId] The chain ID of the policy.
         * @param {boolean} [enabled] Specifies whether to include enabled contracts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicies(limit?: number, skip?: number, order?: SortOrder, expand?: Array<PolicyResponseExpandable>, name?: string, deleted?: boolean, chainId?: number, enabled?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicies(limit, skip, order, expand, name, deleted, chainId, enabled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicy(id: string, expand?: Array<PolicyResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicy(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List policy rules of a policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {Array<'contract'>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyAllowFunctions(id: string, expand?: Array<'contract'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyAllowFunctions(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all gas reports of a policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyTotalGasUsage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GasReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyTotalGasUsage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {UpdatePolicyRequest} updatePolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicy(id: string, updatePolicyRequest: UpdatePolicyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicy(id, updatePolicyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a policy rule object of a policy.
         * @param {string} policy 
         * @param {string} policyRule 
         * @param {UpdatePolicyRuleRequest} updatePolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicyAllowFunction(policy: string, policyRule: string, updatePolicyRuleRequest: UpdatePolicyRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicyAllowFunction(policy, policyRule, updatePolicyRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a policy object.
         * @param {CreatePolicyRequest} createPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy(createPolicyRequest: CreatePolicyRequest, options?: any): AxiosPromise<PolicyResponse> {
            return localVarFp.createPolicy(createPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a policy rule object for a policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {CreatePolicyAllowFunctionRequest} createPolicyAllowFunctionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyAllowFunction(id: string, createPolicyAllowFunctionRequest: CreatePolicyAllowFunctionRequest, options?: any): AxiosPromise<PolicyRuleResponse> {
            return localVarFp.createPolicyAllowFunction(id, createPolicyAllowFunctionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(id: string, options?: any): AxiosPromise<PolicyDeleteResponse> {
            return localVarFp.deletePolicy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disable a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disablePolicy(id: string, options?: any): AxiosPromise<PolicyResponse> {
            return localVarFp.disablePolicy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enable a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enablePolicy(id: string, options?: any): AxiosPromise<PolicyResponse> {
            return localVarFp.enablePolicy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List policies.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {string} [name] Specifies the name of the policy.
         * @param {boolean} [deleted] Specifies whether to include deleted contracts.
         * @param {number} [chainId] The chain ID of the policy.
         * @param {boolean} [enabled] Specifies whether to include enabled contracts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies(limit?: number, skip?: number, order?: SortOrder, expand?: Array<PolicyResponseExpandable>, name?: string, deleted?: boolean, chainId?: number, enabled?: boolean, options?: any): AxiosPromise<PolicyListResponse> {
            return localVarFp.getPolicies(limit, skip, order, expand, name, deleted, chainId, enabled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(id: string, expand?: Array<PolicyResponseExpandable>, options?: any): AxiosPromise<PolicyResponse> {
            return localVarFp.getPolicy(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List policy rules of a policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {Array<'contract'>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyAllowFunctions(id: string, expand?: Array<'contract'>, options?: any): AxiosPromise<PolicyRuleListResponse> {
            return localVarFp.getPolicyAllowFunctions(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all gas reports of a policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyTotalGasUsage(id: string, options?: any): AxiosPromise<GasReport> {
            return localVarFp.getPolicyTotalGasUsage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {UpdatePolicyRequest} updatePolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(id: string, updatePolicyRequest: UpdatePolicyRequest, options?: any): AxiosPromise<PolicyResponse> {
            return localVarFp.updatePolicy(id, updatePolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a policy rule object of a policy.
         * @param {string} policy 
         * @param {string} policyRule 
         * @param {UpdatePolicyRuleRequest} updatePolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyAllowFunction(policy: string, policyRule: string, updatePolicyRuleRequest: UpdatePolicyRuleRequest, options?: any): AxiosPromise<PolicyRuleResponse> {
            return localVarFp.updatePolicyAllowFunction(policy, policyRule, updatePolicyRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * 
     * @summary Create a policy object.
     * @param {CreatePolicyRequest} createPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createPolicy(createPolicyRequest: CreatePolicyRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createPolicy(createPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a policy rule object for a policy.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {CreatePolicyAllowFunctionRequest} createPolicyAllowFunctionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createPolicyAllowFunction(id: string, createPolicyAllowFunctionRequest: CreatePolicyAllowFunctionRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createPolicyAllowFunction(id, createPolicyAllowFunctionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a policy object.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public deletePolicy(id: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).deletePolicy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disable a policy object.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public disablePolicy(id: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).disablePolicy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enable a policy object.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public enablePolicy(id: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).enablePolicy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List policies.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand in the response.
     * @param {string} [name] Specifies the name of the policy.
     * @param {boolean} [deleted] Specifies whether to include deleted contracts.
     * @param {number} [chainId] The chain ID of the policy.
     * @param {boolean} [enabled] Specifies whether to include enabled contracts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicies(limit?: number, skip?: number, order?: SortOrder, expand?: Array<PolicyResponseExpandable>, name?: string, deleted?: boolean, chainId?: number, enabled?: boolean, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicies(limit, skip, order, expand, name, deleted, chainId, enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a policy object.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicy(id: string, expand?: Array<PolicyResponseExpandable>, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicy(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List policy rules of a policy.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {Array<'contract'>} [expand] Specifies the fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicyAllowFunctions(id: string, expand?: Array<'contract'>, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicyAllowFunctions(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all gas reports of a policy.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicyTotalGasUsage(id: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicyTotalGasUsage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a policy object.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {UpdatePolicyRequest} updatePolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public updatePolicy(id: string, updatePolicyRequest: UpdatePolicyRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updatePolicy(id, updatePolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a policy rule object of a policy.
     * @param {string} policy 
     * @param {string} policyRule 
     * @param {UpdatePolicyRuleRequest} updatePolicyRuleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public updatePolicyAllowFunction(policy: string, policyRule: string, updatePolicyRuleRequest: UpdatePolicyRuleRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updatePolicyAllowFunction(policy, policyRule, updatePolicyRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PolicyRulesApi - axios parameter creator
 * @export
 */
export const PolicyRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a policy rule object.
         * @param {CreatePolicyRuleRequest} createPolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyRules: async (createPolicyRuleRequest: CreatePolicyRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPolicyRuleRequest' is not null or undefined
            assertParamExists('createPolicyRules', 'createPolicyRuleRequest', createPolicyRuleRequest)
            const localVarPath = `/v1/policy_rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPolicyRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a policy rule object.
         * @param {string} id Specifies the unique policy rule ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicyRules: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePolicyRules', 'id', id)
            const localVarPath = `/v1/policy_rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List policy rules of a policy.
         * @param {string} policy Specifies the unique policy ID (starts with pol_).
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<'contract'>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyRules: async (policy: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<'contract'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policy' is not null or undefined
            assertParamExists('getPolicyRules', 'policy', policy)
            const localVarPath = `/v1/policy_rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (policy !== undefined) {
                localVarQueryParameter['policy'] = policy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a policy rule object.
         * @param {string} id Specifies the unique policy rule ID.
         * @param {UpdatePolicyRuleRequest} updatePolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyRules: async (id: string, updatePolicyRuleRequest: UpdatePolicyRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePolicyRules', 'id', id)
            // verify required parameter 'updatePolicyRuleRequest' is not null or undefined
            assertParamExists('updatePolicyRules', 'updatePolicyRuleRequest', updatePolicyRuleRequest)
            const localVarPath = `/v1/policy_rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePolicyRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolicyRulesApi - functional programming interface
 * @export
 */
export const PolicyRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PolicyRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a policy rule object.
         * @param {CreatePolicyRuleRequest} createPolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicyRules(createPolicyRuleRequest: CreatePolicyRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicyRules(createPolicyRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a policy rule object.
         * @param {string} id Specifies the unique policy rule ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicyRules(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicyRules(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List policy rules of a policy.
         * @param {string} policy Specifies the unique policy ID (starts with pol_).
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<'contract'>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyRules(policy: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<'contract'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyRules(policy, limit, skip, order, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a policy rule object.
         * @param {string} id Specifies the unique policy rule ID.
         * @param {UpdatePolicyRuleRequest} updatePolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicyRules(id: string, updatePolicyRuleRequest: UpdatePolicyRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicyRules(id, updatePolicyRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PolicyRulesApi - factory interface
 * @export
 */
export const PolicyRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PolicyRulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a policy rule object.
         * @param {CreatePolicyRuleRequest} createPolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyRules(createPolicyRuleRequest: CreatePolicyRuleRequest, options?: any): AxiosPromise<PolicyRuleResponse> {
            return localVarFp.createPolicyRules(createPolicyRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a policy rule object.
         * @param {string} id Specifies the unique policy rule ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicyRules(id: string, options?: any): AxiosPromise<PolicyRuleDeleteResponse> {
            return localVarFp.deletePolicyRules(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List policy rules of a policy.
         * @param {string} policy Specifies the unique policy ID (starts with pol_).
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<'contract'>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyRules(policy: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<'contract'>, options?: any): AxiosPromise<PolicyRuleListResponse> {
            return localVarFp.getPolicyRules(policy, limit, skip, order, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a policy rule object.
         * @param {string} id Specifies the unique policy rule ID.
         * @param {UpdatePolicyRuleRequest} updatePolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyRules(id: string, updatePolicyRuleRequest: UpdatePolicyRuleRequest, options?: any): AxiosPromise<PolicyRuleResponse> {
            return localVarFp.updatePolicyRules(id, updatePolicyRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PolicyRulesApi - object-oriented interface
 * @export
 * @class PolicyRulesApi
 * @extends {BaseAPI}
 */
export class PolicyRulesApi extends BaseAPI {
    /**
     * 
     * @summary Create a policy rule object.
     * @param {CreatePolicyRuleRequest} createPolicyRuleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyRulesApi
     */
    public createPolicyRules(createPolicyRuleRequest: CreatePolicyRuleRequest, options?: AxiosRequestConfig) {
        return PolicyRulesApiFp(this.configuration).createPolicyRules(createPolicyRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a policy rule object.
     * @param {string} id Specifies the unique policy rule ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyRulesApi
     */
    public deletePolicyRules(id: string, options?: AxiosRequestConfig) {
        return PolicyRulesApiFp(this.configuration).deletePolicyRules(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List policy rules of a policy.
     * @param {string} policy Specifies the unique policy ID (starts with pol_).
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<'contract'>} [expand] Specifies the fields to expand in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyRulesApi
     */
    public getPolicyRules(policy: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<'contract'>, options?: AxiosRequestConfig) {
        return PolicyRulesApiFp(this.configuration).getPolicyRules(policy, limit, skip, order, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a policy rule object.
     * @param {string} id Specifies the unique policy rule ID.
     * @param {UpdatePolicyRuleRequest} updatePolicyRuleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyRulesApi
     */
    public updatePolicyRules(id: string, updatePolicyRuleRequest: UpdatePolicyRuleRequest, options?: AxiosRequestConfig) {
        return PolicyRulesApiFp(this.configuration).updatePolicyRules(id, updatePolicyRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a session key.
         * @param {CreateSessionRequest} createSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession: async (createSessionRequest: CreateSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSessionRequest' is not null or undefined
            assertParamExists('createSession', 'createSessionRequest', createSessionRequest)
            const localVarPath = `/v1/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List session keys of a player.
         * @param {string} player The player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerSessions: async (player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<SessionResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'player' is not null or undefined
            assertParamExists('getPlayerSessions', 'player', player)
            const localVarPath = `/v1/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a player session by session id
         * @param {string} id Specifies the unique session ID (starts with ses_).
         * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (id: string, expand?: Array<SessionResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSession', 'id', id)
            const localVarPath = `/v1/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke the session session key.
         * @param {RevokeSessionRequest} revokeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeSession: async (revokeSessionRequest: RevokeSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'revokeSessionRequest' is not null or undefined
            assertParamExists('revokeSession', 'revokeSessionRequest', revokeSessionRequest)
            const localVarPath = `/v1/sessions/revoke`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revokeSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirms the creation of a session with an external owner.
         * @param {string} id Specifies the unique session ID (starts with ses_).
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signatureSession: async (id: string, signatureRequest: SignatureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signatureSession', 'id', id)
            // verify required parameter 'signatureRequest' is not null or undefined
            assertParamExists('signatureSession', 'signatureRequest', signatureRequest)
            const localVarPath = `/v1/sessions/{id}/signature`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a session key.
         * @param {CreateSessionRequest} createSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSession(createSessionRequest: CreateSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(createSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List session keys of a player.
         * @param {string} player The player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerSessions(player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<SessionResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerSessions(player, limit, skip, order, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a player session by session id
         * @param {string} id Specifies the unique session ID (starts with ses_).
         * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(id: string, expand?: Array<SessionResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Revoke the session session key.
         * @param {RevokeSessionRequest} revokeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeSession(revokeSessionRequest: RevokeSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeSession(revokeSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Confirms the creation of a session with an external owner.
         * @param {string} id Specifies the unique session ID (starts with ses_).
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signatureSession(id: string, signatureRequest: SignatureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signatureSession(id, signatureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a session key.
         * @param {CreateSessionRequest} createSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(createSessionRequest: CreateSessionRequest, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.createSession(createSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List session keys of a player.
         * @param {string} player The player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerSessions(player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<SessionResponseExpandable>, options?: any): AxiosPromise<SessionListResponse> {
            return localVarFp.getPlayerSessions(player, limit, skip, order, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a player session by session id
         * @param {string} id Specifies the unique session ID (starts with ses_).
         * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(id: string, expand?: Array<SessionResponseExpandable>, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.getSession(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke the session session key.
         * @param {RevokeSessionRequest} revokeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeSession(revokeSessionRequest: RevokeSessionRequest, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.revokeSession(revokeSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirms the creation of a session with an external owner.
         * @param {string} id Specifies the unique session ID (starts with ses_).
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signatureSession(id: string, signatureRequest: SignatureRequest, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.signatureSession(id, signatureRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * 
     * @summary Create a session key.
     * @param {CreateSessionRequest} createSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public createSession(createSessionRequest: CreateSessionRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).createSession(createSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List session keys of a player.
     * @param {string} player The player ID (starts with pla_)
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getPlayerSessions(player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<SessionResponseExpandable>, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getPlayerSessions(player, limit, skip, order, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a player session by session id
     * @param {string} id Specifies the unique session ID (starts with ses_).
     * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSession(id: string, expand?: Array<SessionResponseExpandable>, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSession(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke the session session key.
     * @param {RevokeSessionRequest} revokeSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public revokeSession(revokeSessionRequest: RevokeSessionRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).revokeSession(revokeSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirms the creation of a session with an external owner.
     * @param {string} id Specifies the unique session ID (starts with ses_).
     * @param {SignatureRequest} signatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public signatureSession(id: string, signatureRequest: SignatureRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).signatureSession(id, signatureRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Verify signature and add a depositor address to the current project environment.
         * @summary Add depositor address.
         * @param {PaymasterDepositorCreateRequest} paymasterDepositorCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDepositorAddress: async (paymasterDepositorCreateRequest: PaymasterDepositorCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymasterDepositorCreateRequest' is not null or undefined
            assertParamExists('addDepositorAddress', 'paymasterDepositorCreateRequest', paymasterDepositorCreateRequest)
            const localVarPath = `/v1/settings/depositor_addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymasterDepositorCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the list of the depositor addresses for the current project environment.
         * @summary List of depositor addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositorAddresses: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/settings/depositor_addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate message, which should be signed for verification of the address ownership.
         * @summary Generate message to sign
         * @param {string} address Specifies the paymaster depositor address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageForSigningDepositorAddress: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getMessageForSigningDepositorAddress', 'address', address)
            const localVarPath = `/v1/settings/depositor_addresses/message_to_sign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a depositor address from the current project environment.
         * @summary Removes depositor address.
         * @param {string} id Specifies unique identifier of depositor address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDepositorAddress: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeDepositorAddress', 'id', id)
            const localVarPath = `/v1/settings/depositor_addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updated the current project environment settings by removing the webhook address. After that system will stop sending events of the transaction intent state changes
         * @summary Removes webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/settings/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updated the current project environment settings by assigning the webhook address. This address is used to send events about the changes of the transaction intent state.
         * @summary Update webhook.
         * @param {SettingsWebhookUpdateRequest} settingsWebhookUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (settingsWebhookUpdateRequest: SettingsWebhookUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingsWebhookUpdateRequest' is not null or undefined
            assertParamExists('updateWebhook', 'settingsWebhookUpdateRequest', settingsWebhookUpdateRequest)
            const localVarPath = `/v1/settings/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsWebhookUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Verify signature and add a depositor address to the current project environment.
         * @summary Add depositor address.
         * @param {PaymasterDepositorCreateRequest} paymasterDepositorCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDepositorAddress(paymasterDepositorCreateRequest: PaymasterDepositorCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymasterDepositorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDepositorAddress(paymasterDepositorCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the list of the depositor addresses for the current project environment.
         * @summary List of depositor addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepositorAddresses(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymasterDepositorListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepositorAddresses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate message, which should be signed for verification of the address ownership.
         * @summary Generate message to sign
         * @param {string} address Specifies the paymaster depositor address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageForSigningDepositorAddress(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymasterDepositorGetMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageForSigningDepositorAddress(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a depositor address from the current project environment.
         * @summary Removes depositor address.
         * @param {string} id Specifies unique identifier of depositor address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDepositorAddress(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymasterDepositorDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDepositorAddress(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updated the current project environment settings by removing the webhook address. After that system will stop sending events of the transaction intent state changes
         * @summary Removes webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeWebhook(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeWebhook(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updated the current project environment settings by assigning the webhook address. This address is used to send events about the changes of the transaction intent state.
         * @summary Update webhook.
         * @param {SettingsWebhookUpdateRequest} settingsWebhookUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(settingsWebhookUpdateRequest: SettingsWebhookUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(settingsWebhookUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * Verify signature and add a depositor address to the current project environment.
         * @summary Add depositor address.
         * @param {PaymasterDepositorCreateRequest} paymasterDepositorCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDepositorAddress(paymasterDepositorCreateRequest: PaymasterDepositorCreateRequest, options?: any): AxiosPromise<PaymasterDepositorResponse> {
            return localVarFp.addDepositorAddress(paymasterDepositorCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the list of the depositor addresses for the current project environment.
         * @summary List of depositor addresses.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepositorAddresses(options?: any): AxiosPromise<PaymasterDepositorListResponse> {
            return localVarFp.getDepositorAddresses(options).then((request) => request(axios, basePath));
        },
        /**
         * Generate message, which should be signed for verification of the address ownership.
         * @summary Generate message to sign
         * @param {string} address Specifies the paymaster depositor address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageForSigningDepositorAddress(address: string, options?: any): AxiosPromise<PaymasterDepositorGetMessageResponse> {
            return localVarFp.getMessageForSigningDepositorAddress(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a depositor address from the current project environment.
         * @summary Removes depositor address.
         * @param {string} id Specifies unique identifier of depositor address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDepositorAddress(id: string, options?: any): AxiosPromise<PaymasterDepositorDeleteResponse> {
            return localVarFp.removeDepositorAddress(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updated the current project environment settings by removing the webhook address. After that system will stop sending events of the transaction intent state changes
         * @summary Removes webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(options?: any): AxiosPromise<void> {
            return localVarFp.removeWebhook(options).then((request) => request(axios, basePath));
        },
        /**
         * Updated the current project environment settings by assigning the webhook address. This address is used to send events about the changes of the transaction intent state.
         * @summary Update webhook.
         * @param {SettingsWebhookUpdateRequest} settingsWebhookUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(settingsWebhookUpdateRequest: SettingsWebhookUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateWebhook(settingsWebhookUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * Verify signature and add a depositor address to the current project environment.
     * @summary Add depositor address.
     * @param {PaymasterDepositorCreateRequest} paymasterDepositorCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public addDepositorAddress(paymasterDepositorCreateRequest: PaymasterDepositorCreateRequest, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).addDepositorAddress(paymasterDepositorCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the list of the depositor addresses for the current project environment.
     * @summary List of depositor addresses.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getDepositorAddresses(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getDepositorAddresses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate message, which should be signed for verification of the address ownership.
     * @summary Generate message to sign
     * @param {string} address Specifies the paymaster depositor address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getMessageForSigningDepositorAddress(address: string, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getMessageForSigningDepositorAddress(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a depositor address from the current project environment.
     * @summary Removes depositor address.
     * @param {string} id Specifies unique identifier of depositor address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public removeDepositorAddress(id: string, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).removeDepositorAddress(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updated the current project environment settings by removing the webhook address. After that system will stop sending events of the transaction intent state changes
     * @summary Removes webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public removeWebhook(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).removeWebhook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updated the current project environment settings by assigning the webhook address. This address is used to send events about the changes of the transaction intent state.
     * @summary Update webhook.
     * @param {SettingsWebhookUpdateRequest} settingsWebhookUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public updateWebhook(settingsWebhookUpdateRequest: SettingsWebhookUpdateRequest, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).updateWebhook(settingsWebhookUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionIntentsApi - axios parameter creator
 * @export
 */
export const TransactionIntentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a transaction intent by providing their id on Openfort. Transaction intents that have not been processed yet, have the `response` attribute as undefined.
         * @summary Create a transaction intent object.
         * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionIntent: async (createTransactionIntentRequest: CreateTransactionIntentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransactionIntentRequest' is not null or undefined
            assertParamExists('createTransactionIntent', 'createTransactionIntentRequest', createTransactionIntentRequest)
            const localVarPath = `/v1/transaction_intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransactionIntentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimate the gas cost of creating a transaction intent and putting it on chain. If a policy that includes payment of gas in ERC-20 tokens is provided, an extra field `estimatedTXGasFeeToken` is returned with the estimated amount of tokens.
         * @summary Estimate gas cost of creating a transaction
         * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateTransactionIntentCost: async (createTransactionIntentRequest: CreateTransactionIntentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransactionIntentRequest' is not null or undefined
            assertParamExists('estimateTransactionIntentCost', 'createTransactionIntentRequest', createTransactionIntentRequest)
            const localVarPath = `/v1/transaction_intents/estimate_gas_cost`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransactionIntentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a transaction intent object.
         * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
         * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionIntent: async (id: string, expand?: Array<TransactionIntentResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransactionIntent', 'id', id)
            const localVarPath = `/v1/transaction_intents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List transaction intents.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {number} [chainId] The chain ID.
         * @param {Array<string>} [accountId] Filter by account ID.
         * @param {Array<string>} [playerId] Filter by player ID (starts with pla_).
         * @param {Array<string>} [policyId] Filter by policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionIntents: async (limit?: number, skip?: number, order?: SortOrder, expand?: Array<TransactionIntentResponseExpandable>, chainId?: number, accountId?: Array<string>, playerId?: Array<string>, policyId?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/transaction_intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (playerId) {
                localVarQueryParameter['playerId'] = playerId;
            }

            if (policyId) {
                localVarQueryParameter['policyId'] = policyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to send the signed userOperationHash.  For non-custodial smart accounts, each on chain action using their wallet, they must sign the userOperationHash received from the `POST` API endpoint that creates a transactionIntent.
         * @summary Confirms the creation of a transaction intent with an external owner.
         * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signature: async (id: string, signatureRequest: SignatureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signature', 'id', id)
            // verify required parameter 'signatureRequest' is not null or undefined
            assertParamExists('signature', 'signatureRequest', signatureRequest)
            const localVarPath = `/v1/transaction_intents/{id}/signature`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionIntentsApi - functional programming interface
 * @export
 */
export const TransactionIntentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionIntentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a transaction intent by providing their id on Openfort. Transaction intents that have not been processed yet, have the `response` attribute as undefined.
         * @summary Create a transaction intent object.
         * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransactionIntent(createTransactionIntentRequest: CreateTransactionIntentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransactionIntent(createTransactionIntentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Estimate the gas cost of creating a transaction intent and putting it on chain. If a policy that includes payment of gas in ERC-20 tokens is provided, an extra field `estimatedTXGasFeeToken` is returned with the estimated amount of tokens.
         * @summary Estimate gas cost of creating a transaction
         * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateTransactionIntentCost(createTransactionIntentRequest: CreateTransactionIntentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateTransactionIntentGasResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateTransactionIntentCost(createTransactionIntentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a transaction intent object.
         * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
         * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionIntent(id: string, expand?: Array<TransactionIntentResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionIntent(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List transaction intents.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {number} [chainId] The chain ID.
         * @param {Array<string>} [accountId] Filter by account ID.
         * @param {Array<string>} [playerId] Filter by player ID (starts with pla_).
         * @param {Array<string>} [policyId] Filter by policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionIntents(limit?: number, skip?: number, order?: SortOrder, expand?: Array<TransactionIntentResponseExpandable>, chainId?: number, accountId?: Array<string>, playerId?: Array<string>, policyId?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionIntents(limit, skip, order, expand, chainId, accountId, playerId, policyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is used to send the signed userOperationHash.  For non-custodial smart accounts, each on chain action using their wallet, they must sign the userOperationHash received from the `POST` API endpoint that creates a transactionIntent.
         * @summary Confirms the creation of a transaction intent with an external owner.
         * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signature(id: string, signatureRequest: SignatureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signature(id, signatureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionIntentsApi - factory interface
 * @export
 */
export const TransactionIntentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionIntentsApiFp(configuration)
    return {
        /**
         * Retrieve a transaction intent by providing their id on Openfort. Transaction intents that have not been processed yet, have the `response` attribute as undefined.
         * @summary Create a transaction intent object.
         * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionIntent(createTransactionIntentRequest: CreateTransactionIntentRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.createTransactionIntent(createTransactionIntentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Estimate the gas cost of creating a transaction intent and putting it on chain. If a policy that includes payment of gas in ERC-20 tokens is provided, an extra field `estimatedTXGasFeeToken` is returned with the estimated amount of tokens.
         * @summary Estimate gas cost of creating a transaction
         * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateTransactionIntentCost(createTransactionIntentRequest: CreateTransactionIntentRequest, options?: any): AxiosPromise<EstimateTransactionIntentGasResult> {
            return localVarFp.estimateTransactionIntentCost(createTransactionIntentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a transaction intent object.
         * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
         * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionIntent(id: string, expand?: Array<TransactionIntentResponseExpandable>, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.getTransactionIntent(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List transaction intents.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {number} [chainId] The chain ID.
         * @param {Array<string>} [accountId] Filter by account ID.
         * @param {Array<string>} [playerId] Filter by player ID (starts with pla_).
         * @param {Array<string>} [policyId] Filter by policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionIntents(limit?: number, skip?: number, order?: SortOrder, expand?: Array<TransactionIntentResponseExpandable>, chainId?: number, accountId?: Array<string>, playerId?: Array<string>, policyId?: Array<string>, options?: any): AxiosPromise<TransactionIntentListResponse> {
            return localVarFp.getTransactionIntents(limit, skip, order, expand, chainId, accountId, playerId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used to send the signed userOperationHash.  For non-custodial smart accounts, each on chain action using their wallet, they must sign the userOperationHash received from the `POST` API endpoint that creates a transactionIntent.
         * @summary Confirms the creation of a transaction intent with an external owner.
         * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signature(id: string, signatureRequest: SignatureRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.signature(id, signatureRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionIntentsApi - object-oriented interface
 * @export
 * @class TransactionIntentsApi
 * @extends {BaseAPI}
 */
export class TransactionIntentsApi extends BaseAPI {
    /**
     * Retrieve a transaction intent by providing their id on Openfort. Transaction intents that have not been processed yet, have the `response` attribute as undefined.
     * @summary Create a transaction intent object.
     * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public createTransactionIntent(createTransactionIntentRequest: CreateTransactionIntentRequest, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).createTransactionIntent(createTransactionIntentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Estimate the gas cost of creating a transaction intent and putting it on chain. If a policy that includes payment of gas in ERC-20 tokens is provided, an extra field `estimatedTXGasFeeToken` is returned with the estimated amount of tokens.
     * @summary Estimate gas cost of creating a transaction
     * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public estimateTransactionIntentCost(createTransactionIntentRequest: CreateTransactionIntentRequest, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).estimateTransactionIntentCost(createTransactionIntentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a transaction intent object.
     * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
     * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the expandable fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public getTransactionIntent(id: string, expand?: Array<TransactionIntentResponseExpandable>, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).getTransactionIntent(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List transaction intents.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the fields to expand in the response.
     * @param {number} [chainId] The chain ID.
     * @param {Array<string>} [accountId] Filter by account ID.
     * @param {Array<string>} [playerId] Filter by player ID (starts with pla_).
     * @param {Array<string>} [policyId] Filter by policy ID (starts with pol_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public getTransactionIntents(limit?: number, skip?: number, order?: SortOrder, expand?: Array<TransactionIntentResponseExpandable>, chainId?: number, accountId?: Array<string>, playerId?: Array<string>, policyId?: Array<string>, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).getTransactionIntents(limit, skip, order, expand, chainId, accountId, playerId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used to send the signed userOperationHash.  For non-custodial smart accounts, each on chain action using their wallet, they must sign the userOperationHash received from the `POST` API endpoint that creates a transactionIntent.
     * @summary Confirms the creation of a transaction intent with an external owner.
     * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
     * @param {SignatureRequest} signatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public signature(id: string, signatureRequest: SignatureRequest, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).signature(id, signatureRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Web3ConnectionsApi - axios parameter creator
 * @export
 */
export const Web3ConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows you to create a new web3 connection to your Openfort player. Together with the player ID (pla_), you need to provide a chain ID. The chain to use is required because Openfort needs to make sure the account is deployed, as counterfactual addresses cannot use web3 connections. The `uri` body parameter must contain a WalletConnect pairing URI (see: https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-uri)
         * @summary Create a Web3 Connection object.
         * @param {CreateWeb3ConnectionRequest} createWeb3ConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWeb3Connection: async (createWeb3ConnectionRequest: CreateWeb3ConnectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWeb3ConnectionRequest' is not null or undefined
            assertParamExists('createWeb3Connection', 'createWeb3ConnectionRequest', createWeb3ConnectionRequest)
            const localVarPath = `/v1/web3_connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWeb3ConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of web3 actions for the given web3 connection. The actions are returned sorted by creation date, with the most recently received action appearing first. By default, a maximum of ten actions are shown per page.
         * @summary List Web3 actions from a web3 connection.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeb3Actions: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWeb3Actions', 'id', id)
            const localVarPath = `/v1/web3_connections/{id}/actions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing web3 connection. Supply the unique web3 connection ID from either a web3 connection creation request or the web3 connection list. Openfort will return the corresponding web3 connection information.
         * @summary Get a web3Connection object.
         * @param {string} id Specifies the unique web3Connection ID (starts with web3_).
         * @param {Array<Web3ConnectionResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeb3Connection: async (id: string, expand?: Array<Web3ConnectionResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWeb3Connection', 'id', id)
            const localVarPath = `/v1/web3_connections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of web3 connections for the given player. The connections are returned sorted by creation date, with the most recently created connections appearing first. By default, a maximum of ten connections are shown per page.
         * @summary List Web3 connections.
         * @param {string} player Specifies the unique player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {boolean} [disconnected] Specifies connection status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeb3Connections: async (player: string, limit?: number, skip?: number, order?: SortOrder, disconnected?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'player' is not null or undefined
            assertParamExists('getWeb3Connections', 'player', player)
            const localVarPath = `/v1/web3_connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }

            if (disconnected !== undefined) {
                localVarQueryParameter['disconnected'] = disconnected;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Approve or Reject a web3 action for the given web3 connection.
         * @summary Approve or Reject a web3 action
         * @param {string} id 
         * @param {string} web3Action 
         * @param {SubmitWeb3ActionRequest} submitWeb3ActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWeb3Action: async (id: string, web3Action: string, submitWeb3ActionRequest: SubmitWeb3ActionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitWeb3Action', 'id', id)
            // verify required parameter 'web3Action' is not null or undefined
            assertParamExists('submitWeb3Action', 'web3Action', web3Action)
            // verify required parameter 'submitWeb3ActionRequest' is not null or undefined
            assertParamExists('submitWeb3Action', 'submitWeb3ActionRequest', submitWeb3ActionRequest)
            const localVarPath = `/v1/web3_connections/{id}/actions/{web3_action}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"web3_action"}}`, encodeURIComponent(String(web3Action)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitWeb3ActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Web3ConnectionsApi - functional programming interface
 * @export
 */
export const Web3ConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Web3ConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows you to create a new web3 connection to your Openfort player. Together with the player ID (pla_), you need to provide a chain ID. The chain to use is required because Openfort needs to make sure the account is deployed, as counterfactual addresses cannot use web3 connections. The `uri` body parameter must contain a WalletConnect pairing URI (see: https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-uri)
         * @summary Create a Web3 Connection object.
         * @param {CreateWeb3ConnectionRequest} createWeb3ConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWeb3Connection(createWeb3ConnectionRequest: CreateWeb3ConnectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Web3ConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWeb3Connection(createWeb3ConnectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of web3 actions for the given web3 connection. The actions are returned sorted by creation date, with the most recently received action appearing first. By default, a maximum of ten actions are shown per page.
         * @summary List Web3 actions from a web3 connection.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWeb3Actions(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Web3ActionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWeb3Actions(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing web3 connection. Supply the unique web3 connection ID from either a web3 connection creation request or the web3 connection list. Openfort will return the corresponding web3 connection information.
         * @summary Get a web3Connection object.
         * @param {string} id Specifies the unique web3Connection ID (starts with web3_).
         * @param {Array<Web3ConnectionResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWeb3Connection(id: string, expand?: Array<Web3ConnectionResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Web3ConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWeb3Connection(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of web3 connections for the given player. The connections are returned sorted by creation date, with the most recently created connections appearing first. By default, a maximum of ten connections are shown per page.
         * @summary List Web3 connections.
         * @param {string} player Specifies the unique player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {boolean} [disconnected] Specifies connection status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWeb3Connections(player: string, limit?: number, skip?: number, order?: SortOrder, disconnected?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Web3ConnectionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWeb3Connections(player, limit, skip, order, disconnected, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Approve or Reject a web3 action for the given web3 connection.
         * @summary Approve or Reject a web3 action
         * @param {string} id 
         * @param {string} web3Action 
         * @param {SubmitWeb3ActionRequest} submitWeb3ActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitWeb3Action(id: string, web3Action: string, submitWeb3ActionRequest: SubmitWeb3ActionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Web3ActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitWeb3Action(id, web3Action, submitWeb3ActionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Web3ConnectionsApi - factory interface
 * @export
 */
export const Web3ConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Web3ConnectionsApiFp(configuration)
    return {
        /**
         * This endpoint allows you to create a new web3 connection to your Openfort player. Together with the player ID (pla_), you need to provide a chain ID. The chain to use is required because Openfort needs to make sure the account is deployed, as counterfactual addresses cannot use web3 connections. The `uri` body parameter must contain a WalletConnect pairing URI (see: https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-uri)
         * @summary Create a Web3 Connection object.
         * @param {CreateWeb3ConnectionRequest} createWeb3ConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWeb3Connection(createWeb3ConnectionRequest: CreateWeb3ConnectionRequest, options?: any): AxiosPromise<Web3ConnectionResponse> {
            return localVarFp.createWeb3Connection(createWeb3ConnectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of web3 actions for the given web3 connection. The actions are returned sorted by creation date, with the most recently received action appearing first. By default, a maximum of ten actions are shown per page.
         * @summary List Web3 actions from a web3 connection.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeb3Actions(id: string, options?: any): AxiosPromise<Web3ActionListResponse> {
            return localVarFp.getWeb3Actions(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing web3 connection. Supply the unique web3 connection ID from either a web3 connection creation request or the web3 connection list. Openfort will return the corresponding web3 connection information.
         * @summary Get a web3Connection object.
         * @param {string} id Specifies the unique web3Connection ID (starts with web3_).
         * @param {Array<Web3ConnectionResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeb3Connection(id: string, expand?: Array<Web3ConnectionResponseExpandable>, options?: any): AxiosPromise<Web3ConnectionResponse> {
            return localVarFp.getWeb3Connection(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of web3 connections for the given player. The connections are returned sorted by creation date, with the most recently created connections appearing first. By default, a maximum of ten connections are shown per page.
         * @summary List Web3 connections.
         * @param {string} player Specifies the unique player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {boolean} [disconnected] Specifies connection status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeb3Connections(player: string, limit?: number, skip?: number, order?: SortOrder, disconnected?: boolean, options?: any): AxiosPromise<Web3ConnectionListResponse> {
            return localVarFp.getWeb3Connections(player, limit, skip, order, disconnected, options).then((request) => request(axios, basePath));
        },
        /**
         * Approve or Reject a web3 action for the given web3 connection.
         * @summary Approve or Reject a web3 action
         * @param {string} id 
         * @param {string} web3Action 
         * @param {SubmitWeb3ActionRequest} submitWeb3ActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWeb3Action(id: string, web3Action: string, submitWeb3ActionRequest: SubmitWeb3ActionRequest, options?: any): AxiosPromise<Web3ActionResponse> {
            return localVarFp.submitWeb3Action(id, web3Action, submitWeb3ActionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Web3ConnectionsApi - object-oriented interface
 * @export
 * @class Web3ConnectionsApi
 * @extends {BaseAPI}
 */
export class Web3ConnectionsApi extends BaseAPI {
    /**
     * This endpoint allows you to create a new web3 connection to your Openfort player. Together with the player ID (pla_), you need to provide a chain ID. The chain to use is required because Openfort needs to make sure the account is deployed, as counterfactual addresses cannot use web3 connections. The `uri` body parameter must contain a WalletConnect pairing URI (see: https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-uri)
     * @summary Create a Web3 Connection object.
     * @param {CreateWeb3ConnectionRequest} createWeb3ConnectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Web3ConnectionsApi
     */
    public createWeb3Connection(createWeb3ConnectionRequest: CreateWeb3ConnectionRequest, options?: AxiosRequestConfig) {
        return Web3ConnectionsApiFp(this.configuration).createWeb3Connection(createWeb3ConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of web3 actions for the given web3 connection. The actions are returned sorted by creation date, with the most recently received action appearing first. By default, a maximum of ten actions are shown per page.
     * @summary List Web3 actions from a web3 connection.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Web3ConnectionsApi
     */
    public getWeb3Actions(id: string, options?: AxiosRequestConfig) {
        return Web3ConnectionsApiFp(this.configuration).getWeb3Actions(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing web3 connection. Supply the unique web3 connection ID from either a web3 connection creation request or the web3 connection list. Openfort will return the corresponding web3 connection information.
     * @summary Get a web3Connection object.
     * @param {string} id Specifies the unique web3Connection ID (starts with web3_).
     * @param {Array<Web3ConnectionResponseExpandable>} [expand] Specifies the fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Web3ConnectionsApi
     */
    public getWeb3Connection(id: string, expand?: Array<Web3ConnectionResponseExpandable>, options?: AxiosRequestConfig) {
        return Web3ConnectionsApiFp(this.configuration).getWeb3Connection(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of web3 connections for the given player. The connections are returned sorted by creation date, with the most recently created connections appearing first. By default, a maximum of ten connections are shown per page.
     * @summary List Web3 connections.
     * @param {string} player Specifies the unique player ID (starts with pla_)
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {boolean} [disconnected] Specifies connection status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Web3ConnectionsApi
     */
    public getWeb3Connections(player: string, limit?: number, skip?: number, order?: SortOrder, disconnected?: boolean, options?: AxiosRequestConfig) {
        return Web3ConnectionsApiFp(this.configuration).getWeb3Connections(player, limit, skip, order, disconnected, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Approve or Reject a web3 action for the given web3 connection.
     * @summary Approve or Reject a web3 action
     * @param {string} id 
     * @param {string} web3Action 
     * @param {SubmitWeb3ActionRequest} submitWeb3ActionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Web3ConnectionsApi
     */
    public submitWeb3Action(id: string, web3Action: string, submitWeb3ActionRequest: SubmitWeb3ActionRequest, options?: AxiosRequestConfig) {
        return Web3ConnectionsApiFp(this.configuration).submitWeb3Action(id, web3Action, submitWeb3ActionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


