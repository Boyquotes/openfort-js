/* tslint:disable */
/* eslint-disable */
/**
 * Openfort API
 * Complete Openfort API references and guides can be found at: https://openfort.xyz/docs
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: founders@openfort.xyz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountPlayerRequest
 */
export interface AccountPlayerRequest {
    /**
     * The chain_id
     * @type {number}
     * @memberof AccountPlayerRequest
     */
    'chain_id': number;
    /**
     * The address of the external owner
     * @type {string}
     * @memberof AccountPlayerRequest
     */
    'external_owner_address'?: string;
}
/**
 * 
 * @export
 * @interface AccountRequest
 */
export interface AccountRequest {
    /**
     * The chain_id
     * @type {number}
     * @memberof AccountRequest
     */
    'chain_id': number;
    /**
     * The player ID
     * @type {string}
     * @memberof AccountRequest
     */
    'player': string;
    /**
     * The address of the external owner
     * @type {string}
     * @memberof AccountRequest
     */
    'external_owner_address'?: string;
}
/**
 * 
 * @export
 * @interface AccountResponse
 */
export interface AccountResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'object': string;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'address': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountResponse
     */
    'deployed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountResponse
     */
    'custodial': boolean;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'chain_id': number;
    /**
     * 
     * @type {Array<PolicyResponseTransactionIntentsInner>}
     * @memberof AccountResponse
     */
    'transaction_intents': Array<PolicyResponseTransactionIntentsInner>;
}
/**
 * 
 * @export
 * @interface AccountsResponse
 */
export interface AccountsResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountsResponse
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof AccountsResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<AccountResponse>}
     * @memberof AccountsResponse
     */
    'data': Array<AccountResponse>;
}
/**
 * 
 * @export
 * @interface ApiKeyResponse
 */
export interface ApiKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiKeyResponse
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiKeyResponse
     */
    'livemode': boolean;
}
/**
 * 
 * @export
 * @interface AssetInventory
 */
export interface AssetInventory {
    /**
     * 
     * @type {AssetType}
     * @memberof AssetInventory
     */
    'asset_type': AssetType;
    /**
     * 
     * @type {string}
     * @memberof AssetInventory
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetInventory
     */
    'token_id'?: number;
    /**
     * amount in Wei
     * @type {string}
     * @memberof AssetInventory
     */
    'amount'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AssetType = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type AssetType = typeof AssetType[keyof typeof AssetType];


/**
 * 
 * @export
 * @interface ContractDeleteResponse
 */
export interface ContractDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof ContractDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContractDeleteResponse
     */
    'object': string;
    /**
     * 
     * @type {boolean}
     * @memberof ContractDeleteResponse
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface ContractRequest
 */
export interface ContractRequest {
    /**
     * 
     * @type {string}
     * @memberof ContractRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ContractRequest
     */
    'chain_id': number;
    /**
     * 
     * @type {string}
     * @memberof ContractRequest
     */
    'address': string;
    /**
     * 
     * @type {any}
     * @memberof ContractRequest
     */
    'abi'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof ContractRequest
     */
    'public_verification'?: boolean;
}
/**
 * 
 * @export
 * @interface ContractResponse
 */
export interface ContractResponse {
    /**
     * 
     * @type {string}
     * @memberof ContractResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ContractResponse
     */
    'object': string;
    /**
     * 
     * @type {number}
     * @memberof ContractResponse
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof ContractResponse
     */
    'name': string | null;
    /**
     * 
     * @type {number}
     * @memberof ContractResponse
     */
    'chain_id': number;
    /**
     * 
     * @type {string}
     * @memberof ContractResponse
     */
    'address': string;
    /**
     * 
     * @type {any}
     * @memberof ContractResponse
     */
    'abi': any;
    /**
     * 
     * @type {boolean}
     * @memberof ContractResponse
     */
    'public_verification': boolean;
}
/**
 * 
 * @export
 * @interface ContractsResponse
 */
export interface ContractsResponse {
    /**
     * 
     * @type {string}
     * @memberof ContractsResponse
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof ContractsResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<ContractResponse>}
     * @memberof ContractsResponse
     */
    'data': Array<ContractResponse>;
}
/**
 * 
 * @export
 * @interface CreatePlayerRequest
 */
export interface CreatePlayerRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePlayerRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePlayerRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateSessionPlayerRequest
 */
export interface CreateSessionPlayerRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateSessionPlayerRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSessionPlayerRequest
     */
    'policy'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateSessionPlayerRequest
     */
    'optimistic'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateSessionPlayerRequest
     */
    'external_owner_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateSessionPlayerRequest
     */
    'chain_id': number;
    /**
     * 
     * @type {number}
     * @memberof CreateSessionPlayerRequest
     */
    'valid_until': number;
    /**
     * 
     * @type {number}
     * @memberof CreateSessionPlayerRequest
     */
    'valid_after': number;
    /**
     * 
     * @type {number}
     * @memberof CreateSessionPlayerRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateSessionPlayerRequest
     */
    'whitelist'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateSessionRequest
 */
export interface CreateSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateSessionRequest
     */
    'player': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSessionRequest
     */
    'policy'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateSessionRequest
     */
    'optimistic'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateSessionRequest
     */
    'external_owner_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateSessionRequest
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof CreateSessionRequest
     */
    'chain_id': number;
    /**
     * 
     * @type {number}
     * @memberof CreateSessionRequest
     */
    'valid_until': number;
    /**
     * 
     * @type {number}
     * @memberof CreateSessionRequest
     */
    'valid_after': number;
    /**
     * 
     * @type {number}
     * @memberof CreateSessionRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateSessionRequest
     */
    'whitelist'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Gas
 */
export interface Gas {
    /**
     * 
     * @type {string}
     * @memberof Gas
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof Gas
     */
    'url': string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof Gas
     */
    'dailyGasUsage': { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface Interaction
 */
export interface Interaction {
    /**
     * 
     * @type {string}
     * @memberof Interaction
     */
    'contract': string | null;
    /**
     * 
     * @type {string}
     * @memberof Interaction
     */
    'value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Interaction
     */
    'function_name': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof Interaction
     */
    'function_args': Array<any>;
}
/**
 * 
 * @export
 * @interface InventoryResponse
 */
export interface InventoryResponse {
    /**
     * 
     * @type {string}
     * @memberof InventoryResponse
     */
    'object': string;
    /**
     * 
     * @type {Array<AssetInventory>}
     * @memberof InventoryResponse
     */
    'nft_assets'?: Array<AssetInventory>;
    /**
     * 
     * @type {AssetInventory}
     * @memberof InventoryResponse
     */
    'native_asset'?: AssetInventory;
    /**
     * 
     * @type {Array<AssetInventory>}
     * @memberof InventoryResponse
     */
    'token_assets'?: Array<AssetInventory>;
}
/**
 * 
 * @export
 * @interface Log
 */
export interface Log {
    /**
     * 
     * @type {number}
     * @memberof Log
     */
    'blockNumber': number;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'blockHash': string;
    /**
     * 
     * @type {number}
     * @memberof Log
     */
    'transactionIndex': number;
    /**
     * 
     * @type {boolean}
     * @memberof Log
     */
    'removed': boolean;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'data': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Log
     */
    'topics': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'transactionHash': string;
    /**
     * 
     * @type {number}
     * @memberof Log
     */
    'logIndex': number;
}
/**
 * Enums
 * @export
 * @enum {string}
 */

export const PKLocation = {
    Db: 'DB',
    GcpKms: 'GCP_KMS',
    User: 'USER'
} as const;

export type PKLocation = typeof PKLocation[keyof typeof PKLocation];


/**
 * 
 * @export
 * @enum {string}
 */

export const PKPolicy = {
    Individual: 'INDIVIDUAL',
    Project: 'PROJECT'
} as const;

export type PKPolicy = typeof PKPolicy[keyof typeof PKPolicy];


/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickAccountResponseId
 */
export interface PickAccountResponseId {
    /**
     * 
     * @type {string}
     * @memberof PickAccountResponseId
     */
    'id': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPlayerResponseId
 */
export interface PickPlayerResponseId {
    /**
     * 
     * @type {string}
     * @memberof PickPlayerResponseId
     */
    'id': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPolicyResponseId
 */
export interface PickPolicyResponseId {
    /**
     * 
     * @type {string}
     * @memberof PickPolicyResponseId
     */
    'id': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPolicyRuleResponseId
 */
export interface PickPolicyRuleResponseId {
    /**
     * 
     * @type {string}
     * @memberof PickPolicyRuleResponseId
     */
    'id': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickTransactionIntentResponseId
 */
export interface PickTransactionIntentResponseId {
    /**
     * 
     * @type {string}
     * @memberof PickTransactionIntentResponseId
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface PlayerRequest
 */
export interface PlayerRequest {
    /**
     * 
     * @type {string}
     * @memberof PlayerRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface PlayerResponse
 */
export interface PlayerResponse {
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    'object': string;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponse
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    'metadata': string;
    /**
     * 
     * @type {Array<PolicyResponseTransactionIntentsInner>}
     * @memberof PlayerResponse
     */
    'transaction_intents'?: Array<PolicyResponseTransactionIntentsInner>;
    /**
     * 
     * @type {Array<TransactionIntentResponseAccount>}
     * @memberof PlayerResponse
     */
    'accounts'?: Array<TransactionIntentResponseAccount>;
}
/**
 * 
 * @export
 * @interface PlayerTransferOwnershipRequest
 */
export interface PlayerTransferOwnershipRequest {
    /**
     * The policy ID
     * @type {string}
     * @memberof PlayerTransferOwnershipRequest
     */
    'policy': string;
    /**
     * The chain_id where the account is.
     * @type {number}
     * @memberof PlayerTransferOwnershipRequest
     */
    'chain_id': number;
    /**
     * The address of the new owner
     * @type {string}
     * @memberof PlayerTransferOwnershipRequest
     */
    'new_owner_address': string;
    /**
     * The player ID
     * @type {string}
     * @memberof PlayerTransferOwnershipRequest
     */
    'player'?: string;
}
/**
 * 
 * @export
 * @interface PlayersResponse
 */
export interface PlayersResponse {
    /**
     * 
     * @type {string}
     * @memberof PlayersResponse
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof PlayersResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<PlayerResponse>}
     * @memberof PlayersResponse
     */
    'data': Array<PlayerResponse>;
}
/**
 * 
 * @export
 * @interface PoliciesResponse
 */
export interface PoliciesResponse {
    /**
     * 
     * @type {string}
     * @memberof PoliciesResponse
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof PoliciesResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<PolicyResponse>}
     * @memberof PoliciesResponse
     */
    'data': Array<PolicyResponse>;
}
/**
 * 
 * @export
 * @interface PolicyAllowFunctionRequest
 */
export interface PolicyAllowFunctionRequest {
    /**
     * 
     * @type {PolicySchema}
     * @memberof PolicyAllowFunctionRequest
     */
    'type': PolicySchema;
    /**
     * 
     * @type {string}
     * @memberof PolicyAllowFunctionRequest
     */
    'function_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof PolicyAllowFunctionRequest
     */
    'contract': string | null;
}


/**
 * 
 * @export
 * @interface PolicyDeleteResponse
 */
export interface PolicyDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyDeleteResponse
     */
    'object': string;
    /**
     * 
     * @type {boolean}
     * @memberof PolicyDeleteResponse
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface PolicyRequest
 */
export interface PolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof PolicyRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PolicyRequest
     */
    'chain_id': number;
    /**
     * 
     * @type {Strategy}
     * @memberof PolicyRequest
     */
    'strategy'?: Strategy;
}
/**
 * 
 * @export
 * @interface PolicyResponse
 */
export interface PolicyResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyResponse
     */
    'object': string;
    /**
     * 
     * @type {number}
     * @memberof PolicyResponse
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof PolicyResponse
     */
    'name': string | null;
    /**
     * 
     * @type {number}
     * @memberof PolicyResponse
     */
    'chain_id': number;
    /**
     * 
     * @type {any}
     * @memberof PolicyResponse
     */
    'strategy': any;
    /**
     * 
     * @type {Array<PolicyResponseTransactionIntentsInner>}
     * @memberof PolicyResponse
     */
    'transaction_intents'?: Array<PolicyResponseTransactionIntentsInner>;
    /**
     * 
     * @type {Array<PolicyResponsePolicyRulesInner>}
     * @memberof PolicyResponse
     */
    'policy_rules'?: Array<PolicyResponsePolicyRulesInner>;
}
/**
 * 
 * @export
 * @interface PolicyResponsePolicyRulesInner
 */
export interface PolicyResponsePolicyRulesInner {
    /**
     * 
     * @type {string}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'object': string;
    /**
     * 
     * @type {number}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'created_at': number;
    /**
     * 
     * @type {PolicySchema}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'type': PolicySchema;
    /**
     * 
     * @type {string}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'function_name': string | null;
    /**
     * 
     * @type {PolicyRuleResponseContract}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'contract': PolicyRuleResponseContract | null;
}


/**
 * 
 * @export
 * @interface PolicyResponseTransactionIntentsInner
 */
export interface PolicyResponseTransactionIntentsInner {
    /**
     * 
     * @type {string}
     * @memberof PolicyResponseTransactionIntentsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyResponseTransactionIntentsInner
     */
    'object': string;
    /**
     * 
     * @type {number}
     * @memberof PolicyResponseTransactionIntentsInner
     */
    'created_at': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyResponseTransactionIntentsInner
     */
    'updated_at': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyResponseTransactionIntentsInner
     */
    'chain_id': number;
    /**
     * 
     * @type {string}
     * @memberof PolicyResponseTransactionIntentsInner
     */
    'user_operation_hash': string | null;
    /**
     * 
     * @type {any}
     * @memberof PolicyResponseTransactionIntentsInner
     */
    'user_operation'?: any;
    /**
     * 
     * @type {TransactionIntentResponsePolicy}
     * @memberof PolicyResponseTransactionIntentsInner
     */
    'policy': TransactionIntentResponsePolicy | null;
    /**
     * 
     * @type {TransactionIntentResponsePlayer}
     * @memberof PolicyResponseTransactionIntentsInner
     */
    'player'?: TransactionIntentResponsePlayer;
    /**
     * 
     * @type {object}
     * @memberof PolicyResponseTransactionIntentsInner
     */
    'next_action'?: object | null;
    /**
     * 
     * @type {TransactionIntentResponseAccount}
     * @memberof PolicyResponseTransactionIntentsInner
     */
    'account'?: TransactionIntentResponseAccount;
    /**
     * 
     * @type {Array<Interaction>}
     * @memberof PolicyResponseTransactionIntentsInner
     */
    'interactions': Array<Interaction> | null;
    /**
     * 
     * @type {ResponseResponse}
     * @memberof PolicyResponseTransactionIntentsInner
     */
    'response': ResponseResponse | null;
}
/**
 * 
 * @export
 * @interface PolicyRuleDeleteResponse
 */
export interface PolicyRuleDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleDeleteResponse
     */
    'object': string;
    /**
     * 
     * @type {boolean}
     * @memberof PolicyRuleDeleteResponse
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface PolicyRuleRequest
 */
export interface PolicyRuleRequest {
    /**
     * 
     * @type {PolicySchema}
     * @memberof PolicyRuleRequest
     */
    'type': PolicySchema;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleRequest
     */
    'function_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleRequest
     */
    'policy': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleRequest
     */
    'contract': string | null;
}


/**
 * 
 * @export
 * @interface PolicyRuleResponse
 */
export interface PolicyRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleResponse
     */
    'object': string;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleResponse
     */
    'created_at': number;
    /**
     * 
     * @type {PolicySchema}
     * @memberof PolicyRuleResponse
     */
    'type': PolicySchema;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleResponse
     */
    'function_name': string | null;
    /**
     * 
     * @type {PolicyRuleResponseContract}
     * @memberof PolicyRuleResponse
     */
    'contract': PolicyRuleResponseContract | null;
}


/**
 * 
 * @export
 * @interface PolicyRuleResponseContract
 */
export interface PolicyRuleResponseContract {
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleResponseContract
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleResponseContract
     */
    'object': string;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleResponseContract
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleResponseContract
     */
    'name': string | null;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleResponseContract
     */
    'chain_id': number;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleResponseContract
     */
    'address': string;
    /**
     * 
     * @type {any}
     * @memberof PolicyRuleResponseContract
     */
    'abi': any;
    /**
     * 
     * @type {boolean}
     * @memberof PolicyRuleResponseContract
     */
    'public_verification': boolean;
}
/**
 * 
 * @export
 * @interface PolicyRuleUpdateRequest
 */
export interface PolicyRuleUpdateRequest {
    /**
     * 
     * @type {PolicySchema}
     * @memberof PolicyRuleUpdateRequest
     */
    'type'?: PolicySchema;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleUpdateRequest
     */
    'function_name': string | null;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleUpdateRequest
     */
    'policy'?: string;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleUpdateRequest
     */
    'contract': string | null;
}


/**
 * 
 * @export
 * @interface PolicyRulesResponse
 */
export interface PolicyRulesResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyRulesResponse
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyRulesResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<PolicyRuleResponse>}
     * @memberof PolicyRulesResponse
     */
    'data': Array<PolicyRuleResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PolicySchema = {
    ContractFunctions: 'contract_functions',
    AccountFunctions: 'account_functions'
} as const;

export type PolicySchema = typeof PolicySchema[keyof typeof PolicySchema];


/**
 * 
 * @export
 * @interface PolicyUpdateRequest
 */
export interface PolicyUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PolicyUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PolicyUpdateRequest
     */
    'chain_id'?: number;
    /**
     * 
     * @type {Strategy}
     * @memberof PolicyUpdateRequest
     */
    'strategy'?: Strategy;
}
/**
 * 
 * @export
 * @interface ProjectLogs
 */
export interface ProjectLogs {
    /**
     * 
     * @type {string}
     * @memberof ProjectLogs
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectLogs
     */
    'url': string;
    /**
     * 
     * @type {Array<Log>}
     * @memberof ProjectLogs
     */
    'data': Array<Log>;
}
/**
 * 
 * @export
 * @interface ProjectRequest
 */
export interface ProjectRequest {
    /**
     * 
     * @type {string}
     * @memberof ProjectRequest
     */
    'name': string;
    /**
     * 
     * @type {PKPolicy}
     * @memberof ProjectRequest
     */
    'pk_policy'?: PKPolicy;
    /**
     * 
     * @type {PKLocation}
     * @memberof ProjectRequest
     */
    'pk_location'?: PKLocation;
}


/**
 * 
 * @export
 * @interface ProjectResponse
 */
export interface ProjectResponse {
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    'object': string;
    /**
     * 
     * @type {number}
     * @memberof ProjectResponse
     */
    'created_at': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectResponse
     */
    'updated_at': number;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    'name': string;
    /**
     * 
     * @type {PKPolicy}
     * @memberof ProjectResponse
     */
    'pk_policy': PKPolicy;
    /**
     * 
     * @type {Array<ApiKeyResponse>}
     * @memberof ProjectResponse
     */
    'apikeys'?: Array<ApiKeyResponse>;
}


/**
 * 
 * @export
 * @interface ProjectsResponse
 */
export interface ProjectsResponse {
    /**
     * 
     * @type {string}
     * @memberof ProjectsResponse
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectsResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<ProjectResponse>}
     * @memberof ProjectsResponse
     */
    'data': Array<ProjectResponse>;
}
/**
 * 
 * @export
 * @interface ResponseResponse
 */
export interface ResponseResponse {
    /**
     * 
     * @type {number}
     * @memberof ResponseResponse
     */
    'created_at': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseResponse
     */
    'block_number': number | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseResponse
     */
    'transaction_hash': string | null;
    /**
     * 
     * @type {number}
     * @memberof ResponseResponse
     */
    'gas_used'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ResponseResponse
     */
    'status'?: number | null;
    /**
     * 
     * @type {Array<Log>}
     * @memberof ResponseResponse
     */
    'logs'?: Array<Log> | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseResponse
     */
    'to'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof ResponseResponse
     */
    'error'?: any;
}
/**
 * 
 * @export
 * @interface RevokeSessionPlayerRequest
 */
export interface RevokeSessionPlayerRequest {
    /**
     * 
     * @type {string}
     * @memberof RevokeSessionPlayerRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof RevokeSessionPlayerRequest
     */
    'policy'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RevokeSessionPlayerRequest
     */
    'optimistic'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RevokeSessionPlayerRequest
     */
    'chain_id': number;
}
/**
 * 
 * @export
 * @interface RevokeSessionRequest
 */
export interface RevokeSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof RevokeSessionRequest
     */
    'player': string;
    /**
     * 
     * @type {number}
     * @memberof RevokeSessionRequest
     */
    'chain_id': number;
    /**
     * 
     * @type {boolean}
     * @memberof RevokeSessionRequest
     */
    'optimistic'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RevokeSessionRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof RevokeSessionRequest
     */
    'policy'?: string;
}
/**
 * 
 * @export
 * @interface SessionResponse
 */
export interface SessionResponse {
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'object': string;
    /**
     * 
     * @type {number}
     * @memberof SessionResponse
     */
    'created_at': number;
    /**
     * 
     * @type {number}
     * @memberof SessionResponse
     */
    'updated_at': number;
    /**
     * 
     * @type {boolean}
     * @memberof SessionResponse
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'valid_after'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'valid_until'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SessionResponse
     */
    'whitelist'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SessionResponse
     */
    'limit'?: number;
    /**
     * 
     * @type {object}
     * @memberof SessionResponse
     */
    'next_action': object | null;
    /**
     * 
     * @type {Array<PolicyResponseTransactionIntentsInner>}
     * @memberof SessionResponse
     */
    'transaction_intents': Array<PolicyResponseTransactionIntentsInner> | null;
}
/**
 * 
 * @export
 * @interface SessionsResponse
 */
export interface SessionsResponse {
    /**
     * 
     * @type {string}
     * @memberof SessionsResponse
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof SessionsResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<SessionResponse>}
     * @memberof SessionsResponse
     */
    'data': Array<SessionResponse>;
}
/**
 * 
 * @export
 * @interface SignPayloadRequest
 */
export interface SignPayloadRequest {
    /**
     * Payload to sign
     * @type {string}
     * @memberof SignPayloadRequest
     */
    'payload': string;
}
/**
 * 
 * @export
 * @interface SignPayloadResponse
 */
export interface SignPayloadResponse {
    /**
     * 
     * @type {string}
     * @memberof SignPayloadResponse
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof SignPayloadResponse
     */
    'account': string;
    /**
     * 
     * @type {string}
     * @memberof SignPayloadResponse
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof SignPayloadResponse
     */
    'payload': string;
    /**
     * 
     * @type {string}
     * @memberof SignPayloadResponse
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface SignTextRequest
 */
export interface SignTextRequest {
    /**
     * Text to sign
     * @type {string}
     * @memberof SignTextRequest
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface SignTextResponse
 */
export interface SignTextResponse {
    /**
     * 
     * @type {string}
     * @memberof SignTextResponse
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof SignTextResponse
     */
    'account': string;
    /**
     * 
     * @type {string}
     * @memberof SignTextResponse
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof SignTextResponse
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof SignTextResponse
     */
    'digest': string;
    /**
     * 
     * @type {string}
     * @memberof SignTextResponse
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface SignatureRequest
 */
export interface SignatureRequest {
    /**
     * 
     * @type {string}
     * @memberof SignatureRequest
     */
    'signature': string;
    /**
     * 
     * @type {boolean}
     * @memberof SignatureRequest
     */
    'optimistic'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SortOrder = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortOrder = typeof SortOrder[keyof typeof SortOrder];


/**
 * 
 * @export
 * @interface Strategy
 */
export interface Strategy {
    /**
     * 
     * @type {string}
     * @memberof Strategy
     */
    'sponsor_schema': string;
    /**
     * 
     * @type {string}
     * @memberof Strategy
     */
    'token_contract': string | null;
    /**
     * 
     * @type {string}
     * @memberof Strategy
     */
    'token_contract_amount': string | null;
}
/**
 * 
 * @export
 * @interface SumGas
 */
export interface SumGas {
    /**
     * 
     * @type {string}
     * @memberof SumGas
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof SumGas
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof SumGas
     */
    'sumGas': number;
}
/**
 * 
 * @export
 * @interface TransactionIntentRequest
 */
export interface TransactionIntentRequest {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentRequest
     */
    'player': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentRequest
     */
    'chain_id': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentRequest
     */
    'policy'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentRequest
     */
    'external_owner_address'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIntentRequest
     */
    'optimistic': boolean;
    /**
     * 
     * @type {Array<Interaction>}
     * @memberof TransactionIntentRequest
     */
    'interactions': Array<Interaction>;
}
/**
 * 
 * @export
 * @interface TransactionIntentResponse
 */
export interface TransactionIntentResponse {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponse
     */
    'object': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponse
     */
    'created_at': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponse
     */
    'updated_at': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponse
     */
    'chain_id': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponse
     */
    'user_operation_hash': string | null;
    /**
     * 
     * @type {any}
     * @memberof TransactionIntentResponse
     */
    'user_operation'?: any;
    /**
     * 
     * @type {TransactionIntentResponsePolicy}
     * @memberof TransactionIntentResponse
     */
    'policy': TransactionIntentResponsePolicy | null;
    /**
     * 
     * @type {TransactionIntentResponsePlayer}
     * @memberof TransactionIntentResponse
     */
    'player'?: TransactionIntentResponsePlayer;
    /**
     * 
     * @type {object}
     * @memberof TransactionIntentResponse
     */
    'next_action'?: object | null;
    /**
     * 
     * @type {TransactionIntentResponseAccount}
     * @memberof TransactionIntentResponse
     */
    'account'?: TransactionIntentResponseAccount;
    /**
     * 
     * @type {Array<Interaction>}
     * @memberof TransactionIntentResponse
     */
    'interactions': Array<Interaction> | null;
    /**
     * 
     * @type {ResponseResponse}
     * @memberof TransactionIntentResponse
     */
    'response': ResponseResponse | null;
}
/**
 * 
 * @export
 * @interface TransactionIntentResponseAccount
 */
export interface TransactionIntentResponseAccount {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponseAccount
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponseAccount
     */
    'object': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponseAccount
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponseAccount
     */
    'address': string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIntentResponseAccount
     */
    'deployed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIntentResponseAccount
     */
    'custodial': boolean;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponseAccount
     */
    'chain_id': number;
    /**
     * 
     * @type {Array<PolicyResponseTransactionIntentsInner>}
     * @memberof TransactionIntentResponseAccount
     */
    'transaction_intents': Array<PolicyResponseTransactionIntentsInner>;
}
/**
 * 
 * @export
 * @interface TransactionIntentResponsePlayer
 */
export interface TransactionIntentResponsePlayer {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePlayer
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePlayer
     */
    'object': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponsePlayer
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePlayer
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePlayer
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePlayer
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePlayer
     */
    'metadata': string;
    /**
     * 
     * @type {Array<PolicyResponseTransactionIntentsInner>}
     * @memberof TransactionIntentResponsePlayer
     */
    'transaction_intents'?: Array<PolicyResponseTransactionIntentsInner>;
    /**
     * 
     * @type {Array<TransactionIntentResponseAccount>}
     * @memberof TransactionIntentResponsePlayer
     */
    'accounts'?: Array<TransactionIntentResponseAccount>;
}
/**
 * 
 * @export
 * @interface TransactionIntentResponsePolicy
 */
export interface TransactionIntentResponsePolicy {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePolicy
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePolicy
     */
    'object': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponsePolicy
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePolicy
     */
    'name': string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponsePolicy
     */
    'chain_id': number;
    /**
     * 
     * @type {any}
     * @memberof TransactionIntentResponsePolicy
     */
    'strategy': any;
    /**
     * 
     * @type {Array<PolicyResponseTransactionIntentsInner>}
     * @memberof TransactionIntentResponsePolicy
     */
    'transaction_intents'?: Array<PolicyResponseTransactionIntentsInner>;
    /**
     * 
     * @type {Array<PolicyResponsePolicyRulesInner>}
     * @memberof TransactionIntentResponsePolicy
     */
    'policy_rules'?: Array<PolicyResponsePolicyRulesInner>;
}
/**
 * 
 * @export
 * @interface TransactionIntentsResponse
 */
export interface TransactionIntentsResponse {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentsResponse
     */
    'object': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentsResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<TransactionIntentResponse>}
     * @memberof TransactionIntentsResponse
     */
    'data': Array<TransactionIntentResponse>;
}
/**
 * 
 * @export
 * @interface TransferOwnershipRequest
 */
export interface TransferOwnershipRequest {
    /**
     * The address of the new owner
     * @type {string}
     * @memberof TransferOwnershipRequest
     */
    'new_owner_address': string;
    /**
     * The policy ID
     * @type {string}
     * @memberof TransferOwnershipRequest
     */
    'policy': string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an account object.
         * @param {AccountRequest} accountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (accountRequest: AccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountRequest' is not null or undefined
            assertParamExists('createAccount', 'accountRequest', accountRequest)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing account. Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
         * @param {string} id Specifies the unique account ID.
         * @param {Array<string>} [expand] whether to expand the response or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: string, expand?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the inventory of an existing account. Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInventory: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountInventory', 'id', id)
            const localVarPath = `/v1/accounts/{id}/inventory`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of accounts for the given player. The accounts are returned sorted by creation date, with the most recently created accounts appearing first.
         * @param {string} player Specifies the unique player ID.
         * @param {Array<string>} [expand] whether to expand the response or not
         * @param {number} [limit] amount of results per query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (player: string, expand?: Array<string>, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'player' is not null or undefined
            assertParamExists('getAccounts', 'player', player)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign a given payload
         * @param {string} id Specifies the unique account ID.
         * @param {SignPayloadRequest} signPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signPayload: async (id: string, signPayloadRequest: SignPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signPayload', 'id', id)
            // verify required parameter 'signPayloadRequest' is not null or undefined
            assertParamExists('signPayload', 'signPayloadRequest', signPayloadRequest)
            const localVarPath = `/v1/accounts/{id}/sign-payload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign a given text
         * @param {string} id Specifies the unique account ID.
         * @param {SignTextRequest} signTextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signText: async (id: string, signTextRequest: SignTextRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signText', 'id', id)
            // verify required parameter 'signTextRequest' is not null or undefined
            assertParamExists('signText', 'signTextRequest', signTextRequest)
            const localVarPath = `/v1/accounts/{id}/sign-text`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signTextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request the ownership transfer of an account to a given address.
         * @param {string} id Specifies the unique account ID.
         * @param {TransferOwnershipRequest} transferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership: async (id: string, transferOwnershipRequest: TransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transferOwnership', 'id', id)
            // verify required parameter 'transferOwnershipRequest' is not null or undefined
            assertParamExists('transferOwnership', 'transferOwnershipRequest', transferOwnershipRequest)
            const localVarPath = `/v1/accounts/{id}/transfer-ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an account object.
         * @param {AccountRequest} accountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(accountRequest: AccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(accountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing account. Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
         * @param {string} id Specifies the unique account ID.
         * @param {Array<string>} [expand] whether to expand the response or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: string, expand?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the inventory of an existing account. Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountInventory(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountInventory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of accounts for the given player. The accounts are returned sorted by creation date, with the most recently created accounts appearing first.
         * @param {string} player Specifies the unique player ID.
         * @param {Array<string>} [expand] whether to expand the response or not
         * @param {number} [limit] amount of results per query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(player: string, expand?: Array<string>, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(player, expand, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sign a given payload
         * @param {string} id Specifies the unique account ID.
         * @param {SignPayloadRequest} signPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signPayload(id: string, signPayloadRequest: SignPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignPayloadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signPayload(id, signPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sign a given text
         * @param {string} id Specifies the unique account ID.
         * @param {SignTextRequest} signTextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signText(id: string, signTextRequest: SignTextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignTextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signText(id, signTextRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Request the ownership transfer of an account to a given address.
         * @param {string} id Specifies the unique account ID.
         * @param {TransferOwnershipRequest} transferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferOwnership(id: string, transferOwnershipRequest: TransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferOwnership(id, transferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Creates an account object.
         * @param {AccountRequest} accountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(accountRequest: AccountRequest, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.createAccount(accountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing account. Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
         * @param {string} id Specifies the unique account ID.
         * @param {Array<string>} [expand] whether to expand the response or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id: string, expand?: Array<string>, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.getAccount(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the inventory of an existing account. Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInventory(id: string, options?: any): AxiosPromise<InventoryResponse> {
            return localVarFp.getAccountInventory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of accounts for the given player. The accounts are returned sorted by creation date, with the most recently created accounts appearing first.
         * @param {string} player Specifies the unique player ID.
         * @param {Array<string>} [expand] whether to expand the response or not
         * @param {number} [limit] amount of results per query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(player: string, expand?: Array<string>, limit?: number, options?: any): AxiosPromise<AccountsResponse> {
            return localVarFp.getAccounts(player, expand, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Sign a given payload
         * @param {string} id Specifies the unique account ID.
         * @param {SignPayloadRequest} signPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signPayload(id: string, signPayloadRequest: SignPayloadRequest, options?: any): AxiosPromise<SignPayloadResponse> {
            return localVarFp.signPayload(id, signPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sign a given text
         * @param {string} id Specifies the unique account ID.
         * @param {SignTextRequest} signTextRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signText(id: string, signTextRequest: SignTextRequest, options?: any): AxiosPromise<SignTextResponse> {
            return localVarFp.signText(id, signTextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Request the ownership transfer of an account to a given address.
         * @param {string} id Specifies the unique account ID.
         * @param {TransferOwnershipRequest} transferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(id: string, transferOwnershipRequest: TransferOwnershipRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.transferOwnership(id, transferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Creates an account object.
     * @param {AccountRequest} accountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(accountRequest: AccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(accountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing account. Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
     * @param {string} id Specifies the unique account ID.
     * @param {Array<string>} [expand] whether to expand the response or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(id: string, expand?: Array<string>, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the inventory of an existing account. Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
     * @param {string} id Specifies the unique account ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountInventory(id: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountInventory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of accounts for the given player. The accounts are returned sorted by creation date, with the most recently created accounts appearing first.
     * @param {string} player Specifies the unique player ID.
     * @param {Array<string>} [expand] whether to expand the response or not
     * @param {number} [limit] amount of results per query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(player: string, expand?: Array<string>, limit?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccounts(player, expand, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sign a given payload
     * @param {string} id Specifies the unique account ID.
     * @param {SignPayloadRequest} signPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public signPayload(id: string, signPayloadRequest: SignPayloadRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).signPayload(id, signPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sign a given text
     * @param {string} id Specifies the unique account ID.
     * @param {SignTextRequest} signTextRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public signText(id: string, signTextRequest: SignTextRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).signText(id, signTextRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request the ownership transfer of an account to a given address.
     * @param {string} id Specifies the unique account ID.
     * @param {TransferOwnershipRequest} transferOwnershipRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public transferOwnership(id: string, transferOwnershipRequest: TransferOwnershipRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).transferOwnership(id, transferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractsApi - axios parameter creator
 * @export
 */
export const ContractsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a contract object.
         * @param {ContractRequest} contractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract: async (contractRequest: ContractRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractRequest' is not null or undefined
            assertParamExists('createContract', 'contractRequest', contractRequest)
            const localVarPath = `/v1/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a contract object.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContract: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteContract', 'id', id)
            const localVarPath = `/v1/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing contract. Supply the unique contract ID from either a contract creation request or the contract list, and Openfort will return the corresponding contract information.
         * @param {string} id Specifies the unique contract ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContract: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContract', 'id', id)
            const localVarPath = `/v1/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your contracts. The contracts are returned sorted by creation date, with the most recently created contracts appearing first.
         * @param {number} [limit] amount of results per query
         * @param {SortOrder} [order] 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContracts: async (limit?: number, order?: SortOrder, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsApi - functional programming interface
 * @export
 */
export const ContractsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a contract object.
         * @param {ContractRequest} contractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContract(contractRequest: ContractRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContract(contractRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a contract object.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContract(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContract(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing contract. Supply the unique contract ID from either a contract creation request or the contract list, and Openfort will return the corresponding contract information.
         * @param {string} id Specifies the unique contract ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContract(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContract(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of your contracts. The contracts are returned sorted by creation date, with the most recently created contracts appearing first.
         * @param {number} [limit] amount of results per query
         * @param {SortOrder} [order] 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContracts(limit?: number, order?: SortOrder, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContracts(limit, order, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractsApi - factory interface
 * @export
 */
export const ContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractsApiFp(configuration)
    return {
        /**
         * Creates a contract object.
         * @param {ContractRequest} contractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract(contractRequest: ContractRequest, options?: any): AxiosPromise<ContractResponse> {
            return localVarFp.createContract(contractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a contract object.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContract(id: string, options?: any): AxiosPromise<ContractDeleteResponse> {
            return localVarFp.deleteContract(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing contract. Supply the unique contract ID from either a contract creation request or the contract list, and Openfort will return the corresponding contract information.
         * @param {string} id Specifies the unique contract ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContract(id: string, options?: any): AxiosPromise<ContractResponse> {
            return localVarFp.getContract(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your contracts. The contracts are returned sorted by creation date, with the most recently created contracts appearing first.
         * @param {number} [limit] amount of results per query
         * @param {SortOrder} [order] 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContracts(limit?: number, order?: SortOrder, skip?: number, options?: any): AxiosPromise<ContractsResponse> {
            return localVarFp.getContracts(limit, order, skip, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractsApi - object-oriented interface
 * @export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI {
    /**
     * Creates a contract object.
     * @param {ContractRequest} contractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public createContract(contractRequest: ContractRequest, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).createContract(contractRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a contract object.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public deleteContract(id: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).deleteContract(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing contract. Supply the unique contract ID from either a contract creation request or the contract list, and Openfort will return the corresponding contract information.
     * @param {string} id Specifies the unique contract ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getContract(id: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getContract(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your contracts. The contracts are returned sorted by creation date, with the most recently created contracts appearing first.
     * @param {number} [limit] amount of results per query
     * @param {SortOrder} [order] 
     * @param {number} [skip] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getContracts(limit?: number, order?: SortOrder, skip?: number, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getContracts(limit, order, skip, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayersApi - axios parameter creator
 * @export
 */
export const PlayersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a player object.
         * @param {CreatePlayerRequest} createPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayer: async (createPlayerRequest: CreatePlayerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPlayerRequest' is not null or undefined
            assertParamExists('createPlayer', 'createPlayerRequest', createPlayerRequest)
            const localVarPath = `/v1/players`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPlayerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an account object for an existing player.
         * @param {string} id Specifies the unique player ID.
         * @param {AccountPlayerRequest} accountPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayerAccount: async (id: string, accountPlayerRequest: AccountPlayerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPlayerAccount', 'id', id)
            // verify required parameter 'accountPlayerRequest' is not null or undefined
            assertParamExists('createPlayerAccount', 'accountPlayerRequest', accountPlayerRequest)
            const localVarPath = `/v1/players/{id}/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountPlayerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a session object for the given player.
         * @param {string} id Specifies the unique player ID.
         * @param {CreateSessionPlayerRequest} createSessionPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayerSession: async (id: string, createSessionPlayerRequest: CreateSessionPlayerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPlayerSession', 'id', id)
            // verify required parameter 'createSessionPlayerRequest' is not null or undefined
            assertParamExists('createPlayerSession', 'createSessionPlayerRequest', createSessionPlayerRequest)
            const localVarPath = `/v1/players/{id}/sessions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSessionPlayerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your players for the query. The players are returned sorted by creation date, with the most recently created players appearing first.
         * @param {string} id Specifies the unique player ID.
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer: async (id: string, expand?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlayer', 'id', id)
            const localVarPath = `/v1/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your accounts for the given player. The accounts are returned sorted by creation date, with the most recently created accounts appearing first.
         * @param {string} id Specifies the unique player ID.
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerAccounts: async (id: string, expand?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlayerAccounts', 'id', id)
            const localVarPath = `/v1/players/{id}/accounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the inventory of an existing player. Supply the unique player ID from either a player creation request or the player list, and Openfort will return the corresponding player information.
         * @param {string} id Specifies the unique player ID.
         * @param {number} chainId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerInventory: async (id: string, chainId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlayerInventory', 'id', id)
            // verify required parameter 'chainId' is not null or undefined
            assertParamExists('getPlayerInventory', 'chainId', chainId)
            const localVarPath = `/v1/players/{id}/inventory`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (chainId !== undefined) {
                localVarQueryParameter['chain_id'] = chainId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your players. The players are returned sorted by creation date, with the most recently created players appearing first.
         * @param {Array<string>} [expand] 
         * @param {number} [limit] 
         * @param {string} [filter] 
         * @param {SortOrder} [order] 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayers: async (expand?: Array<string>, limit?: number, filter?: string, order?: SortOrder, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/players`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a session object for the given player.
         * @param {string} id Specifies the unique player ID.
         * @param {RevokeSessionPlayerRequest} revokeSessionPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePlayerSession: async (id: string, revokeSessionPlayerRequest: RevokeSessionPlayerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('revokePlayerSession', 'id', id)
            // verify required parameter 'revokeSessionPlayerRequest' is not null or undefined
            assertParamExists('revokePlayerSession', 'revokeSessionPlayerRequest', revokeSessionPlayerRequest)
            const localVarPath = `/v1/players/{id}/sessions/revoke`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revokeSessionPlayerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfer ownership of an account to an address.
         * @param {string} id Specifies the unique player ID.
         * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferAccountOwnership: async (id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transferAccountOwnership', 'id', id)
            // verify required parameter 'playerTransferOwnershipRequest' is not null or undefined
            assertParamExists('transferAccountOwnership', 'playerTransferOwnershipRequest', playerTransferOwnershipRequest)
            const localVarPath = `/v1/players/{id}/transfer-ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerTransferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a player object.
         * @param {string} id Specifies the unique player ID.
         * @param {PlayerRequest} playerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer: async (id: string, playerRequest: PlayerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePlayer', 'id', id)
            // verify required parameter 'playerRequest' is not null or undefined
            assertParamExists('updatePlayer', 'playerRequest', playerRequest)
            const localVarPath = `/v1/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayersApi - functional programming interface
 * @export
 */
export const PlayersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayersApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a player object.
         * @param {CreatePlayerRequest} createPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlayer(createPlayerRequest: CreatePlayerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlayer(createPlayerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates an account object for an existing player.
         * @param {string} id Specifies the unique player ID.
         * @param {AccountPlayerRequest} accountPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlayerAccount(id: string, accountPlayerRequest: AccountPlayerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlayerAccount(id, accountPlayerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a session object for the given player.
         * @param {string} id Specifies the unique player ID.
         * @param {CreateSessionPlayerRequest} createSessionPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlayerSession(id: string, createSessionPlayerRequest: CreateSessionPlayerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlayerSession(id, createSessionPlayerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of your players for the query. The players are returned sorted by creation date, with the most recently created players appearing first.
         * @param {string} id Specifies the unique player ID.
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayer(id: string, expand?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayer(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of your accounts for the given player. The accounts are returned sorted by creation date, with the most recently created accounts appearing first.
         * @param {string} id Specifies the unique player ID.
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerAccounts(id: string, expand?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerAccounts(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the inventory of an existing player. Supply the unique player ID from either a player creation request or the player list, and Openfort will return the corresponding player information.
         * @param {string} id Specifies the unique player ID.
         * @param {number} chainId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerInventory(id: string, chainId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerInventory(id, chainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of your players. The players are returned sorted by creation date, with the most recently created players appearing first.
         * @param {Array<string>} [expand] 
         * @param {number} [limit] 
         * @param {string} [filter] 
         * @param {SortOrder} [order] 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayers(expand?: Array<string>, limit?: number, filter?: string, order?: SortOrder, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayers(expand, limit, filter, order, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a session object for the given player.
         * @param {string} id Specifies the unique player ID.
         * @param {RevokeSessionPlayerRequest} revokeSessionPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokePlayerSession(id: string, revokeSessionPlayerRequest: RevokeSessionPlayerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokePlayerSession(id, revokeSessionPlayerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Transfer ownership of an account to an address.
         * @param {string} id Specifies the unique player ID.
         * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferAccountOwnership(id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferAccountOwnership(id, playerTransferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a player object.
         * @param {string} id Specifies the unique player ID.
         * @param {PlayerRequest} playerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlayer(id: string, playerRequest: PlayerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlayer(id, playerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayersApi - factory interface
 * @export
 */
export const PlayersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayersApiFp(configuration)
    return {
        /**
         * Creates a player object.
         * @param {CreatePlayerRequest} createPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayer(createPlayerRequest: CreatePlayerRequest, options?: any): AxiosPromise<PlayerResponse> {
            return localVarFp.createPlayer(createPlayerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an account object for an existing player.
         * @param {string} id Specifies the unique player ID.
         * @param {AccountPlayerRequest} accountPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayerAccount(id: string, accountPlayerRequest: AccountPlayerRequest, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.createPlayerAccount(id, accountPlayerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a session object for the given player.
         * @param {string} id Specifies the unique player ID.
         * @param {CreateSessionPlayerRequest} createSessionPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayerSession(id: string, createSessionPlayerRequest: CreateSessionPlayerRequest, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.createPlayerSession(id, createSessionPlayerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your players for the query. The players are returned sorted by creation date, with the most recently created players appearing first.
         * @param {string} id Specifies the unique player ID.
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer(id: string, expand?: Array<string>, options?: any): AxiosPromise<PlayerResponse> {
            return localVarFp.getPlayer(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your accounts for the given player. The accounts are returned sorted by creation date, with the most recently created accounts appearing first.
         * @param {string} id Specifies the unique player ID.
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerAccounts(id: string, expand?: Array<string>, options?: any): AxiosPromise<AccountsResponse> {
            return localVarFp.getPlayerAccounts(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the inventory of an existing player. Supply the unique player ID from either a player creation request or the player list, and Openfort will return the corresponding player information.
         * @param {string} id Specifies the unique player ID.
         * @param {number} chainId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerInventory(id: string, chainId: number, options?: any): AxiosPromise<InventoryResponse> {
            return localVarFp.getPlayerInventory(id, chainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your players. The players are returned sorted by creation date, with the most recently created players appearing first.
         * @param {Array<string>} [expand] 
         * @param {number} [limit] 
         * @param {string} [filter] 
         * @param {SortOrder} [order] 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayers(expand?: Array<string>, limit?: number, filter?: string, order?: SortOrder, skip?: number, options?: any): AxiosPromise<PlayersResponse> {
            return localVarFp.getPlayers(expand, limit, filter, order, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a session object for the given player.
         * @param {string} id Specifies the unique player ID.
         * @param {RevokeSessionPlayerRequest} revokeSessionPlayerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePlayerSession(id: string, revokeSessionPlayerRequest: RevokeSessionPlayerRequest, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.revokePlayerSession(id, revokeSessionPlayerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Transfer ownership of an account to an address.
         * @param {string} id Specifies the unique player ID.
         * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferAccountOwnership(id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.transferAccountOwnership(id, playerTransferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a player object.
         * @param {string} id Specifies the unique player ID.
         * @param {PlayerRequest} playerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer(id: string, playerRequest: PlayerRequest, options?: any): AxiosPromise<PlayerResponse> {
            return localVarFp.updatePlayer(id, playerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayersApi - object-oriented interface
 * @export
 * @class PlayersApi
 * @extends {BaseAPI}
 */
export class PlayersApi extends BaseAPI {
    /**
     * Creates a player object.
     * @param {CreatePlayerRequest} createPlayerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public createPlayer(createPlayerRequest: CreatePlayerRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).createPlayer(createPlayerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an account object for an existing player.
     * @param {string} id Specifies the unique player ID.
     * @param {AccountPlayerRequest} accountPlayerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public createPlayerAccount(id: string, accountPlayerRequest: AccountPlayerRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).createPlayerAccount(id, accountPlayerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a session object for the given player.
     * @param {string} id Specifies the unique player ID.
     * @param {CreateSessionPlayerRequest} createSessionPlayerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public createPlayerSession(id: string, createSessionPlayerRequest: CreateSessionPlayerRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).createPlayerSession(id, createSessionPlayerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your players for the query. The players are returned sorted by creation date, with the most recently created players appearing first.
     * @param {string} id Specifies the unique player ID.
     * @param {Array<string>} [expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public getPlayer(id: string, expand?: Array<string>, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).getPlayer(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your accounts for the given player. The accounts are returned sorted by creation date, with the most recently created accounts appearing first.
     * @param {string} id Specifies the unique player ID.
     * @param {Array<string>} [expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public getPlayerAccounts(id: string, expand?: Array<string>, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).getPlayerAccounts(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the inventory of an existing player. Supply the unique player ID from either a player creation request or the player list, and Openfort will return the corresponding player information.
     * @param {string} id Specifies the unique player ID.
     * @param {number} chainId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public getPlayerInventory(id: string, chainId: number, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).getPlayerInventory(id, chainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your players. The players are returned sorted by creation date, with the most recently created players appearing first.
     * @param {Array<string>} [expand] 
     * @param {number} [limit] 
     * @param {string} [filter] 
     * @param {SortOrder} [order] 
     * @param {number} [skip] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public getPlayers(expand?: Array<string>, limit?: number, filter?: string, order?: SortOrder, skip?: number, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).getPlayers(expand, limit, filter, order, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a session object for the given player.
     * @param {string} id Specifies the unique player ID.
     * @param {RevokeSessionPlayerRequest} revokeSessionPlayerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public revokePlayerSession(id: string, revokeSessionPlayerRequest: RevokeSessionPlayerRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).revokePlayerSession(id, revokeSessionPlayerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transfer ownership of an account to an address.
     * @param {string} id Specifies the unique player ID.
     * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public transferAccountOwnership(id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).transferAccountOwnership(id, playerTransferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a player object.
     * @param {string} id Specifies the unique player ID.
     * @param {PlayerRequest} playerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public updatePlayer(id: string, playerRequest: PlayerRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).updatePlayer(id, playerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a policy object.
         * @param {PolicyRequest} policyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy: async (policyRequest: PolicyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyRequest' is not null or undefined
            assertParamExists('createPolicy', 'policyRequest', policyRequest)
            const localVarPath = `/v1/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PolicyAllowFunctionRequest} policyAllowFunctionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyAllowFunction: async (id: string, policyAllowFunctionRequest: PolicyAllowFunctionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPolicyAllowFunction', 'id', id)
            // verify required parameter 'policyAllowFunctionRequest' is not null or undefined
            assertParamExists('createPolicyAllowFunction', 'policyAllowFunctionRequest', policyAllowFunctionRequest)
            const localVarPath = `/v1/policies/{id}/policy_rules`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyAllowFunctionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a policy object.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePolicy', 'id', id)
            const localVarPath = `/v1/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all policy objects for a given project.
         * @param {number} [limit] 
         * @param {Array<string>} [expand] 
         * @param {number} [skip] 
         * @param {SortOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies: async (limit?: number, expand?: Array<string>, skip?: number, order?: SortOrder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a policy object for a given project.
         * @param {string} id 
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy: async (id: string, expand?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPolicy', 'id', id)
            const localVarPath = `/v1/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyAllowFunctions: async (id: string, expand?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPolicyAllowFunctions', 'id', id)
            const localVarPath = `/v1/policies/{id}/policy_rules`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyDailyGasUsage: async (id: string, from?: string, to?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPolicyDailyGasUsage', 'id', id)
            const localVarPath = `/v1/policies/{id}/daily_gas_usage`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyTotalGasUsage: async (id: string, from?: string, to?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPolicyTotalGasUsage', 'id', id)
            const localVarPath = `/v1/policies/{id}/gas_usage`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a policy object.
         * @param {string} id 
         * @param {PolicyUpdateRequest} policyUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy: async (id: string, policyUpdateRequest: PolicyUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePolicy', 'id', id)
            // verify required parameter 'policyUpdateRequest' is not null or undefined
            assertParamExists('updatePolicy', 'policyUpdateRequest', policyUpdateRequest)
            const localVarPath = `/v1/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policy 
         * @param {string} policyRule 
         * @param {PolicyRuleUpdateRequest} policyRuleUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyAllowFunction: async (policy: string, policyRule: string, policyRuleUpdateRequest: PolicyRuleUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policy' is not null or undefined
            assertParamExists('updatePolicyAllowFunction', 'policy', policy)
            // verify required parameter 'policyRule' is not null or undefined
            assertParamExists('updatePolicyAllowFunction', 'policyRule', policyRule)
            // verify required parameter 'policyRuleUpdateRequest' is not null or undefined
            assertParamExists('updatePolicyAllowFunction', 'policyRuleUpdateRequest', policyRuleUpdateRequest)
            const localVarPath = `/v1/policies/{policy}/policy_rules/{policy_rule}`
                .replace(`{${"policy"}}`, encodeURIComponent(String(policy)))
                .replace(`{${"policy_rule"}}`, encodeURIComponent(String(policyRule)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyRuleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a policy object.
         * @param {PolicyRequest} policyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicy(policyRequest: PolicyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicy(policyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {PolicyAllowFunctionRequest} policyAllowFunctionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicyAllowFunction(id: string, policyAllowFunctionRequest: PolicyAllowFunctionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicyAllowFunction(id, policyAllowFunctionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a policy object.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all policy objects for a given project.
         * @param {number} [limit] 
         * @param {Array<string>} [expand] 
         * @param {number} [skip] 
         * @param {SortOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicies(limit?: number, expand?: Array<string>, skip?: number, order?: SortOrder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoliciesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicies(limit, expand, skip, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a policy object for a given project.
         * @param {string} id 
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicy(id: string, expand?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicy(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyAllowFunctions(id: string, expand?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyAllowFunctions(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyDailyGasUsage(id: string, from?: string, to?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gas>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyDailyGasUsage(id, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyTotalGasUsage(id: string, from?: string, to?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SumGas>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyTotalGasUsage(id, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a policy object.
         * @param {string} id 
         * @param {PolicyUpdateRequest} policyUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicy(id: string, policyUpdateRequest: PolicyUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicy(id, policyUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} policy 
         * @param {string} policyRule 
         * @param {PolicyRuleUpdateRequest} policyRuleUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicyAllowFunction(policy: string, policyRule: string, policyRuleUpdateRequest: PolicyRuleUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicyAllowFunction(policy, policyRule, policyRuleUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * Creates a policy object.
         * @param {PolicyRequest} policyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy(policyRequest: PolicyRequest, options?: any): AxiosPromise<PolicyResponse> {
            return localVarFp.createPolicy(policyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PolicyAllowFunctionRequest} policyAllowFunctionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyAllowFunction(id: string, policyAllowFunctionRequest: PolicyAllowFunctionRequest, options?: any): AxiosPromise<PolicyRuleResponse> {
            return localVarFp.createPolicyAllowFunction(id, policyAllowFunctionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a policy object.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(id: string, options?: any): AxiosPromise<PolicyDeleteResponse> {
            return localVarFp.deletePolicy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all policy objects for a given project.
         * @param {number} [limit] 
         * @param {Array<string>} [expand] 
         * @param {number} [skip] 
         * @param {SortOrder} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies(limit?: number, expand?: Array<string>, skip?: number, order?: SortOrder, options?: any): AxiosPromise<PoliciesResponse> {
            return localVarFp.getPolicies(limit, expand, skip, order, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a policy object for a given project.
         * @param {string} id 
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(id: string, expand?: Array<string>, options?: any): AxiosPromise<PolicyResponse> {
            return localVarFp.getPolicy(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyAllowFunctions(id: string, expand?: Array<string>, options?: any): AxiosPromise<PolicyRulesResponse> {
            return localVarFp.getPolicyAllowFunctions(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyDailyGasUsage(id: string, from?: string, to?: string, options?: any): AxiosPromise<Gas> {
            return localVarFp.getPolicyDailyGasUsage(id, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyTotalGasUsage(id: string, from?: string, to?: string, options?: any): AxiosPromise<SumGas> {
            return localVarFp.getPolicyTotalGasUsage(id, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a policy object.
         * @param {string} id 
         * @param {PolicyUpdateRequest} policyUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(id: string, policyUpdateRequest: PolicyUpdateRequest, options?: any): AxiosPromise<PolicyResponse> {
            return localVarFp.updatePolicy(id, policyUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policy 
         * @param {string} policyRule 
         * @param {PolicyRuleUpdateRequest} policyRuleUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyAllowFunction(policy: string, policyRule: string, policyRuleUpdateRequest: PolicyRuleUpdateRequest, options?: any): AxiosPromise<PolicyRuleResponse> {
            return localVarFp.updatePolicyAllowFunction(policy, policyRule, policyRuleUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * Creates a policy object.
     * @param {PolicyRequest} policyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createPolicy(policyRequest: PolicyRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createPolicy(policyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PolicyAllowFunctionRequest} policyAllowFunctionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createPolicyAllowFunction(id: string, policyAllowFunctionRequest: PolicyAllowFunctionRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createPolicyAllowFunction(id, policyAllowFunctionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a policy object.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public deletePolicy(id: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).deletePolicy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all policy objects for a given project.
     * @param {number} [limit] 
     * @param {Array<string>} [expand] 
     * @param {number} [skip] 
     * @param {SortOrder} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicies(limit?: number, expand?: Array<string>, skip?: number, order?: SortOrder, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicies(limit, expand, skip, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a policy object for a given project.
     * @param {string} id 
     * @param {Array<string>} [expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicy(id: string, expand?: Array<string>, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicy(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {Array<string>} [expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicyAllowFunctions(id: string, expand?: Array<string>, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicyAllowFunctions(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicyDailyGasUsage(id: string, from?: string, to?: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicyDailyGasUsage(id, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicyTotalGasUsage(id: string, from?: string, to?: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicyTotalGasUsage(id, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a policy object.
     * @param {string} id 
     * @param {PolicyUpdateRequest} policyUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public updatePolicy(id: string, policyUpdateRequest: PolicyUpdateRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updatePolicy(id, policyUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policy 
     * @param {string} policyRule 
     * @param {PolicyRuleUpdateRequest} policyRuleUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public updatePolicyAllowFunction(policy: string, policyRule: string, policyRuleUpdateRequest: PolicyRuleUpdateRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updatePolicyAllowFunction(policy, policyRule, policyRuleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PolicyRulesApi - axios parameter creator
 * @export
 */
export const PolicyRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an allow function object.
         * @param {PolicyRuleRequest} policyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyRules: async (policyRuleRequest: PolicyRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyRuleRequest' is not null or undefined
            assertParamExists('createPolicyRules', 'policyRuleRequest', policyRuleRequest)
            const localVarPath = `/v1/policy_rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an polciy rule (allow_functions) object.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicyRules: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePolicyRules', 'id', id)
            const localVarPath = `/v1/policy_rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your allow functions for the given policy. The allow functions are returned sorted by creation date, with the most recently created allow functions appearing first.
         * @param {Array<string>} [expand] 
         * @param {string} [policy] Specifies the unique policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyRules: async (expand?: Array<string>, policy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/policy_rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (policy !== undefined) {
                localVarQueryParameter['policy'] = policy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an allow functions object.
         * @param {string} id Specifies the unique allow function ID.
         * @param {PolicyRuleRequest} policyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyRules: async (id: string, policyRuleRequest: PolicyRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePolicyRules', 'id', id)
            // verify required parameter 'policyRuleRequest' is not null or undefined
            assertParamExists('updatePolicyRules', 'policyRuleRequest', policyRuleRequest)
            const localVarPath = `/v1/policy_rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolicyRulesApi - functional programming interface
 * @export
 */
export const PolicyRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PolicyRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an allow function object.
         * @param {PolicyRuleRequest} policyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicyRules(policyRuleRequest: PolicyRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicyRules(policyRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes an polciy rule (allow_functions) object.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicyRules(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicyRules(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of your allow functions for the given policy. The allow functions are returned sorted by creation date, with the most recently created allow functions appearing first.
         * @param {Array<string>} [expand] 
         * @param {string} [policy] Specifies the unique policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyRules(expand?: Array<string>, policy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyRules(expand, policy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an allow functions object.
         * @param {string} id Specifies the unique allow function ID.
         * @param {PolicyRuleRequest} policyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicyRules(id: string, policyRuleRequest: PolicyRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicyRules(id, policyRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PolicyRulesApi - factory interface
 * @export
 */
export const PolicyRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PolicyRulesApiFp(configuration)
    return {
        /**
         * Creates an allow function object.
         * @param {PolicyRuleRequest} policyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyRules(policyRuleRequest: PolicyRuleRequest, options?: any): AxiosPromise<PolicyRuleResponse> {
            return localVarFp.createPolicyRules(policyRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an polciy rule (allow_functions) object.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicyRules(id: string, options?: any): AxiosPromise<PolicyRuleDeleteResponse> {
            return localVarFp.deletePolicyRules(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your allow functions for the given policy. The allow functions are returned sorted by creation date, with the most recently created allow functions appearing first.
         * @param {Array<string>} [expand] 
         * @param {string} [policy] Specifies the unique policy ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyRules(expand?: Array<string>, policy?: string, options?: any): AxiosPromise<PolicyRulesResponse> {
            return localVarFp.getPolicyRules(expand, policy, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an allow functions object.
         * @param {string} id Specifies the unique allow function ID.
         * @param {PolicyRuleRequest} policyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyRules(id: string, policyRuleRequest: PolicyRuleRequest, options?: any): AxiosPromise<PolicyRuleResponse> {
            return localVarFp.updatePolicyRules(id, policyRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PolicyRulesApi - object-oriented interface
 * @export
 * @class PolicyRulesApi
 * @extends {BaseAPI}
 */
export class PolicyRulesApi extends BaseAPI {
    /**
     * Creates an allow function object.
     * @param {PolicyRuleRequest} policyRuleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyRulesApi
     */
    public createPolicyRules(policyRuleRequest: PolicyRuleRequest, options?: AxiosRequestConfig) {
        return PolicyRulesApiFp(this.configuration).createPolicyRules(policyRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an polciy rule (allow_functions) object.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyRulesApi
     */
    public deletePolicyRules(id: string, options?: AxiosRequestConfig) {
        return PolicyRulesApiFp(this.configuration).deletePolicyRules(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your allow functions for the given policy. The allow functions are returned sorted by creation date, with the most recently created allow functions appearing first.
     * @param {Array<string>} [expand] 
     * @param {string} [policy] Specifies the unique policy ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyRulesApi
     */
    public getPolicyRules(expand?: Array<string>, policy?: string, options?: AxiosRequestConfig) {
        return PolicyRulesApiFp(this.configuration).getPolicyRules(expand, policy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an allow functions object.
     * @param {string} id Specifies the unique allow function ID.
     * @param {PolicyRuleRequest} policyRuleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyRulesApi
     */
    public updatePolicyRules(id: string, policyRuleRequest: PolicyRuleRequest, options?: AxiosRequestConfig) {
        return PolicyRulesApiFp(this.configuration).updatePolicyRules(id, policyRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a project object.
         * @param {ProjectRequest} projectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (projectRequest: ProjectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectRequest' is not null or undefined
            assertParamExists('createProject', 'projectRequest', projectRequest)
            const localVarPath = `/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProject', 'id', id)
            const localVarPath = `/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a project object.
         * @param {string} id 
         * @param {ProjectRequest} projectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (id: string, projectRequest: ProjectRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProject', 'id', id)
            // verify required parameter 'projectRequest' is not null or undefined
            assertParamExists('updateProject', 'projectRequest', projectRequest)
            const localVarPath = `/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a project object.
         * @param {ProjectRequest} projectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(projectRequest: ProjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(projectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjects(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjects(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a project object.
         * @param {string} id 
         * @param {ProjectRequest} projectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(id: string, projectRequest: ProjectRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(id, projectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Creates a project object.
         * @param {ProjectRequest} projectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(projectRequest: ProjectRequest, options?: any): AxiosPromise<ProjectResponse> {
            return localVarFp.createProject(projectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(id: string, options?: any): AxiosPromise<ProjectResponse> {
            return localVarFp.getProject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects(options?: any): AxiosPromise<ProjectsResponse> {
            return localVarFp.getProjects(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a project object.
         * @param {string} id 
         * @param {ProjectRequest} projectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(id: string, projectRequest: ProjectRequest, options?: any): AxiosPromise<ProjectResponse> {
            return localVarFp.updateProject(id, projectRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Creates a project object.
     * @param {ProjectRequest} projectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProject(projectRequest: ProjectRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProject(projectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(id: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProject(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjects(options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a project object.
     * @param {string} id 
     * @param {ProjectRequest} projectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProject(id: string, projectRequest: ProjectRequest, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).updateProject(id, projectRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates the session for the account.
         * @param {CreateSessionRequest} createSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession: async (createSessionRequest: CreateSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSessionRequest' is not null or undefined
            assertParamExists('createSession', 'createSessionRequest', createSessionRequest)
            const localVarPath = `/v1/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your players. The players are returned sorted by creation date, with the most recently created players appearing first.
         * @param {string} player 
         * @param {Array<string>} [expand] 
         * @param {number} [limit] 
         * @param {string} [filter] 
         * @param {string} [order] 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerSessions: async (player: string, expand?: Array<string>, limit?: number, filter?: string, order?: string, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'player' is not null or undefined
            assertParamExists('getPlayerSessions', 'player', player)
            const localVarPath = `/v1/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes the session for the account.
         * @param {RevokeSessionRequest} revokeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeSession: async (revokeSessionRequest: RevokeSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'revokeSessionRequest' is not null or undefined
            assertParamExists('revokeSession', 'revokeSessionRequest', revokeSessionRequest)
            const localVarPath = `/v1/sessions/revoke`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revokeSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirms the creation of a session with an external owner.
         * @param {string} id 
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signatureSession: async (id: string, signatureRequest: SignatureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signatureSession', 'id', id)
            // verify required parameter 'signatureRequest' is not null or undefined
            assertParamExists('signatureSession', 'signatureRequest', signatureRequest)
            const localVarPath = `/v1/sessions/{id}/signature`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates the session for the account.
         * @param {CreateSessionRequest} createSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSession(createSessionRequest: CreateSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(createSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of your players. The players are returned sorted by creation date, with the most recently created players appearing first.
         * @param {string} player 
         * @param {Array<string>} [expand] 
         * @param {number} [limit] 
         * @param {string} [filter] 
         * @param {string} [order] 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerSessions(player: string, expand?: Array<string>, limit?: number, filter?: string, order?: string, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerSessions(player, expand, limit, filter, order, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Revokes the session for the account.
         * @param {RevokeSessionRequest} revokeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeSession(revokeSessionRequest: RevokeSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeSession(revokeSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Confirms the creation of a session with an external owner.
         * @param {string} id 
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signatureSession(id: string, signatureRequest: SignatureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signatureSession(id, signatureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * Creates the session for the account.
         * @param {CreateSessionRequest} createSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(createSessionRequest: CreateSessionRequest, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.createSession(createSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your players. The players are returned sorted by creation date, with the most recently created players appearing first.
         * @param {string} player 
         * @param {Array<string>} [expand] 
         * @param {number} [limit] 
         * @param {string} [filter] 
         * @param {string} [order] 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerSessions(player: string, expand?: Array<string>, limit?: number, filter?: string, order?: string, skip?: number, options?: any): AxiosPromise<SessionsResponse> {
            return localVarFp.getPlayerSessions(player, expand, limit, filter, order, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Revokes the session for the account.
         * @param {RevokeSessionRequest} revokeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeSession(revokeSessionRequest: RevokeSessionRequest, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.revokeSession(revokeSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirms the creation of a session with an external owner.
         * @param {string} id 
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signatureSession(id: string, signatureRequest: SignatureRequest, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.signatureSession(id, signatureRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * Creates the session for the account.
     * @param {CreateSessionRequest} createSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public createSession(createSessionRequest: CreateSessionRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).createSession(createSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your players. The players are returned sorted by creation date, with the most recently created players appearing first.
     * @param {string} player 
     * @param {Array<string>} [expand] 
     * @param {number} [limit] 
     * @param {string} [filter] 
     * @param {string} [order] 
     * @param {number} [skip] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getPlayerSessions(player: string, expand?: Array<string>, limit?: number, filter?: string, order?: string, skip?: number, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getPlayerSessions(player, expand, limit, filter, order, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revokes the session for the account.
     * @param {RevokeSessionRequest} revokeSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public revokeSession(revokeSessionRequest: RevokeSessionRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).revokeSession(revokeSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirms the creation of a session with an external owner.
     * @param {string} id 
     * @param {SignatureRequest} signatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public signatureSession(id: string, signatureRequest: SignatureRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).signatureSession(id, signatureRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionIntentsApi - axios parameter creator
 * @export
 */
export const TransactionIntentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a transaction intent object.
         * @param {TransactionIntentRequest} transactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionIntent: async (transactionIntentRequest: TransactionIntentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionIntentRequest' is not null or undefined
            assertParamExists('createTransactionIntent', 'transactionIntentRequest', transactionIntentRequest)
            const localVarPath = `/v1/transaction_intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionIntentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a transaction intent object.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionIntent: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransactionIntent', 'id', id)
            const localVarPath = `/v1/transaction_intents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of transaction intents for the given project. The accounts are returned sorted by creation date, with the most recently created accounts appearing first.
         * @param {Array<string>} [expand] 
         * @param {number} [limit] 
         * @param {string} [filter] 
         * @param {SortOrder} [order] 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionIntents: async (expand?: Array<string>, limit?: number, filter?: string, order?: SortOrder, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/transaction_intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirms the creation of a transaction intent with an external owner.
         * @param {string} id 
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signature: async (id: string, signatureRequest: SignatureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signature', 'id', id)
            // verify required parameter 'signatureRequest' is not null or undefined
            assertParamExists('signature', 'signatureRequest', signatureRequest)
            const localVarPath = `/v1/transaction_intents/{id}/signature`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionIntentResponse: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransactionIntentResponse', 'id', id)
            const localVarPath = `/v1/transaction_intents/{id}/update_response`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionIntentsResponse: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/transaction_intents/update_response`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionIntentsApi - functional programming interface
 * @export
 */
export const TransactionIntentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionIntentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a transaction intent object.
         * @param {TransactionIntentRequest} transactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransactionIntent(transactionIntentRequest: TransactionIntentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransactionIntent(transactionIntentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a transaction intent object.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionIntent(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionIntent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of transaction intents for the given project. The accounts are returned sorted by creation date, with the most recently created accounts appearing first.
         * @param {Array<string>} [expand] 
         * @param {number} [limit] 
         * @param {string} [filter] 
         * @param {SortOrder} [order] 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionIntents(expand?: Array<string>, limit?: number, filter?: string, order?: SortOrder, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionIntents(expand, limit, filter, order, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Confirms the creation of a transaction intent with an external owner.
         * @param {string} id 
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signature(id: string, signatureRequest: SignatureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signature(id, signatureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransactionIntentResponse(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransactionIntentResponse(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransactionIntentsResponse(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransactionIntentsResponse(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionIntentsApi - factory interface
 * @export
 */
export const TransactionIntentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionIntentsApiFp(configuration)
    return {
        /**
         * Creates a transaction intent object.
         * @param {TransactionIntentRequest} transactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionIntent(transactionIntentRequest: TransactionIntentRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.createTransactionIntent(transactionIntentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a transaction intent object.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionIntent(id: string, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.getTransactionIntent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of transaction intents for the given project. The accounts are returned sorted by creation date, with the most recently created accounts appearing first.
         * @param {Array<string>} [expand] 
         * @param {number} [limit] 
         * @param {string} [filter] 
         * @param {SortOrder} [order] 
         * @param {number} [skip] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionIntents(expand?: Array<string>, limit?: number, filter?: string, order?: SortOrder, skip?: number, options?: any): AxiosPromise<TransactionIntentsResponse> {
            return localVarFp.getTransactionIntents(expand, limit, filter, order, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirms the creation of a transaction intent with an external owner.
         * @param {string} id 
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signature(id: string, signatureRequest: SignatureRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.signature(id, signatureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionIntentResponse(id: string, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.updateTransactionIntentResponse(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionIntentsResponse(options?: any): AxiosPromise<TransactionIntentsResponse> {
            return localVarFp.updateTransactionIntentsResponse(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionIntentsApi - object-oriented interface
 * @export
 * @class TransactionIntentsApi
 * @extends {BaseAPI}
 */
export class TransactionIntentsApi extends BaseAPI {
    /**
     * Creates a transaction intent object.
     * @param {TransactionIntentRequest} transactionIntentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public createTransactionIntent(transactionIntentRequest: TransactionIntentRequest, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).createTransactionIntent(transactionIntentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a transaction intent object.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public getTransactionIntent(id: string, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).getTransactionIntent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of transaction intents for the given project. The accounts are returned sorted by creation date, with the most recently created accounts appearing first.
     * @param {Array<string>} [expand] 
     * @param {number} [limit] 
     * @param {string} [filter] 
     * @param {SortOrder} [order] 
     * @param {number} [skip] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public getTransactionIntents(expand?: Array<string>, limit?: number, filter?: string, order?: SortOrder, skip?: number, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).getTransactionIntents(expand, limit, filter, order, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirms the creation of a transaction intent with an external owner.
     * @param {string} id 
     * @param {SignatureRequest} signatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public signature(id: string, signatureRequest: SignatureRequest, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).signature(id, signatureRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public updateTransactionIntentResponse(id: string, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).updateTransactionIntentResponse(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public updateTransactionIntentsResponse(options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).updateTransactionIntentsResponse(options).then((request) => request(this.axios, this.basePath));
    }
}


