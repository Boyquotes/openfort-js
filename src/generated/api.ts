/* tslint:disable */
/* eslint-disable */
/**
 * Openfort API
 * Complete Openfort API references and guides can be found at: https://openfort.xyz/docs
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: founders@openfort.xyz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Abi
 */
export interface Abi {
    /**
     * 
     * @type {string}
     * @memberof Abi
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Abi
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Abi
     */
    'anonymous'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Abi
     */
    'payable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Abi
     */
    'constant'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Abi
     */
    'stateMutability'?: string;
    /**
     * 
     * @type {string}
     * @memberof Abi
     */
    'gas'?: string;
    /**
     * 
     * @type {Array<AbiType>}
     * @memberof Abi
     */
    'inputs'?: Array<AbiType>;
    /**
     * 
     * @type {Array<AbiType>}
     * @memberof Abi
     */
    'outputs'?: Array<AbiType>;
}
/**
 * 
 * @export
 * @interface AbiType
 */
export interface AbiType {
    /**
     * 
     * @type {string}
     * @memberof AbiType
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AbiType
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AbiType
     */
    'indexed'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof AbiType
     */
    'internalType'?: any;
    /**
     * 
     * @type {Array<AbiType>}
     * @memberof AbiType
     */
    'components'?: Array<AbiType>;
}
/**
 * Accelbyte oauth configuration
 * @export
 * @interface AccelbyteOAuthConfig
 */
export interface AccelbyteOAuthConfig {
    /**
     * Enable OAuth provider.
     * @type {boolean}
     * @memberof AccelbyteOAuthConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {OAuthProviderACCELBYTE}
     * @memberof AccelbyteOAuthConfig
     */
    'provider': OAuthProviderACCELBYTE;
    /**
     * Base URI of your accelbyte gaming service environment. E.g. https://mygame.dev.gamingservices.accelbyte.io/
     * @type {string}
     * @memberof AccelbyteOAuthConfig
     */
    'baseUrl': string;
    /**
     * Client ID of your accelbyte gaming service environment.
     * @type {string}
     * @memberof AccelbyteOAuthConfig
     */
    'clientId': string;
    /**
     * Secret of your confidential IAM client.
     * @type {string}
     * @memberof AccelbyteOAuthConfig
     */
    'clientSecret': string;
}


/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeACCOUNT}
     * @memberof Account
     */
    'object': EntityTypeACCOUNT;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'ownerAddress': string;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'deployed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'custodial': boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof Account
     */
    'chainId': number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'accountType': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'pendingOwnerAddress'?: string;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof Account
     */
    'transactionIntents'?: Array<EntityIdResponse>;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof Account
     */
    'player': EntityIdResponse;
}


/**
 * 
 * @export
 * @interface AccountInventoryListQueries
 */
export interface AccountInventoryListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof AccountInventoryListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof AccountInventoryListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof AccountInventoryListQueries
     */
    'order'?: SortOrder;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountInventoryListQueries
     */
    'contractId'?: Array<string>;
}


/**
 * 
 * @export
 * @interface AccountListQueries
 */
export interface AccountListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof AccountListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof AccountListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof AccountListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the fields to expand in the response.
     * @type {Array<AccountResponseExpandable>}
     * @memberof AccountListQueries
     */
    'expand'?: Array<AccountResponseExpandable>;
    /**
     * Specifies the unique player ID (starts with pla_)
     * @type {string}
     * @memberof AccountListQueries
     */
    'player': string;
}


/**
 * 
 * @export
 * @interface AccountListResponse
 */
export interface AccountListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof AccountListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof AccountListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<AccountResponse>}
     * @memberof AccountListResponse
     */
    'data': Array<AccountResponse>;
    /**
     * 
     * @type {number}
     * @memberof AccountListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof AccountListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof AccountListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface AccountNotificationTriggerResponse
 */
export interface AccountNotificationTriggerResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountNotificationTriggerResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeNOTIFICATIONTRIGGER}
     * @memberof AccountNotificationTriggerResponse
     */
    'object': EntityTypeNOTIFICATIONTRIGGER;
    /**
     * 
     * @type {number}
     * @memberof AccountNotificationTriggerResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {NotificationTriggerTypeDEVELOPERACCOUNTTRIGGER}
     * @memberof AccountNotificationTriggerResponse
     */
    'type': NotificationTriggerTypeDEVELOPERACCOUNTTRIGGER;
    /**
     * 
     * @type {string}
     * @memberof AccountNotificationTriggerResponse
     */
    'threshold': string;
    /**
     * 
     * @type {AccountNotificationTriggerResponseAccount}
     * @memberof AccountNotificationTriggerResponse
     */
    'account': AccountNotificationTriggerResponseAccount;
    /**
     * 
     * @type {number}
     * @memberof AccountNotificationTriggerResponse
     */
    'chainId': number;
}


/**
 * 
 * @export
 * @interface AccountNotificationTriggerResponseAccount
 */
export interface AccountNotificationTriggerResponseAccount {
    /**
     * 
     * @type {string}
     * @memberof AccountNotificationTriggerResponseAccount
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeDEVELOPERACCOUNT}
     * @memberof AccountNotificationTriggerResponseAccount
     */
    'object': EntityTypeDEVELOPERACCOUNT;
    /**
     * 
     * @type {number}
     * @memberof AccountNotificationTriggerResponseAccount
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof AccountNotificationTriggerResponseAccount
     */
    'address': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountNotificationTriggerResponseAccount
     */
    'custodial': boolean;
    /**
     * 
     * @type {string}
     * @memberof AccountNotificationTriggerResponseAccount
     */
    'name'?: string;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof AccountNotificationTriggerResponseAccount
     */
    'transactionIntents'?: Array<EntityIdResponse>;
}


/**
 * 
 * @export
 * @interface AccountPolicyRuleResponse
 */
export interface AccountPolicyRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountPolicyRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof AccountPolicyRuleResponse
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {number}
     * @memberof AccountPolicyRuleResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {PolicyRuleTypeACCOUNT}
     * @memberof AccountPolicyRuleResponse
     */
    'type': PolicyRuleTypeACCOUNT;
}


/**
 * 
 * @export
 * @interface AccountResponse
 */
export interface AccountResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeACCOUNT}
     * @memberof AccountResponse
     */
    'object': EntityTypeACCOUNT;
    /**
     * 
     * @type {number}
     * @memberof AccountResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'ownerAddress': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountResponse
     */
    'deployed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountResponse
     */
    'custodial': boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof AccountResponse
     */
    'chainId': number;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'accountType': string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    'pendingOwnerAddress'?: string;
    /**
     * 
     * @type {Array<PlayerResponseTransactionIntentsInner>}
     * @memberof AccountResponse
     */
    'transactionIntents'?: Array<PlayerResponseTransactionIntentsInner>;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof AccountResponse
     */
    'player': EntityIdResponse;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AccountResponseExpandable = {
    TransactionIntents: 'transactionIntents',
    Player: 'player'
} as const;

export type AccountResponseExpandable = typeof AccountResponseExpandable[keyof typeof AccountResponseExpandable];


/**
 * 
 * @export
 * @interface ApiAuthorizedNetworkListResponse
 */
export interface ApiAuthorizedNetworkListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof ApiAuthorizedNetworkListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof ApiAuthorizedNetworkListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<ApiAuthorizedNetworkResponse>}
     * @memberof ApiAuthorizedNetworkListResponse
     */
    'data': Array<ApiAuthorizedNetworkResponse>;
    /**
     * 
     * @type {number}
     * @memberof ApiAuthorizedNetworkListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAuthorizedNetworkListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAuthorizedNetworkListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface ApiAuthorizedNetworkResponse
 */
export interface ApiAuthorizedNetworkResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiAuthorizedNetworkResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAuthorizedNetworkResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ApiAuthorizedNetworkResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiAuthorizedNetworkResponse
     */
    'network': string;
}
/**
 * 
 * @export
 * @interface ApiKeyResponse
 */
export interface ApiKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiKeyResponse
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ApiKeyResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiKeyResponse
     */
    'livemode': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ApiKeyType = {
    Pk: 'pk',
    Sk: 'sk'
} as const;

export type ApiKeyType = typeof ApiKeyType[keyof typeof ApiKeyType];


/**
 * 
 * @export
 * @interface AssetInventory
 */
export interface AssetInventory {
    /**
     * 
     * @type {AssetType}
     * @memberof AssetInventory
     */
    'assetType': AssetType;
    /**
     * 
     * @type {string}
     * @memberof AssetInventory
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetInventory
     */
    'tokenId'?: number;
    /**
     * amount in Wei
     * @type {string}
     * @memberof AssetInventory
     */
    'amount'?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetInventory
     */
    'lastTransferredAt'?: number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AssetType = {
    Eth: 'ETH',
    Erc20: 'ERC20',
    Erc721: 'ERC721',
    Erc1155: 'ERC1155'
} as const;

export type AssetType = typeof AssetType[keyof typeof AssetType];


/**
 * 
 * @export
 * @interface AuthPlayerListQueries
 */
export interface AuthPlayerListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof AuthPlayerListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof AuthPlayerListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof AuthPlayerListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the email address of the user.
     * @type {string}
     * @memberof AuthPlayerListQueries
     */
    'email'?: string;
}


/**
 * 
 * @export
 * @interface AuthPlayerListResponse
 */
export interface AuthPlayerListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof AuthPlayerListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof AuthPlayerListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<AuthPlayerResponse>}
     * @memberof AuthPlayerListResponse
     */
    'data': Array<AuthPlayerResponse>;
    /**
     * 
     * @type {number}
     * @memberof AuthPlayerListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof AuthPlayerListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof AuthPlayerListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface AuthPlayerResponse
 */
export interface AuthPlayerResponse {
    /**
     * 
     * @type {AuthPlayerResponsePlayer}
     * @memberof AuthPlayerResponse
     */
    'player'?: AuthPlayerResponsePlayer;
    /**
     * 
     * @type {string}
     * @memberof AuthPlayerResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePLAYER}
     * @memberof AuthPlayerResponse
     */
    'object': EntityTypePLAYER;
    /**
     * 
     * @type {number}
     * @memberof AuthPlayerResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {Array<LinkedAccountResponse>}
     * @memberof AuthPlayerResponse
     */
    'linkedAccounts': Array<LinkedAccountResponse>;
}


/**
 * 
 * @export
 * @interface AuthPlayerResponsePlayer
 */
export interface AuthPlayerResponsePlayer {
    /**
     * 
     * @type {string}
     * @memberof AuthPlayerResponsePlayer
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePLAYER}
     * @memberof AuthPlayerResponsePlayer
     */
    'object': EntityTypePLAYER;
    /**
     * 
     * @type {number}
     * @memberof AuthPlayerResponsePlayer
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof AuthPlayerResponsePlayer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AuthPlayerResponsePlayer
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: PlayerMetadataValue; }}
     * @memberof AuthPlayerResponsePlayer
     */
    'metadata'?: { [key: string]: PlayerMetadataValue; };
    /**
     * 
     * @type {Array<PlayerResponseTransactionIntentsInner>}
     * @memberof AuthPlayerResponsePlayer
     */
    'transactionIntents'?: Array<PlayerResponseTransactionIntentsInner>;
    /**
     * 
     * @type {Array<PlayerResponseAccountsInner>}
     * @memberof AuthPlayerResponsePlayer
     */
    'accounts'?: Array<PlayerResponseAccountsInner>;
}


/**
 * Enum of the supporting OAuth providers.
 * @export
 * @enum {string}
 */

export const AuthProvider = {
    Email: 'email',
    Accelbyte: 'accelbyte',
    Firebase: 'firebase',
    Google: 'google',
    Lootlocker: 'lootlocker',
    Playfab: 'playfab',
    Wallet: 'wallet'
} as const;

export type AuthProvider = typeof AuthProvider[keyof typeof AuthProvider];


/**
 * 
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * 
     * @type {AuthPlayerResponse}
     * @memberof AuthResponse
     */
    'player': AuthPlayerResponse;
    /**
     * JWT access token.
     * @type {string}
     * @memberof AuthResponse
     */
    'token': string;
    /**
     * Refresh token.
     * @type {string}
     * @memberof AuthResponse
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface AuthSessionResponse
 */
export interface AuthSessionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof AuthSessionResponse
     */
    'livemode': boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthSessionResponse
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof AuthSessionResponse
     */
    'playerId': string;
    /**
     * 
     * @type {string}
     * @memberof AuthSessionResponse
     */
    'issuer': string;
    /**
     * 
     * @type {number}
     * @memberof AuthSessionResponse
     */
    'issuedAt': number;
    /**
     * 
     * @type {number}
     * @memberof AuthSessionResponse
     */
    'expiration': number;
    /**
     * 
     * @type {string}
     * @memberof AuthSessionResponse
     */
    'sessionId': string;
}
/**
 * 
 * @export
 * @interface AuthenticateOAuthRequest
 */
export interface AuthenticateOAuthRequest {
    /**
     * 
     * @type {OAuthProvider}
     * @memberof AuthenticateOAuthRequest
     */
    'provider': OAuthProvider;
    /**
     * Token to be verified
     * @type {string}
     * @memberof AuthenticateOAuthRequest
     */
    'token': string;
}


/**
 * 
 * @export
 * @interface BalanceNotificationTriggerResponse
 */
export interface BalanceNotificationTriggerResponse {
    /**
     * 
     * @type {string}
     * @memberof BalanceNotificationTriggerResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeNOTIFICATIONTRIGGER}
     * @memberof BalanceNotificationTriggerResponse
     */
    'object': EntityTypeNOTIFICATIONTRIGGER;
    /**
     * 
     * @type {number}
     * @memberof BalanceNotificationTriggerResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {NotificationTriggerTypePROJECTBALANCETRIGGER}
     * @memberof BalanceNotificationTriggerResponse
     */
    'type': NotificationTriggerTypePROJECTBALANCETRIGGER;
    /**
     * 
     * @type {string}
     * @memberof BalanceNotificationTriggerResponse
     */
    'threshold': string;
}


/**
 * 
 * @export
 * @interface BalanceResponse
 */
export interface BalanceResponse {
    /**
     * 
     * @type {Money}
     * @memberof BalanceResponse
     */
    'balance': Money;
    /**
     * 
     * @type {Money}
     * @memberof BalanceResponse
     */
    'expenses': Money;
    /**
     * 
     * @type {Money}
     * @memberof BalanceResponse
     */
    'payments': Money;
}
/**
 * 
 * @export
 * @interface BaseEntityListResponseDeviceResponse
 */
export interface BaseEntityListResponseDeviceResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof BaseEntityListResponseDeviceResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof BaseEntityListResponseDeviceResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<DeviceResponse>}
     * @memberof BaseEntityListResponseDeviceResponse
     */
    'data': Array<DeviceResponse>;
    /**
     * 
     * @type {number}
     * @memberof BaseEntityListResponseDeviceResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof BaseEntityListResponseDeviceResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof BaseEntityListResponseDeviceResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface BaseEntityListResponseShareResponse
 */
export interface BaseEntityListResponseShareResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof BaseEntityListResponseShareResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof BaseEntityListResponseShareResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<ShareResponse>}
     * @memberof BaseEntityListResponseShareResponse
     */
    'data': Array<ShareResponse>;
    /**
     * 
     * @type {number}
     * @memberof BaseEntityListResponseShareResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof BaseEntityListResponseShareResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof BaseEntityListResponseShareResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface CancelTransferOwnershipRequest
 */
export interface CancelTransferOwnershipRequest {
    /**
     * ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). A policy must be provided.
     * @type {string}
     * @memberof CancelTransferOwnershipRequest
     */
    'policy': string;
}
/**
 * 
 * @export
 * @interface ChargeCustomTokenPolicyStrategy
 */
export interface ChargeCustomTokenPolicyStrategy {
    /**
     * 
     * @type {SponsorSchemaCHARGECUSTOMTOKENS}
     * @memberof ChargeCustomTokenPolicyStrategy
     */
    'sponsorSchema': SponsorSchemaCHARGECUSTOMTOKENS;
    /**
     * 
     * @type {string}
     * @memberof ChargeCustomTokenPolicyStrategy
     */
    'depositor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChargeCustomTokenPolicyStrategy
     */
    'tokenContract': string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCustomTokenPolicyStrategy
     */
    'tokenContractAmount': string;
}


/**
 * 
 * @export
 * @interface CheckoutRequest
 */
export interface CheckoutRequest {
    /**
     * Amount in cents
     * @type {number}
     * @memberof CheckoutRequest
     */
    'amount': number;
    /**
     * 
     * @type {Currency}
     * @memberof CheckoutRequest
     */
    'currency': Currency;
    /**
     * 
     * @type {string}
     * @memberof CheckoutRequest
     */
    'cancelUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutRequest
     */
    'successUrl'?: string;
}


/**
 * 
 * @export
 * @interface CheckoutResponse
 */
export interface CheckoutResponse {
    /**
     * 
     * @type {string}
     * @memberof CheckoutResponse
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface CheckoutSubscriptionRequest
 */
export interface CheckoutSubscriptionRequest {
    /**
     * 
     * @type {string}
     * @memberof CheckoutSubscriptionRequest
     */
    'plan': string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSubscriptionRequest
     */
    'cancelUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSubscriptionRequest
     */
    'successUrl'?: string;
}
/**
 * 
 * @export
 * @interface CompleteRecoveryRequest
 */
export interface CompleteRecoveryRequest {
    /**
     * Address of the new owner
     * @type {string}
     * @memberof CompleteRecoveryRequest
     */
    'newOwnerAddress': string;
    /**
     * Signatures by the guardians
     * @type {Array<string>}
     * @memberof CompleteRecoveryRequest
     */
    'signatures'?: Array<string>;
    /**
     * The policy ID (starts with pol_)
     * @type {string}
     * @memberof CompleteRecoveryRequest
     */
    'policy': string;
}
/**
 * 
 * @export
 * @interface ContractDeleteResponse
 */
export interface ContractDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof ContractDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeCONTRACT}
     * @memberof ContractDeleteResponse
     */
    'object': EntityTypeCONTRACT;
    /**
     * 
     * @type {boolean}
     * @memberof ContractDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface ContractListQueries
 */
export interface ContractListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof ContractListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof ContractListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof ContractListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the name of the contract.
     * @type {string}
     * @memberof ContractListQueries
     */
    'name'?: string;
    /**
     * Specifies whether to include deleted contracts.
     * @type {boolean}
     * @memberof ContractListQueries
     */
    'deleted'?: boolean;
    /**
     * The chain ID of the contract.
     * @type {number}
     * @memberof ContractListQueries
     */
    'chainId'?: number;
    /**
     * Specifies the address of the contract.
     * @type {string}
     * @memberof ContractListQueries
     */
    'address'?: string;
}


/**
 * 
 * @export
 * @interface ContractListResponse
 */
export interface ContractListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof ContractListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof ContractListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<ContractResponse>}
     * @memberof ContractListResponse
     */
    'data': Array<ContractResponse>;
    /**
     * 
     * @type {number}
     * @memberof ContractListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof ContractListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof ContractListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface ContractNotificationTriggerResponse
 */
export interface ContractNotificationTriggerResponse {
    /**
     * 
     * @type {string}
     * @memberof ContractNotificationTriggerResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeNOTIFICATIONTRIGGER}
     * @memberof ContractNotificationTriggerResponse
     */
    'object': EntityTypeNOTIFICATIONTRIGGER;
    /**
     * 
     * @type {number}
     * @memberof ContractNotificationTriggerResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {NotificationTriggerTypeCONTRACTTRIGGER}
     * @memberof ContractNotificationTriggerResponse
     */
    'type': NotificationTriggerTypeCONTRACTTRIGGER;
    /**
     * 
     * @type {string}
     * @memberof ContractNotificationTriggerResponse
     */
    'threshold': string;
    /**
     * 
     * @type {ContractNotificationTriggerResponseContract}
     * @memberof ContractNotificationTriggerResponse
     */
    'contract': ContractNotificationTriggerResponseContract;
    /**
     * 
     * @type {string}
     * @memberof ContractNotificationTriggerResponse
     */
    'functionName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContractNotificationTriggerResponse
     */
    'functionArgs': Array<string>;
}


/**
 * 
 * @export
 * @interface ContractNotificationTriggerResponseContract
 */
export interface ContractNotificationTriggerResponseContract {
    /**
     * 
     * @type {string}
     * @memberof ContractNotificationTriggerResponseContract
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeCONTRACT}
     * @memberof ContractNotificationTriggerResponseContract
     */
    'object': EntityTypeCONTRACT;
    /**
     * 
     * @type {number}
     * @memberof ContractNotificationTriggerResponseContract
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ContractNotificationTriggerResponseContract
     */
    'name': string | null;
    /**
     * The chain ID.
     * @type {number}
     * @memberof ContractNotificationTriggerResponseContract
     */
    'chainId': number;
    /**
     * 
     * @type {string}
     * @memberof ContractNotificationTriggerResponseContract
     */
    'address': string;
    /**
     * 
     * @type {boolean}
     * @memberof ContractNotificationTriggerResponseContract
     */
    'deleted': boolean;
    /**
     * 
     * @type {Array<Abi>}
     * @memberof ContractNotificationTriggerResponseContract
     */
    'abi': Array<Abi>;
    /**
     * 
     * @type {boolean}
     * @memberof ContractNotificationTriggerResponseContract
     */
    'publicVerification': boolean;
}


/**
 * 
 * @export
 * @interface ContractPolicyRuleResponse
 */
export interface ContractPolicyRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof ContractPolicyRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof ContractPolicyRuleResponse
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {number}
     * @memberof ContractPolicyRuleResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {PolicyRuleTypeCONTRACT}
     * @memberof ContractPolicyRuleResponse
     */
    'type': PolicyRuleTypeCONTRACT;
    /**
     * 
     * @type {ContractNotificationTriggerResponseContract}
     * @memberof ContractPolicyRuleResponse
     */
    'contract': ContractNotificationTriggerResponseContract;
    /**
     * 
     * @type {string}
     * @memberof ContractPolicyRuleResponse
     */
    'functionName': string;
}


/**
 * 
 * @export
 * @interface ContractReadQueries
 */
export interface ContractReadQueries {
    /**
     * The function name of the contract.
     * @type {string}
     * @memberof ContractReadQueries
     */
    'functionName': string;
    /**
     * The function arguments of the contract, in string format. Accepts pla_, con_ and acc_ IDs.
     * @type {Array<any>}
     * @memberof ContractReadQueries
     */
    'functionArgs'?: Array<any>;
}
/**
 * 
 * @export
 * @interface ContractReadResponse
 */
export interface ContractReadResponse {
    /**
     * 
     * @type {string}
     * @memberof ContractReadResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeREADCONTRACT}
     * @memberof ContractReadResponse
     */
    'object': EntityTypeREADCONTRACT;
    /**
     * 
     * @type {number}
     * @memberof ContractReadResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ContractReadResponse
     */
    'functionName': string;
    /**
     * 
     * @type {any}
     * @memberof ContractReadResponse
     */
    'result': any;
}


/**
 * 
 * @export
 * @interface ContractResponse
 */
export interface ContractResponse {
    /**
     * 
     * @type {string}
     * @memberof ContractResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeCONTRACT}
     * @memberof ContractResponse
     */
    'object': EntityTypeCONTRACT;
    /**
     * 
     * @type {number}
     * @memberof ContractResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ContractResponse
     */
    'name': string | null;
    /**
     * The chain ID.
     * @type {number}
     * @memberof ContractResponse
     */
    'chainId': number;
    /**
     * 
     * @type {string}
     * @memberof ContractResponse
     */
    'address': string;
    /**
     * 
     * @type {boolean}
     * @memberof ContractResponse
     */
    'deleted': boolean;
    /**
     * 
     * @type {Array<Abi>}
     * @memberof ContractResponse
     */
    'abi': Array<Abi>;
    /**
     * 
     * @type {boolean}
     * @memberof ContractResponse
     */
    'publicVerification': boolean;
}


/**
 * 
 * @export
 * @interface CountPerIntervalLimitPolicyRuleResponse
 */
export interface CountPerIntervalLimitPolicyRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {number}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {PolicyRuleTypeRATELIMIT}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'type': PolicyRuleTypeRATELIMIT;
    /**
     * 
     * @type {PolicyRateLimitCOUNTPERINTERVAL}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'functionName': PolicyRateLimitCOUNTPERINTERVAL;
    /**
     * 
     * @type {number}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'countLimit': number;
    /**
     * 
     * @type {TimeIntervalType}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'timeIntervalType': TimeIntervalType;
    /**
     * 
     * @type {number}
     * @memberof CountPerIntervalLimitPolicyRuleResponse
     */
    'timeIntervalValue': number;
}


/**
 * 
 * @export
 * @interface CreateAccountRequest
 */
export interface CreateAccountRequest {
    /**
     * The chain ID. Must be a [supported chain](/chains).
     * @type {number}
     * @memberof CreateAccountRequest
     */
    'chainId': number;
    /**
     * Use this parameter to create a new Account for Player with the provided owner address.
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'externalOwnerAddress'?: string;
    /**
     * The type of smart account that will be created (e.g. ERC6551V1, ManagedV5, UpgradeableV5). Defaults to UpgradeableV5.
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'accountType'?: string;
    /**
     * For account types that support social recovery, wether to enable Openfort as guardian or not. Defaults to false.
     * @type {boolean}
     * @memberof CreateAccountRequest
     */
    'defaultGuardian'?: boolean;
    /**
     * If ERC6551, the address of the NFT contract to use
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'tokenContract'?: string;
    /**
     * If ERC6551, the tokenId from the NFT contract that will serve as owner
     * @type {number}
     * @memberof CreateAccountRequest
     */
    'tokenId'?: number;
    /**
     * ID of the player this account belongs to (starts with `pla_`). If none is provided, a new player will be created.
     * @type {string}
     * @memberof CreateAccountRequest
     */
    'player'?: string;
}
/**
 * 
 * @export
 * @interface CreateApiAuthorizedNetworkRequest
 */
export interface CreateApiAuthorizedNetworkRequest {
    /**
     * The name of the authorized network.
     * @type {string}
     * @memberof CreateApiAuthorizedNetworkRequest
     */
    'name': string;
    /**
     * The network address.
     * @type {string}
     * @memberof CreateApiAuthorizedNetworkRequest
     */
    'network': string;
}
/**
 * 
 * @export
 * @interface CreateContractRequest
 */
export interface CreateContractRequest {
    /**
     * Specifies the name of the contract (Only for display purposes).
     * @type {string}
     * @memberof CreateContractRequest
     */
    'name': string;
    /**
     * Specifies the chain ID of the contract. Must be a [supported chain](/chains).
     * @type {number}
     * @memberof CreateContractRequest
     */
    'chainId': number;
    /**
     * Specifies the address of the contract.
     * @type {string}
     * @memberof CreateContractRequest
     */
    'address': string;
    /**
     * Specifies the ABI of the contract.
     * @type {Array<Abi>}
     * @memberof CreateContractRequest
     */
    'abi'?: Array<Abi>;
    /**
     * Specifies whether to verify the contract publicly.
     * @type {boolean}
     * @memberof CreateContractRequest
     */
    'publicVerification'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateDeviceRequest
 */
export interface CreateDeviceRequest {
    /**
     * Specifies the unique account ID (starts with acc_)
     * @type {string}
     * @memberof CreateDeviceRequest
     */
    'account': string;
}
/**
 * 
 * @export
 * @interface CreateNotificationRequest
 */
export interface CreateNotificationRequest {
    /**
     * The name of the notification.
     * @type {string}
     * @memberof CreateNotificationRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateNotificationSubscriptionRequest
 */
export interface CreateNotificationSubscriptionRequest {
    /**
     * The notification ID (starts with not_).
     * @type {string}
     * @memberof CreateNotificationSubscriptionRequest
     */
    'notification': string;
    /**
     * 
     * @type {SubscriptionType}
     * @memberof CreateNotificationSubscriptionRequest
     */
    'method': SubscriptionType;
    /**
     * The receiver of notifications.
     * @type {string}
     * @memberof CreateNotificationSubscriptionRequest
     */
    'target': string;
}


/**
 * 
 * @export
 * @interface CreateNotificationTriggerRequest
 */
export interface CreateNotificationTriggerRequest {
    /**
     * The notification ID (starts with not_).
     * @type {string}
     * @memberof CreateNotificationTriggerRequest
     */
    'notification': string;
    /**
     * 
     * @type {NotificationTriggerType}
     * @memberof CreateNotificationTriggerRequest
     */
    'type': NotificationTriggerType;
    /**
     * The function name of the contract. Accepts a a function signature as well (e.g. mint(address)).
     * @type {string}
     * @memberof CreateNotificationTriggerRequest
     */
    'functionName'?: string;
    /**
     * The function arguments of the contract, in string format. If you provide one of a `pla_...`, `con_...` or `acc_...` it will be converted to the corresponding address.
     * @type {Array<string>}
     * @memberof CreateNotificationTriggerRequest
     */
    'functionArgs'?: Array<string>;
    /**
     * The contract ID you want to interact with. Must have been added to Openfort first, starts with `con_`.
     * @type {string}
     * @memberof CreateNotificationTriggerRequest
     */
    'contract'?: string;
    /**
     * The threshold value at which (greater or equal) the notification will be triggered.
     * @type {string}
     * @memberof CreateNotificationTriggerRequest
     */
    'threshold': string;
    /**
     * The chain ID. Must be a [supported chain](/chains).
     * @type {number}
     * @memberof CreateNotificationTriggerRequest
     */
    'chainId'?: number;
    /**
     * ID of the Developer Account this trigger will check the balance of (starts with `dac_`).
     * @type {string}
     * @memberof CreateNotificationTriggerRequest
     */
    'account'?: string;
}


/**
 * 
 * @export
 * @interface CreatePolicyRequest
 */
export interface CreatePolicyRequest {
    /**
     * Specifies the name of the policy.
     * @type {string}
     * @memberof CreatePolicyRequest
     */
    'name': string;
    /**
     * The chain ID. Must be a [supported chain](/chains).
     * @type {number}
     * @memberof CreatePolicyRequest
     */
    'chainId': number;
    /**
     * 
     * @type {PolicyStrategyRequest}
     * @memberof CreatePolicyRequest
     */
    'strategy': PolicyStrategyRequest;
}
/**
 * 
 * @export
 * @interface CreatePolicyRuleRequest
 */
export interface CreatePolicyRuleRequest {
    /**
     * 
     * @type {PolicyRuleType}
     * @memberof CreatePolicyRuleRequest
     */
    'type': PolicyRuleType;
    /**
     * Name of the function in the contract to allow. If you want to allow all functions, use the wildcard \'All functions\'.
     * @type {string}
     * @memberof CreatePolicyRuleRequest
     */
    'functionName'?: string;
    /**
     * The contract ID you want to interact with. Must have been added to Openfort first, starts with `con_`.
     * @type {string}
     * @memberof CreatePolicyRuleRequest
     */
    'contract'?: string;
    /**
     * Gas limit in WEI (i.e. factor 10^18).
     * @type {string}
     * @memberof CreatePolicyRuleRequest
     */
    'gasLimit'?: string;
    /**
     * Number of times the function will be sponsored.
     * @type {number}
     * @memberof CreatePolicyRuleRequest
     */
    'countLimit'?: number;
    /**
     * 
     * @type {TimeIntervalType}
     * @memberof CreatePolicyRuleRequest
     */
    'timeIntervalType'?: TimeIntervalType;
    /**
     * Time interval value.
     * @type {number}
     * @memberof CreatePolicyRuleRequest
     */
    'timeIntervalValue'?: number;
    /**
     * The unique Policy ID to add the rule to (starts with pol_).
     * @type {string}
     * @memberof CreatePolicyRuleRequest
     */
    'policy': string;
}


/**
 * 
 * @export
 * @interface CreateProjectApiKeyRequest
 */
export interface CreateProjectApiKeyRequest {
    /**
     * 
     * @type {ApiKeyType}
     * @memberof CreateProjectApiKeyRequest
     */
    'type': ApiKeyType;
}


/**
 * 
 * @export
 * @interface CreateProjectRequest
 */
export interface CreateProjectRequest {
    /**
     * Name of the project.
     * @type {string}
     * @memberof CreateProjectRequest
     */
    'name': string;
    /**
     * 
     * @type {PrivateKeyPolicy}
     * @memberof CreateProjectRequest
     */
    'pkPolicy'?: PrivateKeyPolicy;
}


/**
 * 
 * @export
 * @interface CreateSessionRequest
 */
export interface CreateSessionRequest {
    /**
     * The address of the session key.
     * @type {string}
     * @memberof CreateSessionRequest
     */
    'address': string;
    /**
     * The chain ID. Must be a [supported chain](/chains).
     * @type {number}
     * @memberof CreateSessionRequest
     */
    'chainId': number;
    /**
     * If no account exists for a given player, create one with this address.
     * @type {string}
     * @memberof CreateSessionRequest
     */
    'externalOwnerAddress'?: string;
    /**
     * Maximum number of times the session key can be used.
     * @type {number}
     * @memberof CreateSessionRequest
     */
    'limit'?: number;
    /**
     * Set to `true` to indicate that the transactionIntent request should be resolved as soon as possible, after the transactionIntent is created and simulated and before it arrives on chain.
     * @type {boolean}
     * @memberof CreateSessionRequest
     */
    'optimistic'?: boolean;
    /**
     * ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). If no Policy is provided, the own Account native token funds will be used to pay for gas.
     * @type {string}
     * @memberof CreateSessionRequest
     */
    'policy'?: string;
    /**
     * The unix timestamp in seconds when the session key becomes valid.
     * @type {number}
     * @memberof CreateSessionRequest
     */
    'validAfter': number;
    /**
     * The unix timestamp in seconds when the session key expires.
     * @type {number}
     * @memberof CreateSessionRequest
     */
    'validUntil': number;
    /**
     * The list of whitelisted addresses (contracts the session key can interact with).
     * @type {Array<string>}
     * @memberof CreateSessionRequest
     */
    'whitelist'?: Array<string>;
    /**
     * The player ID (starts with pla_).
     * @type {string}
     * @memberof CreateSessionRequest
     */
    'player': string;
}
/**
 * 
 * @export
 * @interface CreateShareRequest
 */
export interface CreateShareRequest {
    /**
     * Specifies the unique share ID (starts with sha_)
     * @type {string}
     * @memberof CreateShareRequest
     */
    'share': string;
    /**
     * 
     * @type {ShareType}
     * @memberof CreateShareRequest
     */
    'shareType': ShareType;
    /**
     * Specifies if the recovery share is encrypted by user entropy
     * @type {boolean}
     * @memberof CreateShareRequest
     */
    'userEntropy': boolean;
}


/**
 * 
 * @export
 * @interface CreateTransactionIntentRequest
 */
export interface CreateTransactionIntentRequest {
    /**
     * The chain ID. Must be a [supported chain](/chains).
     * @type {number}
     * @memberof CreateTransactionIntentRequest
     */
    'chainId': number;
    /**
     * ID of the Player this TransactionIntent belongs to, if one exists (starts with `pla_`).  If you omit this parameter a new Player will be created.
     * @type {string}
     * @memberof CreateTransactionIntentRequest
     */
    'player'?: string;
    /**
     * ID of the Account this TransactionIntent is executed with, if one exists (starts with `acc_` or `dac_`).  When providing a Player and ChainID, you can omit this parameter.
     * @type {string}
     * @memberof CreateTransactionIntentRequest
     */
    'account'?: string;
    /**
     * ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). If no Policy is provided, the own Account native token funds will be used to pay for gas.
     * @type {string}
     * @memberof CreateTransactionIntentRequest
     */
    'policy'?: string;
    /**
     * Use this parameter to create a new Account for Player with the provided owner address.  If you omit this parameter and no Account exists for the Player, a custodial Account will be created.
     * @type {string}
     * @memberof CreateTransactionIntentRequest
     */
    'externalOwnerAddress'?: string;
    /**
     * Set to `true` to indicate that the transactionIntent request should be resolved as soon as possible, after the transactionIntent is created and simulated and before it arrives on chain.
     * @type {boolean}
     * @memberof CreateTransactionIntentRequest
     */
    'optimistic'?: boolean;
    /**
     * Specify the number of confirmation blocks after which the confirmation webhook will be sent when the transaction arrives on-chain. Default is 5.
     * @type {number}
     * @memberof CreateTransactionIntentRequest
     */
    'confirmationBlocks'?: number;
    /**
     * 
     * @type {Array<Interaction>}
     * @memberof CreateTransactionIntentRequest
     */
    'interactions': Array<Interaction>;
}
/**
 * 
 * @export
 * @interface CreateWeb3ConnectionRequest
 */
export interface CreateWeb3ConnectionRequest {
    /**
     * ID of the Player this Web3Connection belongs to (starts with `pla_`).
     * @type {string}
     * @memberof CreateWeb3ConnectionRequest
     */
    'player': string;
    /**
     * The chain ID. Must be a [supported chain](/chains).
     * @type {number}
     * @memberof CreateWeb3ConnectionRequest
     */
    'chainId': number;
    /**
     * Specifies the URI of WalletConnect.
     * @type {string}
     * @memberof CreateWeb3ConnectionRequest
     */
    'uri': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Currency = {
    Usd: 'usd'
} as const;

export type Currency = typeof Currency[keyof typeof Currency];


/**
 * 
 * @export
 * @interface DeployRequest
 */
export interface DeployRequest {
    /**
     * The policy ID (starts with pol_)
     * @type {string}
     * @memberof DeployRequest
     */
    'policy': string;
}
/**
 * 
 * @export
 * @interface DeveloperAccount
 */
export interface DeveloperAccount {
    /**
     * 
     * @type {string}
     * @memberof DeveloperAccount
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeDEVELOPERACCOUNT}
     * @memberof DeveloperAccount
     */
    'object': EntityTypeDEVELOPERACCOUNT;
    /**
     * 
     * @type {number}
     * @memberof DeveloperAccount
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof DeveloperAccount
     */
    'address': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeveloperAccount
     */
    'custodial': boolean;
    /**
     * 
     * @type {string}
     * @memberof DeveloperAccount
     */
    'name'?: string;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof DeveloperAccount
     */
    'transactionIntents'?: Array<EntityIdResponse>;
}


/**
 * 
 * @export
 * @interface DeveloperAccountCreateRequest
 */
export interface DeveloperAccountCreateRequest {
    /**
     * The address of the wallet that has deposited funds in the paymaster.
     * @type {string}
     * @memberof DeveloperAccountCreateRequest
     */
    'address'?: string;
    /**
     * Signature to verify the account ownership.
     * @type {string}
     * @memberof DeveloperAccountCreateRequest
     */
    'signature'?: string;
    /**
     * The name of the account.
     * @type {string}
     * @memberof DeveloperAccountCreateRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface DeveloperAccountDeleteResponse
 */
export interface DeveloperAccountDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof DeveloperAccountDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeDEVELOPERACCOUNT}
     * @memberof DeveloperAccountDeleteResponse
     */
    'object': EntityTypeDEVELOPERACCOUNT;
    /**
     * 
     * @type {boolean}
     * @memberof DeveloperAccountDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface DeveloperAccountGetMessageResponse
 */
export interface DeveloperAccountGetMessageResponse {
    /**
     * 
     * @type {string}
     * @memberof DeveloperAccountGetMessageResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof DeveloperAccountGetMessageResponse
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface DeveloperAccountListQueries
 */
export interface DeveloperAccountListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof DeveloperAccountListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof DeveloperAccountListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof DeveloperAccountListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the fields to expand in the response.
     * @type {Array<DeveloperAccountResponseExpandable>}
     * @memberof DeveloperAccountListQueries
     */
    'expand'?: Array<DeveloperAccountResponseExpandable>;
    /**
     * Specifies whether to include deleted dev accounts.
     * @type {boolean}
     * @memberof DeveloperAccountListQueries
     */
    'deleted'?: boolean;
}


/**
 * 
 * @export
 * @interface DeveloperAccountListResponse
 */
export interface DeveloperAccountListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof DeveloperAccountListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof DeveloperAccountListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<DeveloperAccountResponse>}
     * @memberof DeveloperAccountListResponse
     */
    'data': Array<DeveloperAccountResponse>;
    /**
     * 
     * @type {number}
     * @memberof DeveloperAccountListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof DeveloperAccountListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof DeveloperAccountListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface DeveloperAccountResponse
 */
export interface DeveloperAccountResponse {
    /**
     * 
     * @type {string}
     * @memberof DeveloperAccountResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeDEVELOPERACCOUNT}
     * @memberof DeveloperAccountResponse
     */
    'object': EntityTypeDEVELOPERACCOUNT;
    /**
     * 
     * @type {number}
     * @memberof DeveloperAccountResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof DeveloperAccountResponse
     */
    'address': string;
    /**
     * 
     * @type {boolean}
     * @memberof DeveloperAccountResponse
     */
    'custodial': boolean;
    /**
     * 
     * @type {string}
     * @memberof DeveloperAccountResponse
     */
    'name'?: string;
    /**
     * 
     * @type {Array<PlayerResponseTransactionIntentsInner>}
     * @memberof DeveloperAccountResponse
     */
    'transactionIntents'?: Array<PlayerResponseTransactionIntentsInner>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DeveloperAccountResponseExpandable = {
    TransactionIntents: 'transactionIntents'
} as const;

export type DeveloperAccountResponseExpandable = typeof DeveloperAccountResponseExpandable[keyof typeof DeveloperAccountResponseExpandable];


/**
 * 
 * @export
 * @interface DeviceListQueries
 */
export interface DeviceListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof DeviceListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof DeviceListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof DeviceListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the unique account ID (starts with acc_)
     * @type {string}
     * @memberof DeviceListQueries
     */
    'account': string;
}


/**
 * 
 * @export
 * @interface DeviceResponse
 */
export interface DeviceResponse {
    /**
     * 
     * @type {string}
     * @memberof DeviceResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeDEVICE}
     * @memberof DeviceResponse
     */
    'object': EntityTypeDEVICE;
    /**
     * 
     * @type {number}
     * @memberof DeviceResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof DeviceResponse
     */
    'accountID': string;
}


/**
 * 
 * @export
 * @interface DomainData
 */
export interface DomainData {
    /**
     * The chain ID.
     * @type {number}
     * @memberof DomainData
     */
    'chainId': number;
    /**
     * 
     * @type {string}
     * @memberof DomainData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainData
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainData
     */
    'verifyingContract'?: string;
}
/**
 * 
 * @export
 * @interface EntityIdResponse
 */
export interface EntityIdResponse {
    /**
     * 
     * @type {string}
     * @memberof EntityIdResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeACCOUNT = {
    Account: 'account'
} as const;

export type EntityTypeACCOUNT = typeof EntityTypeACCOUNT[keyof typeof EntityTypeACCOUNT];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeCONTRACT = {
    Contract: 'contract'
} as const;

export type EntityTypeCONTRACT = typeof EntityTypeCONTRACT[keyof typeof EntityTypeCONTRACT];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeDEVELOPERACCOUNT = {
    DeveloperAccount: 'developerAccount'
} as const;

export type EntityTypeDEVELOPERACCOUNT = typeof EntityTypeDEVELOPERACCOUNT[keyof typeof EntityTypeDEVELOPERACCOUNT];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeDEVICE = {
    Device: 'device'
} as const;

export type EntityTypeDEVICE = typeof EntityTypeDEVICE[keyof typeof EntityTypeDEVICE];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeINVENTORY = {
    Inventory: 'inventory'
} as const;

export type EntityTypeINVENTORY = typeof EntityTypeINVENTORY[keyof typeof EntityTypeINVENTORY];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeNOTIFICATION = {
    Notification: 'notification'
} as const;

export type EntityTypeNOTIFICATION = typeof EntityTypeNOTIFICATION[keyof typeof EntityTypeNOTIFICATION];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeNOTIFICATIONSUBSCRIPTION = {
    NotificationSubscription: 'notificationSubscription'
} as const;

export type EntityTypeNOTIFICATIONSUBSCRIPTION = typeof EntityTypeNOTIFICATIONSUBSCRIPTION[keyof typeof EntityTypeNOTIFICATIONSUBSCRIPTION];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeNOTIFICATIONTRIGGER = {
    NotificationTrigger: 'notificationTrigger'
} as const;

export type EntityTypeNOTIFICATIONTRIGGER = typeof EntityTypeNOTIFICATIONTRIGGER[keyof typeof EntityTypeNOTIFICATIONTRIGGER];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypePLAYER = {
    Player: 'player'
} as const;

export type EntityTypePLAYER = typeof EntityTypePLAYER[keyof typeof EntityTypePLAYER];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypePOLICY = {
    Policy: 'policy'
} as const;

export type EntityTypePOLICY = typeof EntityTypePOLICY[keyof typeof EntityTypePOLICY];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypePOLICYRULE = {
    PolicyRule: 'policyRule'
} as const;

export type EntityTypePOLICYRULE = typeof EntityTypePOLICYRULE[keyof typeof EntityTypePOLICYRULE];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypePROJECT = {
    Project: 'project'
} as const;

export type EntityTypePROJECT = typeof EntityTypePROJECT[keyof typeof EntityTypePROJECT];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeREADCONTRACT = {
    ReadContract: 'readContract'
} as const;

export type EntityTypeREADCONTRACT = typeof EntityTypeREADCONTRACT[keyof typeof EntityTypeREADCONTRACT];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeSESSION = {
    Session: 'session'
} as const;

export type EntityTypeSESSION = typeof EntityTypeSESSION[keyof typeof EntityTypeSESSION];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeSHARE = {
    Share: 'share'
} as const;

export type EntityTypeSHARE = typeof EntityTypeSHARE[keyof typeof EntityTypeSHARE];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeSIGNATURE = {
    Signature: 'signature'
} as const;

export type EntityTypeSIGNATURE = typeof EntityTypeSIGNATURE[keyof typeof EntityTypeSIGNATURE];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeTRANSACTIONINTENT = {
    TransactionIntent: 'transactionIntent'
} as const;

export type EntityTypeTRANSACTIONINTENT = typeof EntityTypeTRANSACTIONINTENT[keyof typeof EntityTypeTRANSACTIONINTENT];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeUSER = {
    User: 'user'
} as const;

export type EntityTypeUSER = typeof EntityTypeUSER[keyof typeof EntityTypeUSER];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeWEB3ACTION = {
    Web3Action: 'web3Action'
} as const;

export type EntityTypeWEB3ACTION = typeof EntityTypeWEB3ACTION[keyof typeof EntityTypeWEB3ACTION];


/**
 * 
 * @export
 * @enum {string}
 */

export const EntityTypeWEB3CONNECTION = {
    Web3Connection: 'web3Connection'
} as const;

export type EntityTypeWEB3CONNECTION = typeof EntityTypeWEB3CONNECTION[keyof typeof EntityTypeWEB3CONNECTION];


/**
 * 
 * @export
 * @enum {string}
 */

export const ErrorTypeINVALIDREQUESTERROR = {
    InvalidRequestError: 'invalid_request_error'
} as const;

export type ErrorTypeINVALIDREQUESTERROR = typeof ErrorTypeINVALIDREQUESTERROR[keyof typeof ErrorTypeINVALIDREQUESTERROR];


/**
 * return value from estimateTransactionIntentCost
 * @export
 * @interface EstimateTransactionIntentGasResult
 */
export interface EstimateTransactionIntentGasResult {
    /**
     * the preVerification gas used by this UserOperation.
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'preVerificationGas': string;
    /**
     * gas used for validation of this UserOperation, including account creation
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'verificationGas': string;
    /**
     * the deadline after which this UserOperation is invalid (not a gas estimation parameter, but returned by validation
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'validUntil'?: string;
    /**
     * the deadline after which this UserOperation is valid (not a gas estimation parameter, but returned by validation
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'validAfter'?: string;
    /**
     * estimated cost of calling the account with the given callData
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'callGasLimit': string;
    /**
     * returned by some bundlers (e.g. Biconomy\'s)
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'verificationGasLimit'?: string;
    /**
     * estimated TX gas cost
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'estimatedTXGas': string;
    /**
     * estimated TX gas cost in the chain native token (WEI)
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'estimatedTXGasFee': string;
    /**
     * estimated TX gas cost in USD
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'estimatedTXGasFeeUSD': string;
    /**
     * when using a policy, the estimated TX gas cost in the ERC-20 token defined in the strategy (WEI)
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'estimatedTXGasFeeToken'?: string;
    /**
     * gas price used for the estimation
     * @type {string}
     * @memberof EstimateTransactionIntentGasResult
     */
    'gasPrice': string;
}
/**
 * 
 * @export
 * @interface FieldErrorsValue
 */
export interface FieldErrorsValue {
    /**
     * 
     * @type {any}
     * @memberof FieldErrorsValue
     */
    'value'?: any;
    /**
     * 
     * @type {string}
     * @memberof FieldErrorsValue
     */
    'message': string;
}
/**
 * Firebase configuration
 * @export
 * @interface FirebaseOAuthConfig
 */
export interface FirebaseOAuthConfig {
    /**
     * Enable OAuth provider.
     * @type {boolean}
     * @memberof FirebaseOAuthConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {OAuthProviderFIREBASE}
     * @memberof FirebaseOAuthConfig
     */
    'provider': OAuthProviderFIREBASE;
    /**
     * Project ID of your Firebase service environment.
     * @type {string}
     * @memberof FirebaseOAuthConfig
     */
    'projectId': string;
}


/**
 * 
 * @export
 * @interface FixedRateTokenPolicyStrategy
 */
export interface FixedRateTokenPolicyStrategy {
    /**
     * 
     * @type {SponsorSchemaFIXEDRATE}
     * @memberof FixedRateTokenPolicyStrategy
     */
    'sponsorSchema': SponsorSchemaFIXEDRATE;
    /**
     * 
     * @type {string}
     * @memberof FixedRateTokenPolicyStrategy
     */
    'depositor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FixedRateTokenPolicyStrategy
     */
    'tokenContract': string;
    /**
     * 
     * @type {string}
     * @memberof FixedRateTokenPolicyStrategy
     */
    'tokenContractAmount': string;
}


/**
 * 
 * @export
 * @interface GasPerIntervalLimitPolicyRuleResponse
 */
export interface GasPerIntervalLimitPolicyRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {number}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {PolicyRuleTypeRATELIMIT}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'type': PolicyRuleTypeRATELIMIT;
    /**
     * 
     * @type {PolicyRateLimitGASPERINTERVAL}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'functionName': PolicyRateLimitGASPERINTERVAL;
    /**
     * 
     * @type {string}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'gasLimit': string;
    /**
     * 
     * @type {TimeIntervalType}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'timeIntervalType': TimeIntervalType;
    /**
     * 
     * @type {number}
     * @memberof GasPerIntervalLimitPolicyRuleResponse
     */
    'timeIntervalValue': number;
}


/**
 * 
 * @export
 * @interface GasPerTransactionLimitPolicyRuleResponse
 */
export interface GasPerTransactionLimitPolicyRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof GasPerTransactionLimitPolicyRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof GasPerTransactionLimitPolicyRuleResponse
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {number}
     * @memberof GasPerTransactionLimitPolicyRuleResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {PolicyRuleTypeRATELIMIT}
     * @memberof GasPerTransactionLimitPolicyRuleResponse
     */
    'type': PolicyRuleTypeRATELIMIT;
    /**
     * 
     * @type {PolicyRateLimitGASPERTRANSACTION}
     * @memberof GasPerTransactionLimitPolicyRuleResponse
     */
    'functionName': PolicyRateLimitGASPERTRANSACTION;
    /**
     * 
     * @type {string}
     * @memberof GasPerTransactionLimitPolicyRuleResponse
     */
    'gasLimit': string;
}


/**
 * 
 * @export
 * @interface GasReport
 */
export interface GasReport {
    /**
     * 
     * @type {MonthRange}
     * @memberof GasReport
     */
    'period': MonthRange;
    /**
     * 
     * @type {string}
     * @memberof GasReport
     */
    'averageTransactionFee': string;
    /**
     * 
     * @type {string}
     * @memberof GasReport
     */
    'totalTransactionFeeInCustomTokens': string;
    /**
     * 
     * @type {string}
     * @memberof GasReport
     */
    'totalTransactionFee': string;
    /**
     * 
     * @type {string}
     * @memberof GasReport
     */
    'totalTransactionFeeInUSD': string;
    /**
     * 
     * @type {Array<GasReportTransactionIntentsInner>}
     * @memberof GasReport
     */
    'transactionIntents': Array<GasReportTransactionIntentsInner>;
}
/**
 * 
 * @export
 * @interface GasReportListResponse
 */
export interface GasReportListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof GasReportListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof GasReportListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<GasReport>}
     * @memberof GasReportListResponse
     */
    'data': Array<GasReport>;
    /**
     * 
     * @type {number}
     * @memberof GasReportListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof GasReportListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof GasReportListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface GasReportTransactionIntentsInner
 */
export interface GasReportTransactionIntentsInner {
    /**
     * 
     * @type {string}
     * @memberof GasReportTransactionIntentsInner
     */
    'gasFeeInUSD': string;
    /**
     * 
     * @type {string}
     * @memberof GasReportTransactionIntentsInner
     */
    'gasUsed': string;
    /**
     * 
     * @type {string}
     * @memberof GasReportTransactionIntentsInner
     */
    'gasPrice': string;
    /**
     * 
     * @type {string}
     * @memberof GasReportTransactionIntentsInner
     */
    'gasFee': string;
    /**
     * 
     * @type {string}
     * @memberof GasReportTransactionIntentsInner
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface GetSigninUrlResponse
 */
export interface GetSigninUrlResponse {
    /**
     * 
     * @type {string}
     * @memberof GetSigninUrlResponse
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof GetSigninUrlResponse
     */
    'key': string;
}
/**
 * Google oauth configuration
 * @export
 * @interface GoogleOAuthConfig
 */
export interface GoogleOAuthConfig {
    /**
     * Enable OAuth provider.
     * @type {boolean}
     * @memberof GoogleOAuthConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {OAuthProviderGOOGLE}
     * @memberof GoogleOAuthConfig
     */
    'provider': OAuthProviderGOOGLE;
    /**
     * Google API client ID.
     * @type {string}
     * @memberof GoogleOAuthConfig
     */
    'clientId': string;
    /**
     * Google API client secret.
     * @type {string}
     * @memberof GoogleOAuthConfig
     */
    'clientSecret': string;
    /**
     * The URI to redirect to after completing the auth request. You can use Openfort redirect URL: https://openfort.xyz/iam/v1/oauth/google/callback
     * @type {string}
     * @memberof GoogleOAuthConfig
     */
    'redirectUri': string;
}


/**
 * 
 * @export
 * @interface Interaction
 */
export interface Interaction {
    /**
     * The address of the recipient of native tokens. Use *only* to transfer native tokens. If you provide one of a `pla_...`,  or `acc_...` it will be converted to the corresponding address.
     * @type {string}
     * @memberof Interaction
     */
    'to'?: string;
    /**
     * The value intended to be sent with the transaction. Should be a stringified number in WEI (i.e. factor 10^18). * @example \"1000000000000000000\"
     * @type {string}
     * @memberof Interaction
     */
    'value'?: string;
    /**
     * The contract ID you want to interact with. Must have been added to Openfort first, starts with `con_`.
     * @type {string}
     * @memberof Interaction
     */
    'contract'?: string;
    /**
     * The function name of the contract. Accepts a a function signature as well (e.g. mint(address)).
     * @type {string}
     * @memberof Interaction
     */
    'functionName'?: string;
    /**
     * The function arguments of the contract, in string format. If you provide one of a `pla_...`, `con_...` or `acc_...` it will be converted to the corresponding address.
     * @type {Array<any>}
     * @memberof Interaction
     */
    'functionArgs'?: Array<any>;
}
/**
 * 
 * @export
 * @interface InvalidRequestError
 */
export interface InvalidRequestError {
    /**
     * 
     * @type {ErrorTypeINVALIDREQUESTERROR}
     * @memberof InvalidRequestError
     */
    'type': ErrorTypeINVALIDREQUESTERROR;
    /**
     * 
     * @type {string}
     * @memberof InvalidRequestError
     */
    'message': string;
    /**
     * 
     * @type {{ [key: string]: FieldErrorsValue; }}
     * @memberof InvalidRequestError
     */
    'details'?: { [key: string]: FieldErrorsValue; };
}


/**
 * 
 * @export
 * @interface InvalidRequestErrorResponse
 */
export interface InvalidRequestErrorResponse {
    /**
     * 
     * @type {InvalidRequestError}
     * @memberof InvalidRequestErrorResponse
     */
    'error': InvalidRequestError;
}
/**
 * 
 * @export
 * @interface InventoryListResponse
 */
export interface InventoryListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof InventoryListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof InventoryListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<AssetInventory>}
     * @memberof InventoryListResponse
     */
    'data': Array<AssetInventory>;
    /**
     * 
     * @type {number}
     * @memberof InventoryListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof InventoryListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof InventoryListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface InventoryResponse
 */
export interface InventoryResponse {
    /**
     * 
     * @type {EntityTypeINVENTORY}
     * @memberof InventoryResponse
     */
    'object': EntityTypeINVENTORY;
    /**
     * 
     * @type {string}
     * @memberof InventoryResponse
     */
    'url': string;
    /**
     * 
     * @type {AssetInventory}
     * @memberof InventoryResponse
     */
    'data': AssetInventory;
}


/**
 * 
 * @export
 * @interface JwtKey
 */
export interface JwtKey {
    /**
     * 
     * @type {string}
     * @memberof JwtKey
     */
    'kty': string;
    /**
     * 
     * @type {string}
     * @memberof JwtKey
     */
    'x': string;
    /**
     * 
     * @type {string}
     * @memberof JwtKey
     */
    'y': string;
    /**
     * 
     * @type {string}
     * @memberof JwtKey
     */
    'crv': string;
    /**
     * 
     * @type {string}
     * @memberof JwtKey
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof JwtKey
     */
    'use': string;
    /**
     * 
     * @type {string}
     * @memberof JwtKey
     */
    'alg': string;
}
/**
 * 
 * @export
 * @interface JwtKeyResponse
 */
export interface JwtKeyResponse {
    /**
     * 
     * @type {Array<JwtKey>}
     * @memberof JwtKeyResponse
     */
    'keys': Array<JwtKey>;
}
/**
 * The request to verify access token
 * @export
 * @interface LinkRequest
 */
export interface LinkRequest {
    /**
     * 
     * @type {OAuthProvider}
     * @memberof LinkRequest
     */
    'provider': OAuthProvider;
    /**
     * external user id
     * @type {string}
     * @memberof LinkRequest
     */
    'externalUserId': string;
}


/**
 * 
 * @export
 * @interface LinkedAccountResponse
 */
export interface LinkedAccountResponse {
    /**
     * 
     * @type {AuthProvider}
     * @memberof LinkedAccountResponse
     */
    'provider': AuthProvider;
    /**
     * 
     * @type {string}
     * @memberof LinkedAccountResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkedAccountResponse
     */
    'externalUserId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LinkedAccountResponse
     */
    'disabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof LinkedAccountResponse
     */
    'updatedAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof LinkedAccountResponse
     */
    'address'?: string;
    /**
     * 
     * @type {PrismaInputJsonValue}
     * @memberof LinkedAccountResponse
     */
    'metadata'?: PrismaInputJsonValue;
}


/**
 * 
 * @export
 * @interface Log
 */
export interface Log {
    /**
     * 
     * @type {number}
     * @memberof Log
     */
    'blockNumber': number;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'blockHash': string;
    /**
     * 
     * @type {number}
     * @memberof Log
     */
    'transactionIndex': number;
    /**
     * 
     * @type {boolean}
     * @memberof Log
     */
    'removed': boolean;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'data': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Log
     */
    'topics': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    'transactionHash': string;
    /**
     * 
     * @type {number}
     * @memberof Log
     */
    'logIndex': number;
    /**
     * 
     * @type {boolean}
     * @memberof Log
     */
    'orphaned'?: boolean;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * The email address of the user.
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * The password of the user.
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LogoutRequest
 */
export interface LogoutRequest {
    /**
     * Specifies the refresh token.
     * @type {string}
     * @memberof LogoutRequest
     */
    'refreshToken': string;
}
/**
 * LootLocker oauth configuration
 * @export
 * @interface LootLockerOAuthConfig
 */
export interface LootLockerOAuthConfig {
    /**
     * Enable OAuth provider.
     * @type {boolean}
     * @memberof LootLockerOAuthConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {OAuthProviderLOOTLOCKER}
     * @memberof LootLockerOAuthConfig
     */
    'provider': OAuthProviderLOOTLOCKER;
}


/**
 * 
 * @export
 * @interface Money
 */
export interface Money {
    /**
     * Amount in cents
     * @type {number}
     * @memberof Money
     */
    'amount': number;
    /**
     * 
     * @type {Currency}
     * @memberof Money
     */
    'currency': Currency;
}


/**
 * 
 * @export
 * @interface MonthRange
 */
export interface MonthRange {
    /**
     * 
     * @type {number}
     * @memberof MonthRange
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof MonthRange
     */
    'end': number;
}
/**
 * 
 * @export
 * @interface NextActionPayload
 */
export interface NextActionPayload {
    /**
     * 
     * @type {any}
     * @memberof NextActionPayload
     * @deprecated
     */
    'userOp'?: any;
    /**
     * 
     * @type {string}
     * @memberof NextActionPayload
     * @deprecated
     */
    'userOpHash'?: string;
    /**
     * The userOperation.
     * @type {any}
     * @memberof NextActionPayload
     */
    'userOperation'?: any;
    /**
     * The hashed userOperation.
     * @type {string}
     * @memberof NextActionPayload
     */
    'userOperationHash'?: string;
}
/**
 * 
 * @export
 * @interface NextActionResponse
 */
export interface NextActionResponse {
    /**
     * 
     * @type {NextActionType}
     * @memberof NextActionResponse
     */
    'type': NextActionType;
    /**
     * 
     * @type {NextActionPayload}
     * @memberof NextActionResponse
     */
    'payload': NextActionPayload;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const NextActionType = {
    SignWithWallet: 'sign_with_wallet'
} as const;

export type NextActionType = typeof NextActionType[keyof typeof NextActionType];


/**
 * 
 * @export
 * @interface NotificationDeleteResponse
 */
export interface NotificationDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof NotificationDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeNOTIFICATION}
     * @memberof NotificationDeleteResponse
     */
    'object': EntityTypeNOTIFICATION;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface NotificationListQueries
 */
export interface NotificationListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof NotificationListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof NotificationListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof NotificationListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the fields to expand in the response.
     * @type {Array<NotificationResponseExpandable>}
     * @memberof NotificationListQueries
     */
    'expand'?: Array<NotificationResponseExpandable>;
    /**
     * Specifies whether to include deleted notifications.
     * @type {boolean}
     * @memberof NotificationListQueries
     */
    'deleted'?: boolean;
    /**
     * Specifies the name of the notifications.
     * @type {string}
     * @memberof NotificationListQueries
     */
    'name'?: string;
}


/**
 * 
 * @export
 * @interface NotificationListResponse
 */
export interface NotificationListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof NotificationListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof NotificationListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<NotificationResponse>}
     * @memberof NotificationListResponse
     */
    'data': Array<NotificationResponse>;
    /**
     * 
     * @type {number}
     * @memberof NotificationListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface NotificationResponse
 */
export interface NotificationResponse {
    /**
     * 
     * @type {string}
     * @memberof NotificationResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeNOTIFICATION}
     * @memberof NotificationResponse
     */
    'object': EntityTypeNOTIFICATION;
    /**
     * 
     * @type {number}
     * @memberof NotificationResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof NotificationResponse
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationResponse
     */
    'deleted': boolean;
    /**
     * 
     * @type {number}
     * @memberof NotificationResponse
     */
    'updatedAt': number;
    /**
     * 
     * @type {Array<NotificationResponseSubscriptionsInner>}
     * @memberof NotificationResponse
     */
    'subscriptions'?: Array<NotificationResponseSubscriptionsInner>;
    /**
     * 
     * @type {Array<NotificationResponseTriggersInner>}
     * @memberof NotificationResponse
     */
    'triggers'?: Array<NotificationResponseTriggersInner>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationResponseExpandable = {
    Subscriptions: 'subscriptions',
    Triggers: 'triggers'
} as const;

export type NotificationResponseExpandable = typeof NotificationResponseExpandable[keyof typeof NotificationResponseExpandable];


/**
 * 
 * @export
 * @interface NotificationResponseSubscriptionsInner
 */
export interface NotificationResponseSubscriptionsInner {
    /**
     * 
     * @type {string}
     * @memberof NotificationResponseSubscriptionsInner
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeNOTIFICATIONSUBSCRIPTION}
     * @memberof NotificationResponseSubscriptionsInner
     */
    'object': EntityTypeNOTIFICATIONSUBSCRIPTION;
    /**
     * 
     * @type {number}
     * @memberof NotificationResponseSubscriptionsInner
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof NotificationResponseSubscriptionsInner
     */
    'target': string;
    /**
     * 
     * @type {SubscriptionType}
     * @memberof NotificationResponseSubscriptionsInner
     */
    'method': SubscriptionType;
}


/**
 * 
 * @export
 * @interface NotificationResponseTriggersInner
 */
export interface NotificationResponseTriggersInner {
    /**
     * 
     * @type {string}
     * @memberof NotificationResponseTriggersInner
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeNOTIFICATIONTRIGGER}
     * @memberof NotificationResponseTriggersInner
     */
    'object': EntityTypeNOTIFICATIONTRIGGER;
    /**
     * 
     * @type {number}
     * @memberof NotificationResponseTriggersInner
     */
    'createdAt': number;
    /**
     * 
     * @type {NotificationTriggerTypePROJECTBALANCETRIGGER}
     * @memberof NotificationResponseTriggersInner
     */
    'type': NotificationTriggerTypePROJECTBALANCETRIGGER;
    /**
     * 
     * @type {string}
     * @memberof NotificationResponseTriggersInner
     */
    'threshold': string;
    /**
     * 
     * @type {ContractNotificationTriggerResponseContract}
     * @memberof NotificationResponseTriggersInner
     */
    'contract': ContractNotificationTriggerResponseContract;
    /**
     * 
     * @type {string}
     * @memberof NotificationResponseTriggersInner
     */
    'functionName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NotificationResponseTriggersInner
     */
    'functionArgs': Array<string>;
    /**
     * 
     * @type {AccountNotificationTriggerResponseAccount}
     * @memberof NotificationResponseTriggersInner
     */
    'account': AccountNotificationTriggerResponseAccount;
    /**
     * 
     * @type {number}
     * @memberof NotificationResponseTriggersInner
     */
    'chainId': number;
}


/**
 * 
 * @export
 * @interface NotificationSubscription
 */
export interface NotificationSubscription {
    /**
     * 
     * @type {string}
     * @memberof NotificationSubscription
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeNOTIFICATIONSUBSCRIPTION}
     * @memberof NotificationSubscription
     */
    'object': EntityTypeNOTIFICATIONSUBSCRIPTION;
    /**
     * 
     * @type {number}
     * @memberof NotificationSubscription
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof NotificationSubscription
     */
    'target': string;
    /**
     * 
     * @type {SubscriptionType}
     * @memberof NotificationSubscription
     */
    'method': SubscriptionType;
}


/**
 * 
 * @export
 * @interface NotificationSubscriptionDeleteResponse
 */
export interface NotificationSubscriptionDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof NotificationSubscriptionDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeNOTIFICATIONSUBSCRIPTION}
     * @memberof NotificationSubscriptionDeleteResponse
     */
    'object': EntityTypeNOTIFICATIONSUBSCRIPTION;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSubscriptionDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface NotificationSubscriptionListQueries
 */
export interface NotificationSubscriptionListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof NotificationSubscriptionListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof NotificationSubscriptionListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof NotificationSubscriptionListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the unique notification ID (starts with not_).
     * @type {string}
     * @memberof NotificationSubscriptionListQueries
     */
    'notification': string;
}


/**
 * 
 * @export
 * @interface NotificationSubscriptionListResponse
 */
export interface NotificationSubscriptionListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof NotificationSubscriptionListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof NotificationSubscriptionListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<NotificationSubscription>}
     * @memberof NotificationSubscriptionListResponse
     */
    'data': Array<NotificationSubscription>;
    /**
     * 
     * @type {number}
     * @memberof NotificationSubscriptionListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationSubscriptionListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationSubscriptionListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface NotificationTriggerDeleteResponse
 */
export interface NotificationTriggerDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof NotificationTriggerDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeNOTIFICATIONTRIGGER}
     * @memberof NotificationTriggerDeleteResponse
     */
    'object': EntityTypeNOTIFICATIONTRIGGER;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationTriggerDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface NotificationTriggerListQueries
 */
export interface NotificationTriggerListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof NotificationTriggerListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof NotificationTriggerListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof NotificationTriggerListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the unique notification ID (starts with not_).
     * @type {string}
     * @memberof NotificationTriggerListQueries
     */
    'notification': string;
}


/**
 * 
 * @export
 * @interface NotificationTriggerListResponse
 */
export interface NotificationTriggerListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof NotificationTriggerListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof NotificationTriggerListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<NotificationTriggerResponse>}
     * @memberof NotificationTriggerListResponse
     */
    'data': Array<NotificationTriggerResponse>;
    /**
     * 
     * @type {number}
     * @memberof NotificationTriggerListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationTriggerListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationTriggerListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface NotificationTriggerResponse
 */
export interface NotificationTriggerResponse {
    /**
     * 
     * @type {string}
     * @memberof NotificationTriggerResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeNOTIFICATIONTRIGGER}
     * @memberof NotificationTriggerResponse
     */
    'object': EntityTypeNOTIFICATIONTRIGGER;
    /**
     * 
     * @type {number}
     * @memberof NotificationTriggerResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {NotificationTriggerTypePROJECTBALANCETRIGGER}
     * @memberof NotificationTriggerResponse
     */
    'type': NotificationTriggerTypePROJECTBALANCETRIGGER;
    /**
     * 
     * @type {string}
     * @memberof NotificationTriggerResponse
     */
    'threshold': string;
    /**
     * 
     * @type {ContractNotificationTriggerResponseContract}
     * @memberof NotificationTriggerResponse
     */
    'contract': ContractNotificationTriggerResponseContract;
    /**
     * 
     * @type {string}
     * @memberof NotificationTriggerResponse
     */
    'functionName': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NotificationTriggerResponse
     */
    'functionArgs': Array<string>;
    /**
     * 
     * @type {AccountNotificationTriggerResponseAccount}
     * @memberof NotificationTriggerResponse
     */
    'account': AccountNotificationTriggerResponseAccount;
    /**
     * 
     * @type {number}
     * @memberof NotificationTriggerResponse
     */
    'chainId': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationTriggerType = {
    ContractTrigger: 'contract_trigger',
    DeveloperAccountTrigger: 'developer_account_trigger',
    ProjectBalanceTrigger: 'project_balance_trigger'
} as const;

export type NotificationTriggerType = typeof NotificationTriggerType[keyof typeof NotificationTriggerType];


/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationTriggerTypeCONTRACTTRIGGER = {
    ContractTrigger: 'contract_trigger'
} as const;

export type NotificationTriggerTypeCONTRACTTRIGGER = typeof NotificationTriggerTypeCONTRACTTRIGGER[keyof typeof NotificationTriggerTypeCONTRACTTRIGGER];


/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationTriggerTypeDEVELOPERACCOUNTTRIGGER = {
    DeveloperAccountTrigger: 'developer_account_trigger'
} as const;

export type NotificationTriggerTypeDEVELOPERACCOUNTTRIGGER = typeof NotificationTriggerTypeDEVELOPERACCOUNTTRIGGER[keyof typeof NotificationTriggerTypeDEVELOPERACCOUNTTRIGGER];


/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationTriggerTypePROJECTBALANCETRIGGER = {
    ProjectBalanceTrigger: 'project_balance_trigger'
} as const;

export type NotificationTriggerTypePROJECTBALANCETRIGGER = typeof NotificationTriggerTypePROJECTBALANCETRIGGER[keyof typeof NotificationTriggerTypePROJECTBALANCETRIGGER];


/**
 * 
 * @export
 * @interface OAuthConfig
 */
export interface OAuthConfig {
    /**
     * Enable OAuth provider.
     * @type {boolean}
     * @memberof OAuthConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {OAuthProviderLOOTLOCKER}
     * @memberof OAuthConfig
     */
    'provider': OAuthProviderLOOTLOCKER;
    /**
     * Base URI of your accelbyte gaming service environment. E.g. https://mygame.dev.gamingservices.accelbyte.io/
     * @type {string}
     * @memberof OAuthConfig
     */
    'baseUrl': string;
    /**
     * Google API client ID.
     * @type {string}
     * @memberof OAuthConfig
     */
    'clientId': string;
    /**
     * Google API client secret.
     * @type {string}
     * @memberof OAuthConfig
     */
    'clientSecret': string;
    /**
     * The URI to redirect to after completing the auth request. You can use Openfort redirect URL: https://openfort.xyz/iam/v1/oauth/google/callback
     * @type {string}
     * @memberof OAuthConfig
     */
    'redirectUri': string;
    /**
     * Title ID of your Play Fab gaming service environment.
     * @type {string}
     * @memberof OAuthConfig
     */
    'titleId': string;
    /**
     * Project ID of your Firebase service environment.
     * @type {string}
     * @memberof OAuthConfig
     */
    'projectId': string;
}


/**
 * Response for the OAuth config list method.
 * @export
 * @interface OAuthConfigListResponse
 */
export interface OAuthConfigListResponse {
    /**
     * List of the OAuth providers configurations
     * @type {Array<OAuthConfig>}
     * @memberof OAuthConfigListResponse
     */
    'data': Array<OAuthConfig>;
}
/**
 * 
 * @export
 * @interface OAuthInitRequest
 */
export interface OAuthInitRequest {
    /**
     * Access token to be verified
     * @type {string}
     * @memberof OAuthInitRequest
     */
    'token': string;
    /**
     * 
     * @type {OAuthProvider}
     * @memberof OAuthInitRequest
     */
    'provider': OAuthProvider;
}


/**
 * Enum of the supporting OAuth providers.
 * @export
 * @enum {string}
 */

export const OAuthProvider = {
    Accelbyte: 'accelbyte',
    Firebase: 'firebase',
    Google: 'google',
    Lootlocker: 'lootlocker',
    Playfab: 'playfab'
} as const;

export type OAuthProvider = typeof OAuthProvider[keyof typeof OAuthProvider];


/**
 * 
 * @export
 * @enum {string}
 */

export const OAuthProviderACCELBYTE = {
    Accelbyte: 'accelbyte'
} as const;

export type OAuthProviderACCELBYTE = typeof OAuthProviderACCELBYTE[keyof typeof OAuthProviderACCELBYTE];


/**
 * 
 * @export
 * @enum {string}
 */

export const OAuthProviderFIREBASE = {
    Firebase: 'firebase'
} as const;

export type OAuthProviderFIREBASE = typeof OAuthProviderFIREBASE[keyof typeof OAuthProviderFIREBASE];


/**
 * 
 * @export
 * @enum {string}
 */

export const OAuthProviderGOOGLE = {
    Google: 'google'
} as const;

export type OAuthProviderGOOGLE = typeof OAuthProviderGOOGLE[keyof typeof OAuthProviderGOOGLE];


/**
 * 
 * @export
 * @enum {string}
 */

export const OAuthProviderLOOTLOCKER = {
    Lootlocker: 'lootlocker'
} as const;

export type OAuthProviderLOOTLOCKER = typeof OAuthProviderLOOTLOCKER[keyof typeof OAuthProviderLOOTLOCKER];


/**
 * 
 * @export
 * @enum {string}
 */

export const OAuthProviderPLAYFAB = {
    Playfab: 'playfab'
} as const;

export type OAuthProviderPLAYFAB = typeof OAuthProviderPLAYFAB[keyof typeof OAuthProviderPLAYFAB];


/**
 * The request to verify access token
 * @export
 * @interface OAuthRequest
 */
export interface OAuthRequest {
    /**
     * Access token to be verified
     * @type {string}
     * @memberof OAuthRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface PayForUserPolicyStrategy
 */
export interface PayForUserPolicyStrategy {
    /**
     * 
     * @type {SponsorSchemaPAYFORUSER}
     * @memberof PayForUserPolicyStrategy
     */
    'sponsorSchema': SponsorSchemaPAYFORUSER;
    /**
     * 
     * @type {string}
     * @memberof PayForUserPolicyStrategy
     */
    'depositor'?: string | null;
}


/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickContractResponseId
 */
export interface PickContractResponseId {
    /**
     * 
     * @type {string}
     * @memberof PickContractResponseId
     */
    'id': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickDeveloperAccountId
 */
export interface PickDeveloperAccountId {
    /**
     * 
     * @type {string}
     * @memberof PickDeveloperAccountId
     */
    'id': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPlayerResponseId
 */
export interface PickPlayerResponseId {
    /**
     * 
     * @type {string}
     * @memberof PickPlayerResponseId
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface Plan
 */
export interface Plan {
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Plan
     */
    'price': number;
    /**
     * 
     * @type {boolean}
     * @memberof Plan
     */
    'is_current': boolean;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    'change_type': PlanChangeTypeEnum;
}

export const PlanChangeTypeEnum = {
    Upgrade: 'upgrade',
    Downgrade: 'downgrade',
    None: 'none'
} as const;

export type PlanChangeTypeEnum = typeof PlanChangeTypeEnum[keyof typeof PlanChangeTypeEnum];

/**
 * 
 * @export
 * @interface PlansResponse
 */
export interface PlansResponse {
    /**
     * 
     * @type {Array<Plan>}
     * @memberof PlansResponse
     */
    'plans': Array<Plan>;
}
/**
 * PlayFab oauth configuration
 * @export
 * @interface PlayFabOAuthConfig
 */
export interface PlayFabOAuthConfig {
    /**
     * Enable OAuth provider.
     * @type {boolean}
     * @memberof PlayFabOAuthConfig
     */
    'enabled': boolean;
    /**
     * 
     * @type {OAuthProviderPLAYFAB}
     * @memberof PlayFabOAuthConfig
     */
    'provider': OAuthProviderPLAYFAB;
    /**
     * Title ID of your Play Fab gaming service environment.
     * @type {string}
     * @memberof PlayFabOAuthConfig
     */
    'titleId': string;
}


/**
 * 
 * @export
 * @interface Player
 */
export interface Player {
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePLAYER}
     * @memberof Player
     */
    'object': EntityTypePLAYER;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: PlayerMetadataValue; }}
     * @memberof Player
     */
    'metadata'?: { [key: string]: PlayerMetadataValue; };
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof Player
     */
    'transactionIntents'?: Array<EntityIdResponse>;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof Player
     */
    'accounts'?: Array<EntityIdResponse>;
}


/**
 * 
 * @export
 * @interface PlayerCancelTransferOwnershipRequest
 */
export interface PlayerCancelTransferOwnershipRequest {
    /**
     * ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). A policy must be provided.
     * @type {string}
     * @memberof PlayerCancelTransferOwnershipRequest
     */
    'policy': string;
    /**
     * The chain ID. Must be a [supported chain](/chains).
     * @type {number}
     * @memberof PlayerCancelTransferOwnershipRequest
     */
    'chainId': number;
}
/**
 * 
 * @export
 * @interface PlayerCreateRequest
 */
export interface PlayerCreateRequest {
    /**
     * Specifies the player name.
     * @type {string}
     * @memberof PlayerCreateRequest
     */
    'name'?: string;
    /**
     * Specifies the player description.
     * @type {string}
     * @memberof PlayerCreateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: PlayerMetadataValue; }}
     * @memberof PlayerCreateRequest
     */
    'metadata'?: { [key: string]: PlayerMetadataValue; };
}
/**
 * 
 * @export
 * @interface PlayerDeleteResponse
 */
export interface PlayerDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof PlayerDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePLAYER}
     * @memberof PlayerDeleteResponse
     */
    'object': EntityTypePLAYER;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface PlayerInventoryListQueries
 */
export interface PlayerInventoryListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof PlayerInventoryListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof PlayerInventoryListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof PlayerInventoryListQueries
     */
    'order'?: SortOrder;
    /**
     * Filter by contract ID (starts with con_).
     * @type {Array<string>}
     * @memberof PlayerInventoryListQueries
     */
    'contract'?: Array<string>;
    /**
     * Filter by chain id.
     * @type {number}
     * @memberof PlayerInventoryListQueries
     */
    'chainId': number;
}


/**
 * 
 * @export
 * @interface PlayerInventoryQueries
 */
export interface PlayerInventoryQueries {
    /**
     * Filter by chain id.
     * @type {number}
     * @memberof PlayerInventoryQueries
     */
    'chainId': number;
}
/**
 * 
 * @export
 * @interface PlayerListQueries
 */
export interface PlayerListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof PlayerListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof PlayerListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof PlayerListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the fields to expand in the response.
     * @type {Array<PlayerResponseExpandable>}
     * @memberof PlayerListQueries
     */
    'expand'?: Array<PlayerResponseExpandable>;
    /**
     * Filter by player name.
     * @type {string}
     * @memberof PlayerListQueries
     */
    'name'?: string;
}


/**
 * 
 * @export
 * @interface PlayerListResponse
 */
export interface PlayerListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof PlayerListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof PlayerListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<PlayerResponse>}
     * @memberof PlayerListResponse
     */
    'data': Array<PlayerResponse>;
    /**
     * 
     * @type {number}
     * @memberof PlayerListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface PlayerMetadataValue
 */
export interface PlayerMetadataValue {
}
/**
 * 
 * @export
 * @interface PlayerResponse
 */
export interface PlayerResponse {
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePLAYER}
     * @memberof PlayerResponse
     */
    'object': EntityTypePLAYER;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponse
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: PlayerMetadataValue; }}
     * @memberof PlayerResponse
     */
    'metadata'?: { [key: string]: PlayerMetadataValue; };
    /**
     * 
     * @type {Array<PlayerResponseTransactionIntentsInner>}
     * @memberof PlayerResponse
     */
    'transactionIntents'?: Array<PlayerResponseTransactionIntentsInner>;
    /**
     * 
     * @type {Array<PlayerResponseAccountsInner>}
     * @memberof PlayerResponse
     */
    'accounts'?: Array<PlayerResponseAccountsInner>;
}


/**
 * 
 * @export
 * @interface PlayerResponseAccountsInner
 */
export interface PlayerResponseAccountsInner {
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseAccountsInner
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeACCOUNT}
     * @memberof PlayerResponseAccountsInner
     */
    'object': EntityTypeACCOUNT;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseAccountsInner
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseAccountsInner
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseAccountsInner
     */
    'ownerAddress': string;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerResponseAccountsInner
     */
    'deployed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerResponseAccountsInner
     */
    'custodial': boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof PlayerResponseAccountsInner
     */
    'chainId': number;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseAccountsInner
     */
    'accountType': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseAccountsInner
     */
    'pendingOwnerAddress'?: string;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof PlayerResponseAccountsInner
     */
    'transactionIntents'?: Array<EntityIdResponse>;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof PlayerResponseAccountsInner
     */
    'player': EntityIdResponse;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PlayerResponseExpandable = {
    TransactionIntents: 'transactionIntents',
    Accounts: 'accounts'
} as const;

export type PlayerResponseExpandable = typeof PlayerResponseExpandable[keyof typeof PlayerResponseExpandable];


/**
 * 
 * @export
 * @interface PlayerResponseTransactionIntentsInner
 */
export interface PlayerResponseTransactionIntentsInner {
    /**
     * 
     * @type {string}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeTRANSACTIONINTENT}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'object': EntityTypeTRANSACTIONINTENT;
    /**
     * 
     * @type {number}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'createdAt': number;
    /**
     * The unix timestamp in seconds when the transactionIntent was created.
     * @type {number}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'updatedAt': number;
    /**
     * The chain ID.
     * @type {number}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'chainId': number;
    /**
     * The hashed userOperation.
     * @type {string}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'userOperationHash'?: string;
    /**
     * 
     * @type {any}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'userOperation'?: any;
    /**
     * 
     * @type {ResponseResponse}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'response'?: ResponseResponse;
    /**
     * 
     * @type {Array<Interaction>}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'interactions'?: Array<Interaction>;
    /**
     * 
     * @type {NextActionResponse}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'nextAction'?: NextActionResponse;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'policy'?: EntityIdResponse;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'player'?: EntityIdResponse;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof PlayerResponseTransactionIntentsInner
     */
    'account': EntityIdResponse;
}


/**
 * 
 * @export
 * @interface PlayerTransferOwnershipRequest
 */
export interface PlayerTransferOwnershipRequest {
    /**
     * ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). A policy must be provided.
     * @type {string}
     * @memberof PlayerTransferOwnershipRequest
     */
    'policy': string;
    /**
     * The chain ID. Must be a [supported chain](/chains).
     * @type {number}
     * @memberof PlayerTransferOwnershipRequest
     */
    'chainId': number;
    /**
     * The address of the new owner
     * @type {string}
     * @memberof PlayerTransferOwnershipRequest
     */
    'newOwnerAddress': string;
    /**
     * ID of the Player that has the Account you want to transfer ownership from (starts with `pla_`).
     * @type {string}
     * @memberof PlayerTransferOwnershipRequest
     */
    'player'?: string;
}
/**
 * 
 * @export
 * @interface PlayerUpdateRequest
 */
export interface PlayerUpdateRequest {
    /**
     * Specifies the player name.
     * @type {string}
     * @memberof PlayerUpdateRequest
     */
    'name'?: string;
    /**
     * Specifies the player description.
     * @type {string}
     * @memberof PlayerUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: PlayerMetadataValue; }}
     * @memberof PlayerUpdateRequest
     */
    'metadata'?: { [key: string]: PlayerMetadataValue; };
}
/**
 * 
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICY}
     * @memberof Policy
     */
    'object': EntityTypePOLICY;
    /**
     * 
     * @type {number}
     * @memberof Policy
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    'name': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Policy
     */
    'deleted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Policy
     */
    'enabled': boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof Policy
     */
    'chainId': number;
    /**
     * 
     * @type {PolicyStrategy}
     * @memberof Policy
     */
    'strategy': PolicyStrategy;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof Policy
     */
    'transactionIntents': Array<EntityIdResponse>;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof Policy
     */
    'policyRules': Array<EntityIdResponse>;
}


/**
 * 
 * @export
 * @interface PolicyBalanceWithdrawResponse
 */
export interface PolicyBalanceWithdrawResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyBalanceWithdrawResponse
     */
    'policy': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyBalanceWithdrawResponse
     */
    'balance': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyBalanceWithdrawResponse
     */
    'contract': string;
}
/**
 * 
 * @export
 * @interface PolicyDeleteResponse
 */
export interface PolicyDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICY}
     * @memberof PolicyDeleteResponse
     */
    'object': EntityTypePOLICY;
    /**
     * 
     * @type {boolean}
     * @memberof PolicyDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface PolicyListQueries
 */
export interface PolicyListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof PolicyListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof PolicyListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof PolicyListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the fields to expand in the response.
     * @type {Array<PolicyResponseExpandable>}
     * @memberof PolicyListQueries
     */
    'expand'?: Array<PolicyResponseExpandable>;
    /**
     * Specifies the name of the policy.
     * @type {string}
     * @memberof PolicyListQueries
     */
    'name'?: string;
    /**
     * Specifies whether to include deleted policies.
     * @type {boolean}
     * @memberof PolicyListQueries
     */
    'deleted'?: boolean;
    /**
     * The chain ID of the policy.
     * @type {number}
     * @memberof PolicyListQueries
     */
    'chainId'?: number;
    /**
     * Specifies whether to include enabled policies.
     * @type {boolean}
     * @memberof PolicyListQueries
     */
    'enabled'?: boolean;
}


/**
 * 
 * @export
 * @interface PolicyListResponse
 */
export interface PolicyListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof PolicyListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof PolicyListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<PolicyResponse>}
     * @memberof PolicyListResponse
     */
    'data': Array<PolicyResponse>;
    /**
     * 
     * @type {number}
     * @memberof PolicyListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRateLimit = {
    GasPerTransaction: 'gas_per_transaction',
    GasPerInterval: 'gas_per_interval',
    CountPerInterval: 'count_per_interval'
} as const;

export type PolicyRateLimit = typeof PolicyRateLimit[keyof typeof PolicyRateLimit];


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRateLimitCOUNTPERINTERVAL = {
    CountPerInterval: 'count_per_interval'
} as const;

export type PolicyRateLimitCOUNTPERINTERVAL = typeof PolicyRateLimitCOUNTPERINTERVAL[keyof typeof PolicyRateLimitCOUNTPERINTERVAL];


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRateLimitGASPERINTERVAL = {
    GasPerInterval: 'gas_per_interval'
} as const;

export type PolicyRateLimitGASPERINTERVAL = typeof PolicyRateLimitGASPERINTERVAL[keyof typeof PolicyRateLimitGASPERINTERVAL];


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRateLimitGASPERTRANSACTION = {
    GasPerTransaction: 'gas_per_transaction'
} as const;

export type PolicyRateLimitGASPERTRANSACTION = typeof PolicyRateLimitGASPERTRANSACTION[keyof typeof PolicyRateLimitGASPERTRANSACTION];


/**
 * 
 * @export
 * @interface PolicyResponse
 */
export interface PolicyResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICY}
     * @memberof PolicyResponse
     */
    'object': EntityTypePOLICY;
    /**
     * 
     * @type {number}
     * @memberof PolicyResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof PolicyResponse
     */
    'name': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PolicyResponse
     */
    'deleted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PolicyResponse
     */
    'enabled': boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof PolicyResponse
     */
    'chainId': number;
    /**
     * 
     * @type {PolicyStrategy}
     * @memberof PolicyResponse
     */
    'strategy': PolicyStrategy;
    /**
     * 
     * @type {Array<PlayerResponseTransactionIntentsInner>}
     * @memberof PolicyResponse
     */
    'transactionIntents': Array<PlayerResponseTransactionIntentsInner>;
    /**
     * 
     * @type {Array<PolicyResponsePolicyRulesInner>}
     * @memberof PolicyResponse
     */
    'policyRules': Array<PolicyResponsePolicyRulesInner>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyResponseExpandable = {
    TransactionIntents: 'transactionIntents',
    PolicyRules: 'policyRules'
} as const;

export type PolicyResponseExpandable = typeof PolicyResponseExpandable[keyof typeof PolicyResponseExpandable];


/**
 * 
 * @export
 * @interface PolicyResponsePolicyRulesInner
 */
export interface PolicyResponsePolicyRulesInner {
    /**
     * 
     * @type {string}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {number}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'createdAt': number;
    /**
     * 
     * @type {PolicyRuleTypeRATELIMIT}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'type': PolicyRuleTypeRATELIMIT;
    /**
     * 
     * @type {ContractNotificationTriggerResponseContract}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'contract': ContractNotificationTriggerResponseContract;
    /**
     * 
     * @type {PolicyRateLimitCOUNTPERINTERVAL}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'functionName': PolicyRateLimitCOUNTPERINTERVAL;
    /**
     * 
     * @type {string}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'gasLimit': string;
    /**
     * 
     * @type {TimeIntervalType}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'timeIntervalType': TimeIntervalType;
    /**
     * 
     * @type {number}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'timeIntervalValue': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyResponsePolicyRulesInner
     */
    'countLimit': number;
}


/**
 * 
 * @export
 * @interface PolicyRuleDeleteResponse
 */
export interface PolicyRuleDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof PolicyRuleDeleteResponse
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {boolean}
     * @memberof PolicyRuleDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface PolicyRuleListQueries
 */
export interface PolicyRuleListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof PolicyRuleListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof PolicyRuleListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof PolicyRuleListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the fields to expand in the response.
     * @type {Array<string>}
     * @memberof PolicyRuleListQueries
     */
    'expand'?: Array<PolicyRuleListQueriesExpandEnum>;
    /**
     * Specifies the unique policy ID (starts with pol_).
     * @type {string}
     * @memberof PolicyRuleListQueries
     */
    'policy': string;
}

export const PolicyRuleListQueriesExpandEnum = {
    Contract: 'contract'
} as const;

export type PolicyRuleListQueriesExpandEnum = typeof PolicyRuleListQueriesExpandEnum[keyof typeof PolicyRuleListQueriesExpandEnum];

/**
 * 
 * @export
 * @interface PolicyRuleListResponse
 */
export interface PolicyRuleListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof PolicyRuleListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<PolicyRuleResponse>}
     * @memberof PolicyRuleListResponse
     */
    'data': Array<PolicyRuleResponse>;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface PolicyRuleResponse
 */
export interface PolicyRuleResponse {
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICYRULE}
     * @memberof PolicyRuleResponse
     */
    'object': EntityTypePOLICYRULE;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {PolicyRuleTypeRATELIMIT}
     * @memberof PolicyRuleResponse
     */
    'type': PolicyRuleTypeRATELIMIT;
    /**
     * 
     * @type {ContractNotificationTriggerResponseContract}
     * @memberof PolicyRuleResponse
     */
    'contract': ContractNotificationTriggerResponseContract;
    /**
     * 
     * @type {PolicyRateLimitCOUNTPERINTERVAL}
     * @memberof PolicyRuleResponse
     */
    'functionName': PolicyRateLimitCOUNTPERINTERVAL;
    /**
     * 
     * @type {string}
     * @memberof PolicyRuleResponse
     */
    'gasLimit': string;
    /**
     * 
     * @type {TimeIntervalType}
     * @memberof PolicyRuleResponse
     */
    'timeIntervalType': TimeIntervalType;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleResponse
     */
    'timeIntervalValue': number;
    /**
     * 
     * @type {number}
     * @memberof PolicyRuleResponse
     */
    'countLimit': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRuleType = {
    ContractFunctions: 'contract_functions',
    AccountFunctions: 'account_functions',
    RateLimit: 'rate_limit'
} as const;

export type PolicyRuleType = typeof PolicyRuleType[keyof typeof PolicyRuleType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRuleTypeACCOUNT = {
    AccountFunctions: 'account_functions'
} as const;

export type PolicyRuleTypeACCOUNT = typeof PolicyRuleTypeACCOUNT[keyof typeof PolicyRuleTypeACCOUNT];


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRuleTypeCONTRACT = {
    ContractFunctions: 'contract_functions'
} as const;

export type PolicyRuleTypeCONTRACT = typeof PolicyRuleTypeCONTRACT[keyof typeof PolicyRuleTypeCONTRACT];


/**
 * 
 * @export
 * @enum {string}
 */

export const PolicyRuleTypeRATELIMIT = {
    RateLimit: 'rate_limit'
} as const;

export type PolicyRuleTypeRATELIMIT = typeof PolicyRuleTypeRATELIMIT[keyof typeof PolicyRuleTypeRATELIMIT];


/**
 * 
 * @export
 * @interface PolicyStrategy
 */
export interface PolicyStrategy {
    /**
     * 
     * @type {SponsorSchemaFIXEDRATE}
     * @memberof PolicyStrategy
     */
    'sponsorSchema': SponsorSchemaFIXEDRATE;
    /**
     * 
     * @type {string}
     * @memberof PolicyStrategy
     */
    'depositor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PolicyStrategy
     */
    'tokenContract': string;
    /**
     * 
     * @type {string}
     * @memberof PolicyStrategy
     */
    'tokenContractAmount': string;
}


/**
 * 
 * @export
 * @interface PolicyStrategyRequest
 */
export interface PolicyStrategyRequest {
    /**
     * 
     * @type {SponsorSchema}
     * @memberof PolicyStrategyRequest
     */
    'sponsorSchema': SponsorSchema;
    /**
     * If the user pays in custom tokens, the contract ID (starts with con_) of the token contract.
     * @type {string}
     * @memberof PolicyStrategyRequest
     */
    'tokenContract'?: string;
    /**
     * If the user pays in ERC20 tokens, this reflects either the exchange rate or the amount in WEI.
     * @type {string}
     * @memberof PolicyStrategyRequest
     */
    'tokenContractAmount'?: string;
    /**
     * If the you want to use your own native tokens to pay for gas, specify the developer account ID (starts with dac_)
     * @type {string}
     * @memberof PolicyStrategyRequest
     */
    'depositor'?: string;
}


/**
 * Matches any valid value that can be used as an input for operations like create and update as the value of a JSON field. Unlike `JsonValue`, this type allows read-only arrays and read-only object properties and disallows `null` at the top level.  `null` cannot be used as the value of a JSON field because its meaning would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or `Prisma.DbNull` to clear the JSON value and set the field to the database NULL value instead.
 * @export
 * @interface PrismaInputJsonValue
 */
export interface PrismaInputJsonValue {
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PrivateKeyPolicy = {
    Individual: 'INDIVIDUAL',
    Project: 'PROJECT'
} as const;

export type PrivateKeyPolicy = typeof PrivateKeyPolicy[keyof typeof PrivateKeyPolicy];


/**
 * 
 * @export
 * @interface ProjectListResponse
 */
export interface ProjectListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof ProjectListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof ProjectListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<ProjectResponse>}
     * @memberof ProjectListResponse
     */
    'data': Array<ProjectResponse>;
    /**
     * 
     * @type {number}
     * @memberof ProjectListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface ProjectLogs
 */
export interface ProjectLogs {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof ProjectLogs
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof ProjectLogs
     */
    'url': string;
    /**
     * 
     * @type {Array<Log>}
     * @memberof ProjectLogs
     */
    'data': Array<Log>;
    /**
     * 
     * @type {number}
     * @memberof ProjectLogs
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectLogs
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectLogs
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface ProjectResponse
 */
export interface ProjectResponse {
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePROJECT}
     * @memberof ProjectResponse
     */
    'object': EntityTypePROJECT;
    /**
     * 
     * @type {number}
     * @memberof ProjectResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectResponse
     */
    'updatedAt': number;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<ApiKeyResponse>}
     * @memberof ProjectResponse
     */
    'apikeys'?: Array<ApiKeyResponse>;
    /**
     * 
     * @type {Array<WebhookResponse>}
     * @memberof ProjectResponse
     */
    'webhook'?: Array<WebhookResponse>;
}


/**
 * 
 * @export
 * @interface ProjectStatsRequest
 */
export interface ProjectStatsRequest {
    /**
     * 
     * @type {string}
     * @memberof ProjectStatsRequest
     */
    'timeFrame': ProjectStatsRequestTimeFrameEnum;
}

export const ProjectStatsRequestTimeFrameEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month',
    All: 'all'
} as const;

export type ProjectStatsRequestTimeFrameEnum = typeof ProjectStatsRequestTimeFrameEnum[keyof typeof ProjectStatsRequestTimeFrameEnum];

/**
 * 
 * @export
 * @interface ProjectStatsResponse
 */
export interface ProjectStatsResponse {
    /**
     * 
     * @type {Array<Stat>}
     * @memberof ProjectStatsResponse
     */
    'transactionIntents': Array<Stat>;
}
/**
 * 
 * @export
 * @interface ProjectWebhookRequest
 */
export interface ProjectWebhookRequest {
    /**
     * The webhook url.
     * @type {string}
     * @memberof ProjectWebhookRequest
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectWebhookRequest
     */
    'apiKey'?: string;
}
/**
 * 
 * @export
 * @interface RefreshTokenRequest
 */
export interface RefreshTokenRequest {
    /**
     * Specifies the session.
     * @type {string}
     * @memberof RefreshTokenRequest
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface ResponseResponse
 */
export interface ResponseResponse {
    /**
     * The unix timestamp in seconds when the transactionIntent was created.
     * @type {number}
     * @memberof ResponseResponse
     */
    'createdAt': number;
    /**
     * The block height (number) of the block including the transaction of this log.
     * @type {number}
     * @memberof ResponseResponse
     */
    'blockNumber'?: number;
    /**
     * The transaction hash of the transaction of this log.
     * @type {string}
     * @memberof ResponseResponse
     */
    'transactionHash'?: string;
    /**
     * The l1 gas used by the transaction of this log.
     * @type {string}
     * @memberof ResponseResponse
     */
    'l1GasUsed'?: string;
    /**
     * The gas used by the transaction of this log.
     * @type {string}
     * @memberof ResponseResponse
     */
    'gasUsed'?: string;
    /**
     * The gas fee by the transaction of this log.
     * @type {string}
     * @memberof ResponseResponse
     */
    'gasFee'?: string;
    /**
     * The l1 gas fee by the transaction of this log.
     * @type {string}
     * @memberof ResponseResponse
     */
    'l1GasFee'?: string;
    /**
     * The status of the transaction of this log.
     * @type {number}
     * @memberof ResponseResponse
     */
    'status'?: number;
    /**
     * The logs of the transaction of this log.
     * @type {Array<Log>}
     * @memberof ResponseResponse
     */
    'logs'?: Array<Log>;
    /**
     * The address of the contract of this log.
     * @type {string}
     * @memberof ResponseResponse
     */
    'to'?: string;
    /**
     * The error of the transaction of this log.
     * @type {any}
     * @memberof ResponseResponse
     */
    'error'?: any;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ResponseTypeLIST = {
    List: 'list'
} as const;

export type ResponseTypeLIST = typeof ResponseTypeLIST[keyof typeof ResponseTypeLIST];


/**
 * 
 * @export
 * @interface RevokeSessionRequest
 */
export interface RevokeSessionRequest {
    /**
     * The address of the session key to revoke.
     * @type {string}
     * @memberof RevokeSessionRequest
     */
    'address': string;
    /**
     * ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). If no Policy is provided, the own Account native token funds will be used to pay for gas.
     * @type {string}
     * @memberof RevokeSessionRequest
     */
    'policy'?: string;
    /**
     * Whether the transactionIntent is optimistic (resolve before it arrives on chain) or not.
     * @type {boolean}
     * @memberof RevokeSessionRequest
     */
    'optimistic'?: boolean;
    /**
     * The chain ID. Must be a [supported chain](/chains).
     * @type {number}
     * @memberof RevokeSessionRequest
     */
    'chainId': number;
    /**
     * The player ID (starts with pla_).
     * @type {string}
     * @memberof RevokeSessionRequest
     */
    'player': string;
}
/**
 * 
 * @export
 * @interface SIWEAuthenticateRequest
 */
export interface SIWEAuthenticateRequest {
    /**
     * Signature of the EIP-712 message with the user\'s wallet.
     * @type {string}
     * @memberof SIWEAuthenticateRequest
     */
    'signature': string;
    /**
     * The EIP-712 message to sign.
     * @type {string}
     * @memberof SIWEAuthenticateRequest
     */
    'message': string;
    /**
     * The wallet client of the user
     * @type {string}
     * @memberof SIWEAuthenticateRequest
     */
    'walletClientType': string;
    /**
     * The connector type of the user
     * @type {string}
     * @memberof SIWEAuthenticateRequest
     */
    'connectorType': string;
}
/**
 * 
 * @export
 * @interface SIWEInitResponse
 */
export interface SIWEInitResponse {
    /**
     * The address of the player.
     * @type {string}
     * @memberof SIWEInitResponse
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof SIWEInitResponse
     */
    'nonce': string;
    /**
     * 
     * @type {number}
     * @memberof SIWEInitResponse
     */
    'expiresAt': number;
}
/**
 * 
 * @export
 * @interface SIWERequest
 */
export interface SIWERequest {
    /**
     * The address of the user.
     * @type {string}
     * @memberof SIWERequest
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface SessionListQueries
 */
export interface SessionListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof SessionListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof SessionListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof SessionListQueries
     */
    'order'?: SortOrder;
    /**
     * The player ID (starts with pla_)
     * @type {string}
     * @memberof SessionListQueries
     */
    'player': string;
    /**
     * Specifies the fields to expand in the response.
     * @type {Array<SessionResponseExpandable>}
     * @memberof SessionListQueries
     */
    'expand'?: Array<SessionResponseExpandable>;
}


/**
 * 
 * @export
 * @interface SessionListResponse
 */
export interface SessionListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof SessionListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof SessionListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<SessionResponse>}
     * @memberof SessionListResponse
     */
    'data': Array<SessionResponse>;
    /**
     * 
     * @type {number}
     * @memberof SessionListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof SessionListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof SessionListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface SessionResponse
 */
export interface SessionResponse {
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeSESSION}
     * @memberof SessionResponse
     */
    'object': EntityTypeSESSION;
    /**
     * 
     * @type {number}
     * @memberof SessionResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof SessionResponse
     */
    'updatedAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof SessionResponse
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'validAfter'?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionResponse
     */
    'validUntil'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SessionResponse
     */
    'whitelist'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SessionResponse
     */
    'limit'?: number;
    /**
     * 
     * @type {NextActionResponse}
     * @memberof SessionResponse
     */
    'nextAction'?: NextActionResponse;
    /**
     * 
     * @type {Array<PlayerResponseTransactionIntentsInner>}
     * @memberof SessionResponse
     */
    'transactionIntents'?: Array<PlayerResponseTransactionIntentsInner>;
}


/**
 * Contains list of the expandable fields for the session response
 * @export
 * @enum {string}
 */

export const SessionResponseExpandable = {
    TransactionIntents: 'transactionIntents'
} as const;

export type SessionResponseExpandable = typeof SessionResponseExpandable[keyof typeof SessionResponseExpandable];


/**
 * 
 * @export
 * @interface SettingsWebhookUpdateRequest
 */
export interface SettingsWebhookUpdateRequest {
    /**
     * The webhook url.
     * @type {string}
     * @memberof SettingsWebhookUpdateRequest
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ShareResponse
 */
export interface ShareResponse {
    /**
     * 
     * @type {string}
     * @memberof ShareResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeSHARE}
     * @memberof ShareResponse
     */
    'object': EntityTypeSHARE;
    /**
     * 
     * @type {number}
     * @memberof ShareResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ShareResponse
     */
    'share': string;
    /**
     * 
     * @type {boolean}
     * @memberof ShareResponse
     */
    'userEntropy': boolean;
    /**
     * 
     * @type {ShareType}
     * @memberof ShareResponse
     */
    'type': ShareType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ShareType = {
    Auth: 'auth',
    Recovery: 'recovery'
} as const;

export type ShareType = typeof ShareType[keyof typeof ShareType];


/**
 * 
 * @export
 * @interface SignPayloadRequest
 */
export interface SignPayloadRequest {
    /**
     * 
     * @type {DomainData}
     * @memberof SignPayloadRequest
     */
    'domain': DomainData;
    /**
     * 
     * @type {{ [key: string]: Array<TypedDataField>; }}
     * @memberof SignPayloadRequest
     */
    'types': { [key: string]: Array<TypedDataField>; };
    /**
     * 
     * @type {string}
     * @memberof SignPayloadRequest
     */
    'primaryType': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SignPayloadRequest
     */
    'value': { [key: string]: any; };
    /**
     * Hash to verify and that will be signed
     * @type {string}
     * @memberof SignPayloadRequest
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface SignPayloadResponse
 */
export interface SignPayloadResponse {
    /**
     * 
     * @type {EntityTypeSIGNATURE}
     * @memberof SignPayloadResponse
     */
    'object': EntityTypeSIGNATURE;
    /**
     * 
     * @type {string}
     * @memberof SignPayloadResponse
     */
    'account': string;
    /**
     * 
     * @type {string}
     * @memberof SignPayloadResponse
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof SignPayloadResponse
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof SignPayloadResponse
     */
    'signature': string;
}


/**
 * 
 * @export
 * @interface SignatureRequest
 */
export interface SignatureRequest {
    /**
     * signed userOperationHash by the owner or valid session key
     * @type {string}
     * @memberof SignatureRequest
     */
    'signature': string;
    /**
     * Set to `true` to indicate that the transactionIntent request should be resolved as soon as possible, after the transactionIntent is created and simulated and before it arrives on chain.
     * @type {boolean}
     * @memberof SignatureRequest
     */
    'optimistic'?: boolean;
}
/**
 * 
 * @export
 * @interface SignupRequest
 */
export interface SignupRequest {
    /**
     * The email address of the user.
     * @type {string}
     * @memberof SignupRequest
     */
    'email': string;
    /**
     * The password of the user.
     * @type {string}
     * @memberof SignupRequest
     */
    'password': string;
    /**
     * The name of the user.
     * @type {string}
     * @memberof SignupRequest
     */
    'name': string;
    /**
     * The description of the user.
     * @type {string}
     * @memberof SignupRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SortOrder = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortOrder = typeof SortOrder[keyof typeof SortOrder];


/**
 * 
 * @export
 * @enum {string}
 */

export const SponsorSchema = {
    PayForUser: 'pay_for_user',
    ChargeCustomTokens: 'charge_custom_tokens',
    FixedRate: 'fixed_rate'
} as const;

export type SponsorSchema = typeof SponsorSchema[keyof typeof SponsorSchema];


/**
 * 
 * @export
 * @enum {string}
 */

export const SponsorSchemaCHARGECUSTOMTOKENS = {
    ChargeCustomTokens: 'charge_custom_tokens'
} as const;

export type SponsorSchemaCHARGECUSTOMTOKENS = typeof SponsorSchemaCHARGECUSTOMTOKENS[keyof typeof SponsorSchemaCHARGECUSTOMTOKENS];


/**
 * 
 * @export
 * @enum {string}
 */

export const SponsorSchemaFIXEDRATE = {
    FixedRate: 'fixed_rate'
} as const;

export type SponsorSchemaFIXEDRATE = typeof SponsorSchemaFIXEDRATE[keyof typeof SponsorSchemaFIXEDRATE];


/**
 * 
 * @export
 * @enum {string}
 */

export const SponsorSchemaPAYFORUSER = {
    PayForUser: 'pay_for_user'
} as const;

export type SponsorSchemaPAYFORUSER = typeof SponsorSchemaPAYFORUSER[keyof typeof SponsorSchemaPAYFORUSER];


/**
 * 
 * @export
 * @interface StartRecoveryRequest
 */
export interface StartRecoveryRequest {
    /**
     * Address of the new owner
     * @type {string}
     * @memberof StartRecoveryRequest
     */
    'newOwnerAddress': string;
    /**
     * The policy ID (starts with pol_)
     * @type {string}
     * @memberof StartRecoveryRequest
     */
    'policy': string;
}
/**
 * 
 * @export
 * @interface Stat
 */
export interface Stat {
    /**
     * 
     * @type {string}
     * @memberof Stat
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof Stat
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof Stat
     */
    'successful': number;
    /**
     * 
     * @type {string}
     * @memberof Stat
     */
    'gasUsed': string;
}
/**
 * 
 * @export
 * @interface SubmitWeb3ActionRequest
 */
export interface SubmitWeb3ActionRequest {
    /**
     * True to approve the action, false to reject it.
     * @type {boolean}
     * @memberof SubmitWeb3ActionRequest
     */
    'approve': boolean;
    /**
     * ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). If no Policy is provided, the own Account native token funds will be used to pay for gas.
     * @type {string}
     * @memberof SubmitWeb3ActionRequest
     */
    'policy'?: string;
    /**
     * signed data by the owner
     * @type {string}
     * @memberof SubmitWeb3ActionRequest
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionResponse
 */
export interface SubscriptionResponse {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionResponse
     */
    'currentPeriodEnd': string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionResponse
     */
    'currentPeriodStart': string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionResponse
     */
    'canceledAt': string;
    /**
     * 
     * @type {SubscriptionResponsePlan}
     * @memberof SubscriptionResponse
     */
    'plan': SubscriptionResponsePlan;
}
/**
 * 
 * @export
 * @interface SubscriptionResponsePlan
 */
export interface SubscriptionResponsePlan {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionResponsePlan
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionResponsePlan
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionResponsePlan
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SubscriptionType = {
    Email: 'Email',
    Webhook: 'Webhook'
} as const;

export type SubscriptionType = typeof SubscriptionType[keyof typeof SubscriptionType];


/**
 * 
 * @export
 * @enum {string}
 */

export const TimeIntervalType = {
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;

export type TimeIntervalType = typeof TimeIntervalType[keyof typeof TimeIntervalType];


/**
 * 
 * @export
 * @interface TransactionIntent
 */
export interface TransactionIntent {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntent
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeTRANSACTIONINTENT}
     * @memberof TransactionIntent
     */
    'object': EntityTypeTRANSACTIONINTENT;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntent
     */
    'createdAt': number;
    /**
     * The unix timestamp in seconds when the transactionIntent was created.
     * @type {number}
     * @memberof TransactionIntent
     */
    'updatedAt': number;
    /**
     * The chain ID.
     * @type {number}
     * @memberof TransactionIntent
     */
    'chainId': number;
    /**
     * The hashed userOperation.
     * @type {string}
     * @memberof TransactionIntent
     */
    'userOperationHash'?: string;
    /**
     * 
     * @type {any}
     * @memberof TransactionIntent
     */
    'userOperation'?: any;
    /**
     * 
     * @type {ResponseResponse}
     * @memberof TransactionIntent
     */
    'response'?: ResponseResponse;
    /**
     * 
     * @type {Array<Interaction>}
     * @memberof TransactionIntent
     */
    'interactions'?: Array<Interaction>;
    /**
     * 
     * @type {NextActionResponse}
     * @memberof TransactionIntent
     */
    'nextAction'?: NextActionResponse;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof TransactionIntent
     */
    'policy'?: EntityIdResponse;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof TransactionIntent
     */
    'player'?: EntityIdResponse;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof TransactionIntent
     */
    'account': EntityIdResponse;
}


/**
 * 
 * @export
 * @interface TransactionIntentListQueries
 */
export interface TransactionIntentListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof TransactionIntentListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof TransactionIntentListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof TransactionIntentListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the fields to expand in the response.
     * @type {Array<TransactionIntentResponseExpandable>}
     * @memberof TransactionIntentListQueries
     */
    'expand'?: Array<TransactionIntentResponseExpandable>;
    /**
     * The chain ID. Must be a [supported chain](/chains).
     * @type {number}
     * @memberof TransactionIntentListQueries
     */
    'chainId'?: number;
    /**
     * Filter by account ID or developer account (starts with acc_ or dac_ respectively).
     * @type {Array<string>}
     * @memberof TransactionIntentListQueries
     */
    'account'?: Array<string>;
    /**
     * Filter by player ID (starts with pla_).
     * @type {Array<string>}
     * @memberof TransactionIntentListQueries
     */
    'player'?: Array<string>;
    /**
     * Filter by successful (1) or failed (0) transaction intents.
     * @type {number}
     * @memberof TransactionIntentListQueries
     */
    'status'?: number;
    /**
     * Filter by policy ID (starts with pol_).
     * @type {Array<string>}
     * @memberof TransactionIntentListQueries
     */
    'policy'?: Array<string>;
}


/**
 * 
 * @export
 * @interface TransactionIntentListResponse
 */
export interface TransactionIntentListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof TransactionIntentListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<TransactionIntentResponse>}
     * @memberof TransactionIntentListResponse
     */
    'data': Array<TransactionIntentResponse>;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface TransactionIntentResponse
 */
export interface TransactionIntentResponse {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeTRANSACTIONINTENT}
     * @memberof TransactionIntentResponse
     */
    'object': EntityTypeTRANSACTIONINTENT;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponse
     */
    'createdAt': number;
    /**
     * The unix timestamp in seconds when the transactionIntent was created.
     * @type {number}
     * @memberof TransactionIntentResponse
     */
    'updatedAt': number;
    /**
     * The chain ID.
     * @type {number}
     * @memberof TransactionIntentResponse
     */
    'chainId': number;
    /**
     * The hashed userOperation.
     * @type {string}
     * @memberof TransactionIntentResponse
     */
    'userOperationHash'?: string;
    /**
     * 
     * @type {any}
     * @memberof TransactionIntentResponse
     */
    'userOperation'?: any;
    /**
     * 
     * @type {ResponseResponse}
     * @memberof TransactionIntentResponse
     */
    'response'?: ResponseResponse;
    /**
     * 
     * @type {Array<Interaction>}
     * @memberof TransactionIntentResponse
     */
    'interactions'?: Array<Interaction>;
    /**
     * 
     * @type {NextActionResponse}
     * @memberof TransactionIntentResponse
     */
    'nextAction'?: NextActionResponse;
    /**
     * 
     * @type {TransactionIntentResponsePolicy}
     * @memberof TransactionIntentResponse
     */
    'policy'?: TransactionIntentResponsePolicy;
    /**
     * 
     * @type {TransactionIntentResponsePlayer}
     * @memberof TransactionIntentResponse
     */
    'player'?: TransactionIntentResponsePlayer;
    /**
     * 
     * @type {TransactionIntentResponseAccount}
     * @memberof TransactionIntentResponse
     */
    'account': TransactionIntentResponseAccount;
}


/**
 * The account ID (starts with acc_).
 * @export
 * @interface TransactionIntentResponseAccount
 */
export interface TransactionIntentResponseAccount {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponseAccount
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeDEVELOPERACCOUNT}
     * @memberof TransactionIntentResponseAccount
     */
    'object': EntityTypeDEVELOPERACCOUNT;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponseAccount
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponseAccount
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponseAccount
     */
    'ownerAddress': string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIntentResponseAccount
     */
    'deployed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIntentResponseAccount
     */
    'custodial': boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof TransactionIntentResponseAccount
     */
    'chainId': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponseAccount
     */
    'accountType': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponseAccount
     */
    'pendingOwnerAddress'?: string;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof TransactionIntentResponseAccount
     */
    'transactionIntents'?: Array<EntityIdResponse>;
    /**
     * 
     * @type {EntityIdResponse}
     * @memberof TransactionIntentResponseAccount
     */
    'player': EntityIdResponse;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponseAccount
     */
    'name'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionIntentResponseExpandable = {
    Player: 'player',
    Policy: 'policy',
    Account: 'account'
} as const;

export type TransactionIntentResponseExpandable = typeof TransactionIntentResponseExpandable[keyof typeof TransactionIntentResponseExpandable];


/**
 * The player ID (starts with pla_).
 * @export
 * @interface TransactionIntentResponsePlayer
 */
export interface TransactionIntentResponsePlayer {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePlayer
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePLAYER}
     * @memberof TransactionIntentResponsePlayer
     */
    'object': EntityTypePLAYER;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponsePlayer
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePlayer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePlayer
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: PlayerMetadataValue; }}
     * @memberof TransactionIntentResponsePlayer
     */
    'metadata'?: { [key: string]: PlayerMetadataValue; };
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof TransactionIntentResponsePlayer
     */
    'transactionIntents'?: Array<EntityIdResponse>;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof TransactionIntentResponsePlayer
     */
    'accounts'?: Array<EntityIdResponse>;
}


/**
 * The policy ID (starts with pol_).
 * @export
 * @interface TransactionIntentResponsePolicy
 */
export interface TransactionIntentResponsePolicy {
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePolicy
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePOLICY}
     * @memberof TransactionIntentResponsePolicy
     */
    'object': EntityTypePOLICY;
    /**
     * 
     * @type {number}
     * @memberof TransactionIntentResponsePolicy
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionIntentResponsePolicy
     */
    'name': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIntentResponsePolicy
     */
    'deleted': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionIntentResponsePolicy
     */
    'enabled': boolean;
    /**
     * The chain ID.
     * @type {number}
     * @memberof TransactionIntentResponsePolicy
     */
    'chainId': number;
    /**
     * 
     * @type {PolicyStrategy}
     * @memberof TransactionIntentResponsePolicy
     */
    'strategy': PolicyStrategy;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof TransactionIntentResponsePolicy
     */
    'transactionIntents': Array<EntityIdResponse>;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof TransactionIntentResponsePolicy
     */
    'policyRules': Array<EntityIdResponse>;
}


/**
 * 
 * @export
 * @interface TransferOwnershipRequest
 */
export interface TransferOwnershipRequest {
    /**
     * The address of the new owner
     * @type {string}
     * @memberof TransferOwnershipRequest
     */
    'newOwnerAddress': string;
    /**
     * ID of the Policy that defines the gas sponsorship strategy (starts with `pol_`). A policy must be provided.
     * @type {string}
     * @memberof TransferOwnershipRequest
     */
    'policy': string;
}
/**
 * 
 * @export
 * @interface TypedDataField
 */
export interface TypedDataField {
    /**
     * 
     * @type {string}
     * @memberof TypedDataField
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TypedDataField
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface UpdateContractRequest
 */
export interface UpdateContractRequest {
    /**
     * Specifies the name of the contract (Only for display purposes).
     * @type {string}
     * @memberof UpdateContractRequest
     */
    'name'?: string;
    /**
     * Specifies the chain ID of the contract. Must be a [supported chain](/chains).
     * @type {number}
     * @memberof UpdateContractRequest
     */
    'chainId'?: number;
    /**
     * Specifies whether to delete the contract.
     * @type {boolean}
     * @memberof UpdateContractRequest
     */
    'deleted'?: boolean;
    /**
     * Specifies the address of the contract.
     * @type {string}
     * @memberof UpdateContractRequest
     */
    'address'?: string;
    /**
     * Specifies the ABI of the contract.
     * @type {Array<Abi>}
     * @memberof UpdateContractRequest
     */
    'abi'?: Array<Abi>;
    /**
     * Specifies whether to verify the contract publicly.
     * @type {boolean}
     * @memberof UpdateContractRequest
     */
    'publicVerification'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdatePolicyRequest
 */
export interface UpdatePolicyRequest {
    /**
     * Specifies the name of the policy.
     * @type {string}
     * @memberof UpdatePolicyRequest
     */
    'name'?: string;
    /**
     * The chain ID. Must be a [supported chain](/chains).
     * @type {number}
     * @memberof UpdatePolicyRequest
     */
    'chainId'?: number;
    /**
     * 
     * @type {PolicyStrategyRequest}
     * @memberof UpdatePolicyRequest
     */
    'strategy'?: PolicyStrategyRequest;
    /**
     * Specifies whether to delete the policy.
     * @type {boolean}
     * @memberof UpdatePolicyRequest
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdatePolicyRuleRequest
 */
export interface UpdatePolicyRuleRequest {
    /**
     * 
     * @type {PolicyRuleType}
     * @memberof UpdatePolicyRuleRequest
     */
    'type': PolicyRuleType;
    /**
     * Name of the function in the contract to allow. If you want to allow all functions, use the wildcard \'All functions\'.
     * @type {string}
     * @memberof UpdatePolicyRuleRequest
     */
    'functionName'?: string;
    /**
     * The contract ID you want to interact with. Must have been added to Openfort first, starts with `con_`.
     * @type {string}
     * @memberof UpdatePolicyRuleRequest
     */
    'contract'?: string;
    /**
     * Gas limit in WEI (i.e. factor 10^18).
     * @type {string}
     * @memberof UpdatePolicyRuleRequest
     */
    'gasLimit'?: string;
    /**
     * Number of times the function will be sponsored.
     * @type {number}
     * @memberof UpdatePolicyRuleRequest
     */
    'countLimit'?: number;
    /**
     * 
     * @type {TimeIntervalType}
     * @memberof UpdatePolicyRuleRequest
     */
    'timeIntervalType'?: TimeIntervalType;
    /**
     * Time interval value.
     * @type {number}
     * @memberof UpdatePolicyRuleRequest
     */
    'timeIntervalValue'?: number;
}


/**
 * 
 * @export
 * @interface UpdateProjectApiKeyRequest
 */
export interface UpdateProjectApiKeyRequest {
    /**
     * 
     * @type {ApiKeyType}
     * @memberof UpdateProjectApiKeyRequest
     */
    'type': ApiKeyType;
    /**
     * The API key to update.
     * @type {string}
     * @memberof UpdateProjectApiKeyRequest
     */
    'uuid': string;
}


/**
 * 
 * @export
 * @interface UpdateProjectRequest
 */
export interface UpdateProjectRequest {
    /**
     * Name of the project.
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UserProjectCreateRequest
 */
export interface UserProjectCreateRequest {
    /**
     * 
     * @type {UserProjectCreateRequestRole}
     * @memberof UserProjectCreateRequest
     */
    'role'?: UserProjectCreateRequestRole;
    /**
     * The email of the user to add.
     * @type {string}
     * @memberof UserProjectCreateRequest
     */
    'email': string;
}
/**
 * The role of the user.
 * @export
 * @interface UserProjectCreateRequestRole
 */
export interface UserProjectCreateRequestRole {
}
/**
 * 
 * @export
 * @interface UserProjectDeleteResponse
 */
export interface UserProjectDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof UserProjectDeleteResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeUSER}
     * @memberof UserProjectDeleteResponse
     */
    'object': EntityTypeUSER;
    /**
     * 
     * @type {boolean}
     * @memberof UserProjectDeleteResponse
     */
    'deleted': boolean;
}


/**
 * 
 * @export
 * @interface UserProjectListResponse
 */
export interface UserProjectListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof UserProjectListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof UserProjectListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<UserProjectResponse>}
     * @memberof UserProjectListResponse
     */
    'data': Array<UserProjectResponse>;
    /**
     * 
     * @type {number}
     * @memberof UserProjectListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof UserProjectListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof UserProjectListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface UserProjectResponse
 */
export interface UserProjectResponse {
    /**
     * 
     * @type {string}
     * @memberof UserProjectResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeUSER}
     * @memberof UserProjectResponse
     */
    'object': EntityTypeUSER;
    /**
     * 
     * @type {number}
     * @memberof UserProjectResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof UserProjectResponse
     */
    'updatedAt': number;
    /**
     * 
     * @type {string}
     * @memberof UserProjectResponse
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserProjectResponse
     */
    'lastName': string;
    /**
     * 
     * @type {UserProjectRole}
     * @memberof UserProjectResponse
     */
    'role': UserProjectRole;
    /**
     * 
     * @type {string}
     * @memberof UserProjectResponse
     */
    'email': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserProjectRole = {
    Owner: 'OWNER',
    Admin: 'ADMIN',
    Member: 'MEMBER'
} as const;

export type UserProjectRole = typeof UserProjectRole[keyof typeof UserProjectRole];


/**
 * 
 * @export
 * @enum {string}
 */

export const UserProjectRoleADMIN = {
    Admin: 'ADMIN'
} as const;

export type UserProjectRoleADMIN = typeof UserProjectRoleADMIN[keyof typeof UserProjectRoleADMIN];


/**
 * 
 * @export
 * @enum {string}
 */

export const UserProjectRoleMEMBER = {
    Member: 'MEMBER'
} as const;

export type UserProjectRoleMEMBER = typeof UserProjectRoleMEMBER[keyof typeof UserProjectRoleMEMBER];


/**
 * 
 * @export
 * @interface UserProjectUpdateRequest
 */
export interface UserProjectUpdateRequest {
    /**
     * 
     * @type {UserProjectCreateRequestRole}
     * @memberof UserProjectUpdateRequest
     */
    'role': UserProjectCreateRequestRole;
}
/**
 * 
 * @export
 * @interface Web3ActionListResponse
 */
export interface Web3ActionListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof Web3ActionListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof Web3ActionListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<Web3ActionResponse>}
     * @memberof Web3ActionListResponse
     */
    'data': Array<Web3ActionResponse>;
    /**
     * 
     * @type {number}
     * @memberof Web3ActionListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof Web3ActionListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof Web3ActionListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface Web3ActionResponse
 */
export interface Web3ActionResponse {
    /**
     * 
     * @type {string}
     * @memberof Web3ActionResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeWEB3ACTION}
     * @memberof Web3ActionResponse
     */
    'object': EntityTypeWEB3ACTION;
    /**
     * 
     * @type {number}
     * @memberof Web3ActionResponse
     */
    'createdAt': number;
    /**
     * The web3_connection ID (starts with web3_).
     * @type {string}
     * @memberof Web3ActionResponse
     */
    'web3Connection': string;
    /**
     * 
     * @type {Web3ActionStatusEnum}
     * @memberof Web3ActionResponse
     */
    'status': Web3ActionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Web3ActionResponse
     */
    'chaindId': string;
    /**
     * 
     * @type {string}
     * @memberof Web3ActionResponse
     */
    'method': string;
    /**
     * 
     * @type {string}
     * @memberof Web3ActionResponse
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof Web3ActionResponse
     */
    'to'?: string;
    /**
     * 
     * @type {string}
     * @memberof Web3ActionResponse
     */
    'data': string;
    /**
     * 
     * @type {string}
     * @memberof Web3ActionResponse
     */
    'decodedData': string;
    /**
     * 
     * @type {string}
     * @memberof Web3ActionResponse
     */
    'hashedData': string;
    /**
     * 
     * @type {string}
     * @memberof Web3ActionResponse
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof Web3ActionResponse
     */
    'gas'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const Web3ActionStatusEnum = {
    Pending: 'Pending',
    Approved: 'Approved',
    Rejected: 'Rejected',
    Expired: 'Expired',
    Failed: 'Failed'
} as const;

export type Web3ActionStatusEnum = typeof Web3ActionStatusEnum[keyof typeof Web3ActionStatusEnum];


/**
 * 
 * @export
 * @interface Web3ConnectionListQueries
 */
export interface Web3ConnectionListQueries {
    /**
     * Specifies the maximum number of records to return.
     * @type {number}
     * @memberof Web3ConnectionListQueries
     */
    'limit'?: number;
    /**
     * Specifies the offset for the first records to return.
     * @type {number}
     * @memberof Web3ConnectionListQueries
     */
    'skip'?: number;
    /**
     * 
     * @type {SortOrder}
     * @memberof Web3ConnectionListQueries
     */
    'order'?: SortOrder;
    /**
     * Specifies the unique player ID (starts with pla_)
     * @type {string}
     * @memberof Web3ConnectionListQueries
     */
    'player'?: string;
    /**
     * Specifies connection status
     * @type {boolean}
     * @memberof Web3ConnectionListQueries
     */
    'disconnected'?: boolean;
}


/**
 * 
 * @export
 * @interface Web3ConnectionListResponse
 */
export interface Web3ConnectionListResponse {
    /**
     * 
     * @type {ResponseTypeLIST}
     * @memberof Web3ConnectionListResponse
     */
    'object': ResponseTypeLIST;
    /**
     * 
     * @type {string}
     * @memberof Web3ConnectionListResponse
     */
    'url': string;
    /**
     * 
     * @type {Array<Web3ConnectionResponse>}
     * @memberof Web3ConnectionListResponse
     */
    'data': Array<Web3ConnectionResponse>;
    /**
     * 
     * @type {number}
     * @memberof Web3ConnectionListResponse
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof Web3ConnectionListResponse
     */
    'end': number;
    /**
     * 
     * @type {number}
     * @memberof Web3ConnectionListResponse
     */
    'total': number;
}


/**
 * 
 * @export
 * @interface Web3ConnectionResponse
 */
export interface Web3ConnectionResponse {
    /**
     * 
     * @type {string}
     * @memberof Web3ConnectionResponse
     */
    'id': string;
    /**
     * 
     * @type {EntityTypeWEB3CONNECTION}
     * @memberof Web3ConnectionResponse
     */
    'object': EntityTypeWEB3CONNECTION;
    /**
     * 
     * @type {number}
     * @memberof Web3ConnectionResponse
     */
    'createdAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof Web3ConnectionResponse
     */
    'disconnected': boolean;
    /**
     * 
     * @type {Web3ConnectionResponsePlayer}
     * @memberof Web3ConnectionResponse
     */
    'player': Web3ConnectionResponsePlayer;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const Web3ConnectionResponseExpandable = {
    Player: 'player'
} as const;

export type Web3ConnectionResponseExpandable = typeof Web3ConnectionResponseExpandable[keyof typeof Web3ConnectionResponseExpandable];


/**
 * The player ID (starts with pla_).
 * @export
 * @interface Web3ConnectionResponsePlayer
 */
export interface Web3ConnectionResponsePlayer {
    /**
     * 
     * @type {string}
     * @memberof Web3ConnectionResponsePlayer
     */
    'id': string;
    /**
     * 
     * @type {EntityTypePLAYER}
     * @memberof Web3ConnectionResponsePlayer
     */
    'object': EntityTypePLAYER;
    /**
     * 
     * @type {number}
     * @memberof Web3ConnectionResponsePlayer
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof Web3ConnectionResponsePlayer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Web3ConnectionResponsePlayer
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: PlayerMetadataValue; }}
     * @memberof Web3ConnectionResponsePlayer
     */
    'metadata'?: { [key: string]: PlayerMetadataValue; };
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof Web3ConnectionResponsePlayer
     */
    'transactionIntents'?: Array<EntityIdResponse>;
    /**
     * 
     * @type {Array<EntityIdResponse>}
     * @memberof Web3ConnectionResponsePlayer
     */
    'accounts'?: Array<EntityIdResponse>;
}


/**
 * 
 * @export
 * @interface WebhookResponse
 */
export interface WebhookResponse {
    /**
     * 
     * @type {string}
     * @memberof WebhookResponse
     */
    'webhook': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookResponse
     */
    'livemode': boolean;
}
/**
 * 
 * @export
 * @interface WithdrawalPolicyRequest
 */
export interface WithdrawalPolicyRequest {
    /**
     * ID of the Dev Account this TransactionIntent will send the specified amount of tokens to (starts with `dac_`).
     * @type {string}
     * @memberof WithdrawalPolicyRequest
     */
    'account': string;
    /**
     * Amount in WEI to withdraw (i.e. factor 10^18)..
     * @type {string}
     * @memberof WithdrawalPolicyRequest
     */
    'amount': string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {CancelTransferOwnershipRequest} cancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransferOwnership: async (id: string, cancelTransferOwnershipRequest: CancelTransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelTransferOwnership', 'id', id)
            // verify required parameter 'cancelTransferOwnershipRequest' is not null or undefined
            assertParamExists('cancelTransferOwnership', 'cancelTransferOwnershipRequest', cancelTransferOwnershipRequest)
            const localVarPath = `/v1/accounts/{id}/cancel_transfer_ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelTransferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {CompleteRecoveryRequest} completeRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeRecovery: async (id: string, completeRecoveryRequest: CompleteRecoveryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeRecovery', 'id', id)
            // verify required parameter 'completeRecoveryRequest' is not null or undefined
            assertParamExists('completeRecovery', 'completeRecoveryRequest', completeRecoveryRequest)
            const localVarPath = `/v1/accounts/{id}/complete_recovery`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeRecoveryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new blockchain account for the provided player. If not player is provided, a new one will be created.  Account creation does not consume any gas. All accounts of a player will use the same address across blockchains.  Each player can only have one account per chain.
         * @summary Create an account object.
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (createAccountRequest: CreateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccountRequest' is not null or undefined
            assertParamExists('createAccount', 'createAccountRequest', createAccountRequest)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to deploy a smart contract account that was counterfactually generated.
         * @summary Deploy an account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {DeployRequest} deployRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAccount: async (id: string, deployRequest: DeployRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deployAccount', 'id', id)
            // verify required parameter 'deployRequest' is not null or undefined
            assertParamExists('deployAccount', 'deployRequest', deployRequest)
            const localVarPath = `/v1/accounts/{id}/deploy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing account.  Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
         * @summary Get existing account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {Array<AccountResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: string, expand?: Array<AccountResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of accounts for the given player.  This object represents a player\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  By default, a maximum of 10 accounts are shown per page.
         * @summary List accounts of a player.
         * @param {string} player Specifies the unique player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<AccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<AccountResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'player' is not null or undefined
            assertParamExists('getAccounts', 'player', player)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a request to change the owner of an account.  To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {TransferOwnershipRequest} transferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTransferOwnership: async (id: string, transferOwnershipRequest: TransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('requestTransferOwnership', 'id', id)
            // verify required parameter 'transferOwnershipRequest' is not null or undefined
            assertParamExists('requestTransferOwnership', 'transferOwnershipRequest', transferOwnershipRequest)
            const localVarPath = `/v1/accounts/{id}/request_transfer_ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Signs the typed data value with types data structure for domain using the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
         * @summary Sign a given payload
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {SignPayloadRequest} signPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signPayload: async (id: string, signPayloadRequest: SignPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signPayload', 'id', id)
            // verify required parameter 'signPayloadRequest' is not null or undefined
            assertParamExists('signPayload', 'signPayloadRequest', signPayloadRequest)
            const localVarPath = `/v1/accounts/{id}/sign_payload`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {StartRecoveryRequest} startRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecovery: async (id: string, startRecoveryRequest: StartRecoveryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startRecovery', 'id', id)
            // verify required parameter 'startRecoveryRequest' is not null or undefined
            assertParamExists('startRecovery', 'startRecoveryRequest', startRecoveryRequest)
            const localVarPath = `/v1/accounts/{id}/start_recovery`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startRecoveryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Synchronize the account state with the blockchain. Specifically, it updates the account owner and whether its deployed or not.
         * @summary Sync account state with the blockchain
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('syncAccount', 'id', id)
            const localVarPath = `/v1/accounts/{id}/sync`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {CancelTransferOwnershipRequest} cancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTransferOwnership(id: string, cancelTransferOwnershipRequest: CancelTransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransferOwnership(id, cancelTransferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Complete a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {CompleteRecoveryRequest} completeRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeRecovery(id: string, completeRecoveryRequest: CompleteRecoveryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeRecovery(id, completeRecoveryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new blockchain account for the provided player. If not player is provided, a new one will be created.  Account creation does not consume any gas. All accounts of a player will use the same address across blockchains.  Each player can only have one account per chain.
         * @summary Create an account object.
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(createAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint can be used to deploy a smart contract account that was counterfactually generated.
         * @summary Deploy an account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {DeployRequest} deployRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployAccount(id: string, deployRequest: DeployRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployAccount(id, deployRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing account.  Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
         * @summary Get existing account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {Array<AccountResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: string, expand?: Array<AccountResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of accounts for the given player.  This object represents a player\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  By default, a maximum of 10 accounts are shown per page.
         * @summary List accounts of a player.
         * @param {string} player Specifies the unique player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<AccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<AccountResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(player, limit, skip, order, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform a request to change the owner of an account.  To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {TransferOwnershipRequest} transferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestTransferOwnership(id: string, transferOwnershipRequest: TransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestTransferOwnership(id, transferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Signs the typed data value with types data structure for domain using the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
         * @summary Sign a given payload
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {SignPayloadRequest} signPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signPayload(id: string, signPayloadRequest: SignPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignPayloadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signPayload(id, signPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {StartRecoveryRequest} startRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRecovery(id: string, startRecoveryRequest: StartRecoveryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRecovery(id, startRecoveryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Synchronize the account state with the blockchain. Specifically, it updates the account owner and whether its deployed or not.
         * @summary Sync account state with the blockchain
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of an account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {CancelTransferOwnershipRequest} cancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransferOwnership(id: string, cancelTransferOwnershipRequest: CancelTransferOwnershipRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.cancelTransferOwnership(id, cancelTransferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complete a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {CompleteRecoveryRequest} completeRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeRecovery(id: string, completeRecoveryRequest: CompleteRecoveryRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.completeRecovery(id, completeRecoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new blockchain account for the provided player. If not player is provided, a new one will be created.  Account creation does not consume any gas. All accounts of a player will use the same address across blockchains.  Each player can only have one account per chain.
         * @summary Create an account object.
         * @param {CreateAccountRequest} createAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(createAccountRequest: CreateAccountRequest, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.createAccount(createAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint can be used to deploy a smart contract account that was counterfactually generated.
         * @summary Deploy an account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {DeployRequest} deployRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployAccount(id: string, deployRequest: DeployRequest, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.deployAccount(id, deployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing account.  Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
         * @summary Get existing account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {Array<AccountResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id: string, expand?: Array<AccountResponseExpandable>, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.getAccount(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of accounts for the given player.  This object represents a player\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  By default, a maximum of 10 accounts are shown per page.
         * @summary List accounts of a player.
         * @param {string} player Specifies the unique player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<AccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<AccountResponseExpandable>, options?: any): AxiosPromise<AccountListResponse> {
            return localVarFp.getAccounts(player, limit, skip, order, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a request to change the owner of an account.  To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {TransferOwnershipRequest} transferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTransferOwnership(id: string, transferOwnershipRequest: TransferOwnershipRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.requestTransferOwnership(id, transferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Signs the typed data value with types data structure for domain using the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
         * @summary Sign a given payload
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {SignPayloadRequest} signPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signPayload(id: string, signPayloadRequest: SignPayloadRequest, options?: any): AxiosPromise<SignPayloadResponse> {
            return localVarFp.signPayload(id, signPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a recovery process of a recoverable account.
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {StartRecoveryRequest} startRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecovery(id: string, startRecoveryRequest: StartRecoveryRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.startRecovery(id, startRecoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Synchronize the account state with the blockchain. Specifically, it updates the account owner and whether its deployed or not.
         * @summary Sync account state with the blockchain
         * @param {string} id Specifies the unique account ID (starts with acc_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAccount(id: string, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.syncAccount(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Cancel a pending transfer of ownership.
     * @summary Cancel request to transfer ownership of an account.
     * @param {string} id Specifies the unique account ID (starts with acc_).
     * @param {CancelTransferOwnershipRequest} cancelTransferOwnershipRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public cancelTransferOwnership(id: string, cancelTransferOwnershipRequest: CancelTransferOwnershipRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).cancelTransferOwnership(id, cancelTransferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complete a recovery process of a recoverable account.
     * @param {string} id Specifies the unique account ID (starts with acc_).
     * @param {CompleteRecoveryRequest} completeRecoveryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public completeRecovery(id: string, completeRecoveryRequest: CompleteRecoveryRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).completeRecovery(id, completeRecoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new blockchain account for the provided player. If not player is provided, a new one will be created.  Account creation does not consume any gas. All accounts of a player will use the same address across blockchains.  Each player can only have one account per chain.
     * @summary Create an account object.
     * @param {CreateAccountRequest} createAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccount(createAccountRequest: CreateAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccount(createAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint can be used to deploy a smart contract account that was counterfactually generated.
     * @summary Deploy an account.
     * @param {string} id Specifies the unique account ID (starts with acc_).
     * @param {DeployRequest} deployRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public deployAccount(id: string, deployRequest: DeployRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).deployAccount(id, deployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing account.  Supply the unique account ID from either a account creation request or the account list, and Openfort will return the corresponding account information.
     * @summary Get existing account.
     * @param {string} id Specifies the unique account ID (starts with acc_).
     * @param {Array<AccountResponseExpandable>} [expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(id: string, expand?: Array<AccountResponseExpandable>, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of accounts for the given player.  This object represents a player\'s account, which is a blockchain smart account that can be used to interact with the blockchain.  The accounts are returned sorted by creation date, with the most recently created accounts appearing first.  By default, a maximum of 10 accounts are shown per page.
     * @summary List accounts of a player.
     * @param {string} player Specifies the unique player ID (starts with pla_)
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<AccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<AccountResponseExpandable>, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccounts(player, limit, skip, order, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a request to change the owner of an account.  To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
     * @summary Request transfer ownership of account.
     * @param {string} id Specifies the unique account ID (starts with acc_).
     * @param {TransferOwnershipRequest} transferOwnershipRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public requestTransferOwnership(id: string, transferOwnershipRequest: TransferOwnershipRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).requestTransferOwnership(id, transferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Signs the typed data value with types data structure for domain using the [EIP-712](https://eips.ethereum.org/EIPS/eip-712) specification.
     * @summary Sign a given payload
     * @param {string} id Specifies the unique account ID (starts with acc_).
     * @param {SignPayloadRequest} signPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public signPayload(id: string, signPayloadRequest: SignPayloadRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).signPayload(id, signPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a recovery process of a recoverable account.
     * @param {string} id Specifies the unique account ID (starts with acc_).
     * @param {StartRecoveryRequest} startRecoveryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public startRecovery(id: string, startRecoveryRequest: StartRecoveryRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).startRecovery(id, startRecoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Synchronize the account state with the blockchain. Specifically, it updates the account owner and whether its deployed or not.
     * @summary Sync account state with the blockchain
     * @param {string} id Specifies the unique account ID (starts with acc_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public syncAccount(id: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).syncAccount(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AdminAuthenticationApi - axios parameter creator
 * @export
 */
export const AdminAuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The endpoint creates oauth configuration for the current project environment.
         * @summary Create oauth configuration.
         * @param {OAuthConfig} body Specifies the oauth provider specific configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOAuthConfig: async (body: OAuthConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOAuthConfig', 'body', body)
            const localVarPath = `/iam/v1/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a player auth object.  It will delete all linked accounts the player is authenticated with.
         * @summary Deletes a player auth object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthPlayer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAuthPlayer', 'id', id)
            const localVarPath = `/iam/v1/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint deletes oauth configuration for specified provider for the current project environment.
         * @summary Delete oauth configuration.
         * @param {OAuthProvider} provider Specifies the oauth provider type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOAuthConfig: async (provider: OAuthProvider, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('deleteOAuthConfig', 'provider', provider)
            const localVarPath = `/iam/v1/oauth/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of authenticated players.  Players have linked accounts and are authenticated with a provider.
         * @summary List authenticated players.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [email] Specifies the email address of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthPlayers: async (limit?: number, skip?: number, order?: SortOrder, email?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iam/v1/players`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint retrieves oauth configuration for specified provider for the current project environment.
         * @summary Get oauth configuration.
         * @param {OAuthProvider} provider Specifies the oauth provider type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthConfig: async (provider: OAuthProvider, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('getOAuthConfig', 'provider', provider)
            const localVarPath = `/iam/v1/oauth/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List configured OAuth methods for the current project environment.
         * @summary List of oauth configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOAuthConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iam/v1/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminAuthenticationApi - functional programming interface
 * @export
 */
export const AdminAuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminAuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * The endpoint creates oauth configuration for the current project environment.
         * @summary Create oauth configuration.
         * @param {OAuthConfig} body Specifies the oauth provider specific configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOAuthConfig(body: OAuthConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOAuthConfig(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a player auth object.  It will delete all linked accounts the player is authenticated with.
         * @summary Deletes a player auth object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthPlayer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAuthPlayer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The endpoint deletes oauth configuration for specified provider for the current project environment.
         * @summary Delete oauth configuration.
         * @param {OAuthProvider} provider Specifies the oauth provider type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOAuthConfig(provider: OAuthProvider, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOAuthConfig(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of authenticated players.  Players have linked accounts and are authenticated with a provider.
         * @summary List authenticated players.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [email] Specifies the email address of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthPlayers(limit?: number, skip?: number, order?: SortOrder, email?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthPlayerListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthPlayers(limit, skip, order, email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The endpoint retrieves oauth configuration for specified provider for the current project environment.
         * @summary Get oauth configuration.
         * @param {OAuthProvider} provider Specifies the oauth provider type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOAuthConfig(provider: OAuthProvider, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOAuthConfig(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List configured OAuth methods for the current project environment.
         * @summary List of oauth configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOAuthConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthConfigListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOAuthConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminAuthenticationApi - factory interface
 * @export
 */
export const AdminAuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminAuthenticationApiFp(configuration)
    return {
        /**
         * The endpoint creates oauth configuration for the current project environment.
         * @summary Create oauth configuration.
         * @param {OAuthConfig} body Specifies the oauth provider specific configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOAuthConfig(body: OAuthConfig, options?: any): AxiosPromise<OAuthConfig> {
            return localVarFp.createOAuthConfig(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a player auth object.  It will delete all linked accounts the player is authenticated with.
         * @summary Deletes a player auth object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthPlayer(id: string, options?: any): AxiosPromise<PlayerDeleteResponse> {
            return localVarFp.deleteAuthPlayer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint deletes oauth configuration for specified provider for the current project environment.
         * @summary Delete oauth configuration.
         * @param {OAuthProvider} provider Specifies the oauth provider type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOAuthConfig(provider: OAuthProvider, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOAuthConfig(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of authenticated players.  Players have linked accounts and are authenticated with a provider.
         * @summary List authenticated players.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [email] Specifies the email address of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthPlayers(limit?: number, skip?: number, order?: SortOrder, email?: string, options?: any): AxiosPromise<AuthPlayerListResponse> {
            return localVarFp.getAuthPlayers(limit, skip, order, email, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint retrieves oauth configuration for specified provider for the current project environment.
         * @summary Get oauth configuration.
         * @param {OAuthProvider} provider Specifies the oauth provider type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthConfig(provider: OAuthProvider, options?: any): AxiosPromise<OAuthConfig> {
            return localVarFp.getOAuthConfig(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * List configured OAuth methods for the current project environment.
         * @summary List of oauth configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOAuthConfig(options?: any): AxiosPromise<OAuthConfigListResponse> {
            return localVarFp.listOAuthConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminAuthenticationApi - object-oriented interface
 * @export
 * @class AdminAuthenticationApi
 * @extends {BaseAPI}
 */
export class AdminAuthenticationApi extends BaseAPI {
    /**
     * The endpoint creates oauth configuration for the current project environment.
     * @summary Create oauth configuration.
     * @param {OAuthConfig} body Specifies the oauth provider specific configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAuthenticationApi
     */
    public createOAuthConfig(body: OAuthConfig, options?: AxiosRequestConfig) {
        return AdminAuthenticationApiFp(this.configuration).createOAuthConfig(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a player auth object.  It will delete all linked accounts the player is authenticated with.
     * @summary Deletes a player auth object.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAuthenticationApi
     */
    public deleteAuthPlayer(id: string, options?: AxiosRequestConfig) {
        return AdminAuthenticationApiFp(this.configuration).deleteAuthPlayer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint deletes oauth configuration for specified provider for the current project environment.
     * @summary Delete oauth configuration.
     * @param {OAuthProvider} provider Specifies the oauth provider type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAuthenticationApi
     */
    public deleteOAuthConfig(provider: OAuthProvider, options?: AxiosRequestConfig) {
        return AdminAuthenticationApiFp(this.configuration).deleteOAuthConfig(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of authenticated players.  Players have linked accounts and are authenticated with a provider.
     * @summary List authenticated players.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {string} [email] Specifies the email address of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAuthenticationApi
     */
    public getAuthPlayers(limit?: number, skip?: number, order?: SortOrder, email?: string, options?: AxiosRequestConfig) {
        return AdminAuthenticationApiFp(this.configuration).getAuthPlayers(limit, skip, order, email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint retrieves oauth configuration for specified provider for the current project environment.
     * @summary Get oauth configuration.
     * @param {OAuthProvider} provider Specifies the oauth provider type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAuthenticationApi
     */
    public getOAuthConfig(provider: OAuthProvider, options?: AxiosRequestConfig) {
        return AdminAuthenticationApiFp(this.configuration).getOAuthConfig(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List configured OAuth methods for the current project environment.
     * @summary List of oauth configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminAuthenticationApi
     */
    public listOAuthConfig(options?: AxiosRequestConfig) {
        return AdminAuthenticationApiFp(this.configuration).listOAuthConfig(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate player with oauth token.
         * @param {AuthenticateOAuthRequest} authenticateOAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateOAuth: async (authenticateOAuthRequest: AuthenticateOAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticateOAuthRequest' is not null or undefined
            assertParamExists('authenticateOAuth', 'authenticateOAuthRequest', authenticateOAuthRequest)
            const localVarPath = `/iam/v1/oauth/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticateOAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authenticate player with SIWE
         * @param {SIWEAuthenticateRequest} sIWEAuthenticateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateSIWE: async (sIWEAuthenticateRequest: SIWEAuthenticateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sIWEAuthenticateRequest' is not null or undefined
            assertParamExists('authenticateSIWE', 'sIWEAuthenticateRequest', sIWEAuthenticateRequest)
            const localVarPath = `/iam/v1/siwe/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sIWEAuthenticateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint verifies the token generated by OAuth provider, creates or retrieves a player based on his email, and returns the jwt token for the player together with the player id.
         * @summary Authorize player with token.
         * @param {OAuthProvider} provider OAuth provider
         * @param {OAuthRequest} oAuthRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authorizeWithOAuthToken: async (provider: OAuthProvider, oAuthRequest: OAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('authorizeWithOAuthToken', 'provider', provider)
            // verify required parameter 'oAuthRequest' is not null or undefined
            assertParamExists('authorizeWithOAuthToken', 'oAuthRequest', oAuthRequest)
            const localVarPath = `/iam/v1/oauth/{provider}/authorize`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the jwks.json file.  You can use the jwks.json file to verify the signature of a JWT token issued by Openfort Auth.
         * @summary Get the jwks.json file.
         * @param {string} publishableKey Specifies the project publishable key (starts with pk_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJwks: async (publishableKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publishableKey' is not null or undefined
            assertParamExists('getJwks', 'publishableKey', publishableKey)
            const localVarPath = `/iam/v1/{publishable_key}/jwks.json`
                .replace(`{${"publishable_key"}}`, encodeURIComponent(String(publishableKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initialize OAuth.
         * @param {OAuthInitRequest} oAuthInitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initOAuth: async (oAuthInitRequest: OAuthInitRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuthInitRequest' is not null or undefined
            assertParamExists('initOAuth', 'oAuthInitRequest', oAuthInitRequest)
            const localVarPath = `/iam/v1/oauth/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthInitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a challenge to link external wallet to the player.
         * @summary Initialize SIWE.
         * @param {SIWERequest} sIWERequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initSIWE: async (sIWERequest: SIWERequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sIWERequest' is not null or undefined
            assertParamExists('initSIWE', 'sIWERequest', sIWERequest)
            const localVarPath = `/iam/v1/siwe/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sIWERequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link external wallet.
         * @param {SIWEAuthenticateRequest} sIWEAuthenticateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkSIWE: async (sIWEAuthenticateRequest: SIWEAuthenticateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sIWEAuthenticateRequest' is not null or undefined
            assertParamExists('linkSIWE', 'sIWEAuthenticateRequest', sIWEAuthenticateRequest)
            const localVarPath = `/iam/v1/siwe/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sIWEAuthenticateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a player based on email and password.
         * @summary Email and password login.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginEmailPassword: async (loginRequest: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('loginEmailPassword', 'loginRequest', loginRequest)
            const localVarPath = `/iam/v1/password/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When using Openfort Auth, the endpoint logs out the player.
         * @summary Log out a player.
         * @param {LogoutRequest} logoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (logoutRequest: LogoutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logoutRequest' is not null or undefined
            assertParamExists('logout', 'logoutRequest', logoutRequest)
            const localVarPath = `/iam/v1/sessions/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get or create a new session for the player based on the refresh token.
         * @summary Refresh or create auth session.
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh: async (refreshTokenRequest: RefreshTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('refresh', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/iam/v1/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create and authenticate a player based on email and password.
         * @summary Email and password signup.
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupEmailPassword: async (signupRequest: SignupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupRequest' is not null or undefined
            assertParamExists('signupEmailPassword', 'signupRequest', signupRequest)
            const localVarPath = `/iam/v1/password/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink OAuth account
         * @param {LinkRequest} linkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkOAuth: async (linkRequest: LinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'linkRequest' is not null or undefined
            assertParamExists('unlinkOAuth', 'linkRequest', linkRequest)
            const localVarPath = `/iam/v1/oauth/unlink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(linkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlink external wallet.
         * @param {SIWERequest} sIWERequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkSIWE: async (sIWERequest: SIWERequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sIWERequest' is not null or undefined
            assertParamExists('unlinkSIWE', 'sIWERequest', sIWERequest)
            const localVarPath = `/iam/v1/siwe/unlink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sIWERequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the token generated by Openfort Auth.
         * @summary Verify auth token.
         * @param {string} token Specifies the auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAuthToken: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('verifyAuthToken', 'token', token)
            const localVarPath = `/iam/v1/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint verifies the token generated by OAuth provider and retrieves a corresponding player.
         * @summary Retrieve player by oauth token.
         * @param {AuthenticateOAuthRequest} authenticateOAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOAuth: async (authenticateOAuthRequest: AuthenticateOAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticateOAuthRequest' is not null or undefined
            assertParamExists('verifyOAuth', 'authenticateOAuthRequest', authenticateOAuthRequest)
            const localVarPath = `/iam/v1/oauth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticateOAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The endpoint verifies the token generated by OAuth provider and retrieves a corresponding player.
         * @summary Retrieve player by token.
         * @param {OAuthProvider} provider OAuth provider
         * @param {OAuthRequest} oAuthRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        verifyOAuthToken: async (provider: OAuthProvider, oAuthRequest: OAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('verifyOAuthToken', 'provider', provider)
            // verify required parameter 'oAuthRequest' is not null or undefined
            assertParamExists('verifyOAuthToken', 'oAuthRequest', oAuthRequest)
            const localVarPath = `/iam/v1/oauth/{provider}/verify`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authenticate player with oauth token.
         * @param {AuthenticateOAuthRequest} authenticateOAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateOAuth(authenticateOAuthRequest: AuthenticateOAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateOAuth(authenticateOAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Authenticate player with SIWE
         * @param {SIWEAuthenticateRequest} sIWEAuthenticateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateSIWE(sIWEAuthenticateRequest: SIWEAuthenticateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateSIWE(sIWEAuthenticateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The endpoint verifies the token generated by OAuth provider, creates or retrieves a player based on his email, and returns the jwt token for the player together with the player id.
         * @summary Authorize player with token.
         * @param {OAuthProvider} provider OAuth provider
         * @param {OAuthRequest} oAuthRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authorizeWithOAuthToken(provider: OAuthProvider, oAuthRequest: OAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeWithOAuthToken(provider, oAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the jwks.json file.  You can use the jwks.json file to verify the signature of a JWT token issued by Openfort Auth.
         * @summary Get the jwks.json file.
         * @param {string} publishableKey Specifies the project publishable key (starts with pk_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJwks(publishableKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJwks(publishableKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Initialize OAuth.
         * @param {OAuthInitRequest} oAuthInitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initOAuth(oAuthInitRequest: OAuthInitRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSigninUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initOAuth(oAuthInitRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a challenge to link external wallet to the player.
         * @summary Initialize SIWE.
         * @param {SIWERequest} sIWERequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initSIWE(sIWERequest: SIWERequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SIWEInitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initSIWE(sIWERequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Link external wallet.
         * @param {SIWEAuthenticateRequest} sIWEAuthenticateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkSIWE(sIWEAuthenticateRequest: SIWEAuthenticateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthPlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkSIWE(sIWEAuthenticateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate a player based on email and password.
         * @summary Email and password login.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginEmailPassword(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginEmailPassword(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * When using Openfort Auth, the endpoint logs out the player.
         * @summary Log out a player.
         * @param {LogoutRequest} logoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(logoutRequest: LogoutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(logoutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get or create a new session for the player based on the refresh token.
         * @summary Refresh or create auth session.
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refresh(refreshTokenRequest: RefreshTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(refreshTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create and authenticate a player based on email and password.
         * @summary Email and password signup.
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signupEmailPassword(signupRequest: SignupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signupEmailPassword(signupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlink OAuth account
         * @param {LinkRequest} linkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkOAuth(linkRequest: LinkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthPlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkOAuth(linkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlink external wallet.
         * @param {SIWERequest} sIWERequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkSIWE(sIWERequest: SIWERequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthPlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkSIWE(sIWERequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verifies the token generated by Openfort Auth.
         * @summary Verify auth token.
         * @param {string} token Specifies the auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyAuthToken(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyAuthToken(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The endpoint verifies the token generated by OAuth provider and retrieves a corresponding player.
         * @summary Retrieve player by oauth token.
         * @param {AuthenticateOAuthRequest} authenticateOAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyOAuth(authenticateOAuthRequest: AuthenticateOAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyOAuth(authenticateOAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The endpoint verifies the token generated by OAuth provider and retrieves a corresponding player.
         * @summary Retrieve player by token.
         * @param {OAuthProvider} provider OAuth provider
         * @param {OAuthRequest} oAuthRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async verifyOAuthToken(provider: OAuthProvider, oAuthRequest: OAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyOAuthToken(provider, oAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Authenticate player with oauth token.
         * @param {AuthenticateOAuthRequest} authenticateOAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateOAuth(authenticateOAuthRequest: AuthenticateOAuthRequest, options?: any): AxiosPromise<AuthResponse> {
            return localVarFp.authenticateOAuth(authenticateOAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Authenticate player with SIWE
         * @param {SIWEAuthenticateRequest} sIWEAuthenticateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateSIWE(sIWEAuthenticateRequest: SIWEAuthenticateRequest, options?: any): AxiosPromise<AuthResponse> {
            return localVarFp.authenticateSIWE(sIWEAuthenticateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint verifies the token generated by OAuth provider, creates or retrieves a player based on his email, and returns the jwt token for the player together with the player id.
         * @summary Authorize player with token.
         * @param {OAuthProvider} provider OAuth provider
         * @param {OAuthRequest} oAuthRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authorizeWithOAuthToken(provider: OAuthProvider, oAuthRequest: OAuthRequest, options?: any): AxiosPromise<AuthResponse> {
            return localVarFp.authorizeWithOAuthToken(provider, oAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the jwks.json file.  You can use the jwks.json file to verify the signature of a JWT token issued by Openfort Auth.
         * @summary Get the jwks.json file.
         * @param {string} publishableKey Specifies the project publishable key (starts with pk_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJwks(publishableKey: string, options?: any): AxiosPromise<JwtKeyResponse> {
            return localVarFp.getJwks(publishableKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initialize OAuth.
         * @param {OAuthInitRequest} oAuthInitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initOAuth(oAuthInitRequest: OAuthInitRequest, options?: any): AxiosPromise<GetSigninUrlResponse> {
            return localVarFp.initOAuth(oAuthInitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a challenge to link external wallet to the player.
         * @summary Initialize SIWE.
         * @param {SIWERequest} sIWERequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initSIWE(sIWERequest: SIWERequest, options?: any): AxiosPromise<SIWEInitResponse> {
            return localVarFp.initSIWE(sIWERequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link external wallet.
         * @param {SIWEAuthenticateRequest} sIWEAuthenticateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkSIWE(sIWEAuthenticateRequest: SIWEAuthenticateRequest, options?: any): AxiosPromise<AuthPlayerResponse> {
            return localVarFp.linkSIWE(sIWEAuthenticateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a player based on email and password.
         * @summary Email and password login.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginEmailPassword(loginRequest: LoginRequest, options?: any): AxiosPromise<AuthResponse> {
            return localVarFp.loginEmailPassword(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * When using Openfort Auth, the endpoint logs out the player.
         * @summary Log out a player.
         * @param {LogoutRequest} logoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(logoutRequest: LogoutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.logout(logoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get or create a new session for the player based on the refresh token.
         * @summary Refresh or create auth session.
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(refreshTokenRequest: RefreshTokenRequest, options?: any): AxiosPromise<AuthResponse> {
            return localVarFp.refresh(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create and authenticate a player based on email and password.
         * @summary Email and password signup.
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupEmailPassword(signupRequest: SignupRequest, options?: any): AxiosPromise<AuthResponse> {
            return localVarFp.signupEmailPassword(signupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink OAuth account
         * @param {LinkRequest} linkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkOAuth(linkRequest: LinkRequest, options?: any): AxiosPromise<AuthPlayerResponse> {
            return localVarFp.unlinkOAuth(linkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlink external wallet.
         * @param {SIWERequest} sIWERequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkSIWE(sIWERequest: SIWERequest, options?: any): AxiosPromise<AuthPlayerResponse> {
            return localVarFp.unlinkSIWE(sIWERequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the token generated by Openfort Auth.
         * @summary Verify auth token.
         * @param {string} token Specifies the auth token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAuthToken(token: string, options?: any): AxiosPromise<AuthSessionResponse> {
            return localVarFp.verifyAuthToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint verifies the token generated by OAuth provider and retrieves a corresponding player.
         * @summary Retrieve player by oauth token.
         * @param {AuthenticateOAuthRequest} authenticateOAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyOAuth(authenticateOAuthRequest: AuthenticateOAuthRequest, options?: any): AxiosPromise<PlayerResponse> {
            return localVarFp.verifyOAuth(authenticateOAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The endpoint verifies the token generated by OAuth provider and retrieves a corresponding player.
         * @summary Retrieve player by token.
         * @param {OAuthProvider} provider OAuth provider
         * @param {OAuthRequest} oAuthRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        verifyOAuthToken(provider: OAuthProvider, oAuthRequest: OAuthRequest, options?: any): AxiosPromise<PlayerResponse> {
            return localVarFp.verifyOAuthToken(provider, oAuthRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Authenticate player with oauth token.
     * @param {AuthenticateOAuthRequest} authenticateOAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticateOAuth(authenticateOAuthRequest: AuthenticateOAuthRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticateOAuth(authenticateOAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Authenticate player with SIWE
     * @param {SIWEAuthenticateRequest} sIWEAuthenticateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticateSIWE(sIWEAuthenticateRequest: SIWEAuthenticateRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticateSIWE(sIWEAuthenticateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint verifies the token generated by OAuth provider, creates or retrieves a player based on his email, and returns the jwt token for the player together with the player id.
     * @summary Authorize player with token.
     * @param {OAuthProvider} provider OAuth provider
     * @param {OAuthRequest} oAuthRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authorizeWithOAuthToken(provider: OAuthProvider, oAuthRequest: OAuthRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authorizeWithOAuthToken(provider, oAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the jwks.json file.  You can use the jwks.json file to verify the signature of a JWT token issued by Openfort Auth.
     * @summary Get the jwks.json file.
     * @param {string} publishableKey Specifies the project publishable key (starts with pk_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getJwks(publishableKey: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getJwks(publishableKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initialize OAuth.
     * @param {OAuthInitRequest} oAuthInitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public initOAuth(oAuthInitRequest: OAuthInitRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).initOAuth(oAuthInitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a challenge to link external wallet to the player.
     * @summary Initialize SIWE.
     * @param {SIWERequest} sIWERequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public initSIWE(sIWERequest: SIWERequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).initSIWE(sIWERequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link external wallet.
     * @param {SIWEAuthenticateRequest} sIWEAuthenticateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public linkSIWE(sIWEAuthenticateRequest: SIWEAuthenticateRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).linkSIWE(sIWEAuthenticateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a player based on email and password.
     * @summary Email and password login.
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public loginEmailPassword(loginRequest: LoginRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).loginEmailPassword(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When using Openfort Auth, the endpoint logs out the player.
     * @summary Log out a player.
     * @param {LogoutRequest} logoutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(logoutRequest: LogoutRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(logoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get or create a new session for the player based on the refresh token.
     * @summary Refresh or create auth session.
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public refresh(refreshTokenRequest: RefreshTokenRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refresh(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create and authenticate a player based on email and password.
     * @summary Email and password signup.
     * @param {SignupRequest} signupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signupEmailPassword(signupRequest: SignupRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).signupEmailPassword(signupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink OAuth account
     * @param {LinkRequest} linkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public unlinkOAuth(linkRequest: LinkRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).unlinkOAuth(linkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlink external wallet.
     * @param {SIWERequest} sIWERequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public unlinkSIWE(sIWERequest: SIWERequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).unlinkSIWE(sIWERequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies the token generated by Openfort Auth.
     * @summary Verify auth token.
     * @param {string} token Specifies the auth token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public verifyAuthToken(token: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).verifyAuthToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint verifies the token generated by OAuth provider and retrieves a corresponding player.
     * @summary Retrieve player by oauth token.
     * @param {AuthenticateOAuthRequest} authenticateOAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public verifyOAuth(authenticateOAuthRequest: AuthenticateOAuthRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).verifyOAuth(authenticateOAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The endpoint verifies the token generated by OAuth provider and retrieves a corresponding player.
     * @summary Retrieve player by token.
     * @param {OAuthProvider} provider OAuth provider
     * @param {OAuthRequest} oAuthRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public verifyOAuthToken(provider: OAuthProvider, oAuthRequest: OAuthRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).verifyOAuthToken(provider, oAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractsApi - axios parameter creator
 * @export
 */
export const ContractsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new contract to your project in Openfort
         * @summary Create contract object.
         * @param {CreateContractRequest} createContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract: async (createContractRequest: CreateContractRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createContractRequest' is not null or undefined
            assertParamExists('createContract', 'createContractRequest', createContractRequest)
            const localVarPath = `/v1/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createContractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a contract from the project by providing its contract id.
         * @summary Deletes a contract object.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContract: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteContract', 'id', id)
            const localVarPath = `/v1/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a contract by providing their contract id.
         * @summary Get a contract.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContract: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContract', 'id', id)
            const localVarPath = `/v1/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of all contracts per project. By default, a maximum of ten contracts are shown.
         * @summary List contracts.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [name] Specifies the name of the contract.
         * @param {boolean} [deleted] Specifies whether to include deleted contracts.
         * @param {number} [chainId] The chain ID of the contract.
         * @param {string} [address] Specifies the address of the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContracts: async (limit?: number, skip?: number, order?: SortOrder, name?: string, deleted?: boolean, chainId?: number, address?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Using this endpoint, you can get the data returned by any readable function listed in a contracts ABI. This could be things like querying the totalSupply of a currency contract, the number of owners of an items contract, and more.
         * @summary Read on chain contract data.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {string} functionName The function name of the contract.
         * @param {Array<any>} [functionArgs] The function arguments of the contract, in string format. Accepts pla_, con_ and acc_ IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readContract: async (id: string, functionName: string, functionArgs?: Array<any>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readContract', 'id', id)
            // verify required parameter 'functionName' is not null or undefined
            assertParamExists('readContract', 'functionName', functionName)
            const localVarPath = `/v1/contracts/{id}/read`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (functionName !== undefined) {
                localVarQueryParameter['functionName'] = functionName;
            }

            if (functionArgs) {
                localVarQueryParameter['functionArgs'] = functionArgs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a contract object.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {UpdateContractRequest} updateContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContract: async (id: string, updateContractRequest: UpdateContractRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateContract', 'id', id)
            // verify required parameter 'updateContractRequest' is not null or undefined
            assertParamExists('updateContract', 'updateContractRequest', updateContractRequest)
            const localVarPath = `/v1/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsApi - functional programming interface
 * @export
 */
export const ContractsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new contract to your project in Openfort
         * @summary Create contract object.
         * @param {CreateContractRequest} createContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContract(createContractRequest: CreateContractRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContract(createContractRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a contract from the project by providing its contract id.
         * @summary Deletes a contract object.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContract(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContract(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a contract by providing their contract id.
         * @summary Get a contract.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContract(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContract(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List of all contracts per project. By default, a maximum of ten contracts are shown.
         * @summary List contracts.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [name] Specifies the name of the contract.
         * @param {boolean} [deleted] Specifies whether to include deleted contracts.
         * @param {number} [chainId] The chain ID of the contract.
         * @param {string} [address] Specifies the address of the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContracts(limit?: number, skip?: number, order?: SortOrder, name?: string, deleted?: boolean, chainId?: number, address?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContracts(limit, skip, order, name, deleted, chainId, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Using this endpoint, you can get the data returned by any readable function listed in a contracts ABI. This could be things like querying the totalSupply of a currency contract, the number of owners of an items contract, and more.
         * @summary Read on chain contract data.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {string} functionName The function name of the contract.
         * @param {Array<any>} [functionArgs] The function arguments of the contract, in string format. Accepts pla_, con_ and acc_ IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readContract(id: string, functionName: string, functionArgs?: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractReadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readContract(id, functionName, functionArgs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates a contract object.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {UpdateContractRequest} updateContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContract(id: string, updateContractRequest: UpdateContractRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContract(id, updateContractRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractsApi - factory interface
 * @export
 */
export const ContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractsApiFp(configuration)
    return {
        /**
         * Add a new contract to your project in Openfort
         * @summary Create contract object.
         * @param {CreateContractRequest} createContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract(createContractRequest: CreateContractRequest, options?: any): AxiosPromise<ContractResponse> {
            return localVarFp.createContract(createContractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a contract from the project by providing its contract id.
         * @summary Deletes a contract object.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContract(id: string, options?: any): AxiosPromise<ContractDeleteResponse> {
            return localVarFp.deleteContract(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a contract by providing their contract id.
         * @summary Get a contract.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContract(id: string, options?: any): AxiosPromise<ContractResponse> {
            return localVarFp.getContract(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List of all contracts per project. By default, a maximum of ten contracts are shown.
         * @summary List contracts.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [name] Specifies the name of the contract.
         * @param {boolean} [deleted] Specifies whether to include deleted contracts.
         * @param {number} [chainId] The chain ID of the contract.
         * @param {string} [address] Specifies the address of the contract.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContracts(limit?: number, skip?: number, order?: SortOrder, name?: string, deleted?: boolean, chainId?: number, address?: string, options?: any): AxiosPromise<ContractListResponse> {
            return localVarFp.getContracts(limit, skip, order, name, deleted, chainId, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Using this endpoint, you can get the data returned by any readable function listed in a contracts ABI. This could be things like querying the totalSupply of a currency contract, the number of owners of an items contract, and more.
         * @summary Read on chain contract data.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {string} functionName The function name of the contract.
         * @param {Array<any>} [functionArgs] The function arguments of the contract, in string format. Accepts pla_, con_ and acc_ IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readContract(id: string, functionName: string, functionArgs?: Array<any>, options?: any): AxiosPromise<ContractReadResponse> {
            return localVarFp.readContract(id, functionName, functionArgs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a contract object.
         * @param {string} id Specifies the unique contract ID (starts with con_).
         * @param {UpdateContractRequest} updateContractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContract(id: string, updateContractRequest: UpdateContractRequest, options?: any): AxiosPromise<ContractResponse> {
            return localVarFp.updateContract(id, updateContractRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractsApi - object-oriented interface
 * @export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI {
    /**
     * Add a new contract to your project in Openfort
     * @summary Create contract object.
     * @param {CreateContractRequest} createContractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public createContract(createContractRequest: CreateContractRequest, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).createContract(createContractRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a contract from the project by providing its contract id.
     * @summary Deletes a contract object.
     * @param {string} id Specifies the unique contract ID (starts with con_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public deleteContract(id: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).deleteContract(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a contract by providing their contract id.
     * @summary Get a contract.
     * @param {string} id Specifies the unique contract ID (starts with con_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getContract(id: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getContract(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of all contracts per project. By default, a maximum of ten contracts are shown.
     * @summary List contracts.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {string} [name] Specifies the name of the contract.
     * @param {boolean} [deleted] Specifies whether to include deleted contracts.
     * @param {number} [chainId] The chain ID of the contract.
     * @param {string} [address] Specifies the address of the contract.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public getContracts(limit?: number, skip?: number, order?: SortOrder, name?: string, deleted?: boolean, chainId?: number, address?: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).getContracts(limit, skip, order, name, deleted, chainId, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Using this endpoint, you can get the data returned by any readable function listed in a contracts ABI. This could be things like querying the totalSupply of a currency contract, the number of owners of an items contract, and more.
     * @summary Read on chain contract data.
     * @param {string} id Specifies the unique contract ID (starts with con_).
     * @param {string} functionName The function name of the contract.
     * @param {Array<any>} [functionArgs] The function arguments of the contract, in string format. Accepts pla_, con_ and acc_ IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public readContract(id: string, functionName: string, functionArgs?: Array<any>, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).readContract(id, functionName, functionArgs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a contract object.
     * @param {string} id Specifies the unique contract ID (starts with con_).
     * @param {UpdateContractRequest} updateContractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public updateContract(id: string, updateContractRequest: UpdateContractRequest, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).updateContract(id, updateContractRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EmbeddedApi - axios parameter creator
 * @export
 */
export const EmbeddedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new device for a given account.  This object represents the device that the account owner uses to store the device share. It has an equivalent auth share and recovery share associated with it.
         * @summary Create a device object.
         * @param {CreateDeviceRequest} createDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDevice: async (createDeviceRequest: CreateDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDeviceRequest' is not null or undefined
            assertParamExists('createDevice', 'createDeviceRequest', createDeviceRequest)
            const localVarPath = `/v1/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add the share of for existing device.
         * @summary Create a device share.
         * @param {string} id Specifies the unique device ID (starts with dev_).
         * @param {CreateShareRequest} createShareRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceShare: async (id: string, createShareRequest: CreateShareRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createDeviceShare', 'id', id)
            // verify required parameter 'createShareRequest' is not null or undefined
            assertParamExists('createDeviceShare', 'createShareRequest', createShareRequest)
            const localVarPath = `/v1/devices/{id}/shares`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createShareRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the shares of an existing device.
         * @summary Get existing device shares.
         * @param {string} id Specifies the unique device ID (starts with dev_).
         * @param {string} [shareType] Specifies the type of the share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceShares: async (id: string, shareType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeviceShares', 'id', id)
            const localVarPath = `/v1/devices/{id}/shares`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (shareType !== undefined) {
                localVarQueryParameter['shareType'] = shareType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of devices for the given account.  This object represents the devices where the account owner has device share stored.  Devices are returned sorted by creation date, with the most recently created devices appearing first.  By default, a maximum of 10 devices are shown per page.
         * @summary List devices of account.
         * @param {string} account Specifies the unique account ID (starts with acc_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (account: string, limit?: number, skip?: number, order?: SortOrder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('getDevices', 'account', account)
            const localVarPath = `/v1/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmbeddedApi - functional programming interface
 * @export
 */
export const EmbeddedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmbeddedApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new device for a given account.  This object represents the device that the account owner uses to store the device share. It has an equivalent auth share and recovery share associated with it.
         * @summary Create a device object.
         * @param {CreateDeviceRequest} createDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDevice(createDeviceRequest: CreateDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDevice(createDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add the share of for existing device.
         * @summary Create a device share.
         * @param {string} id Specifies the unique device ID (starts with dev_).
         * @param {CreateShareRequest} createShareRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeviceShare(id: string, createShareRequest: CreateShareRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeviceShare(id, createShareRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the shares of an existing device.
         * @summary Get existing device shares.
         * @param {string} id Specifies the unique device ID (starts with dev_).
         * @param {string} [shareType] Specifies the type of the share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceShares(id: string, shareType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseEntityListResponseShareResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceShares(id, shareType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of devices for the given account.  This object represents the devices where the account owner has device share stored.  Devices are returned sorted by creation date, with the most recently created devices appearing first.  By default, a maximum of 10 devices are shown per page.
         * @summary List devices of account.
         * @param {string} account Specifies the unique account ID (starts with acc_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(account: string, limit?: number, skip?: number, order?: SortOrder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseEntityListResponseDeviceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevices(account, limit, skip, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EmbeddedApi - factory interface
 * @export
 */
export const EmbeddedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmbeddedApiFp(configuration)
    return {
        /**
         * Creates a new device for a given account.  This object represents the device that the account owner uses to store the device share. It has an equivalent auth share and recovery share associated with it.
         * @summary Create a device object.
         * @param {CreateDeviceRequest} createDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDevice(createDeviceRequest: CreateDeviceRequest, options?: any): AxiosPromise<DeviceResponse> {
            return localVarFp.createDevice(createDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add the share of for existing device.
         * @summary Create a device share.
         * @param {string} id Specifies the unique device ID (starts with dev_).
         * @param {CreateShareRequest} createShareRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceShare(id: string, createShareRequest: CreateShareRequest, options?: any): AxiosPromise<ShareResponse> {
            return localVarFp.createDeviceShare(id, createShareRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the shares of an existing device.
         * @summary Get existing device shares.
         * @param {string} id Specifies the unique device ID (starts with dev_).
         * @param {string} [shareType] Specifies the type of the share ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceShares(id: string, shareType?: string, options?: any): AxiosPromise<BaseEntityListResponseShareResponse> {
            return localVarFp.getDeviceShares(id, shareType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of devices for the given account.  This object represents the devices where the account owner has device share stored.  Devices are returned sorted by creation date, with the most recently created devices appearing first.  By default, a maximum of 10 devices are shown per page.
         * @summary List devices of account.
         * @param {string} account Specifies the unique account ID (starts with acc_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(account: string, limit?: number, skip?: number, order?: SortOrder, options?: any): AxiosPromise<BaseEntityListResponseDeviceResponse> {
            return localVarFp.getDevices(account, limit, skip, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmbeddedApi - object-oriented interface
 * @export
 * @class EmbeddedApi
 * @extends {BaseAPI}
 */
export class EmbeddedApi extends BaseAPI {
    /**
     * Creates a new device for a given account.  This object represents the device that the account owner uses to store the device share. It has an equivalent auth share and recovery share associated with it.
     * @summary Create a device object.
     * @param {CreateDeviceRequest} createDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedApi
     */
    public createDevice(createDeviceRequest: CreateDeviceRequest, options?: AxiosRequestConfig) {
        return EmbeddedApiFp(this.configuration).createDevice(createDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add the share of for existing device.
     * @summary Create a device share.
     * @param {string} id Specifies the unique device ID (starts with dev_).
     * @param {CreateShareRequest} createShareRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedApi
     */
    public createDeviceShare(id: string, createShareRequest: CreateShareRequest, options?: AxiosRequestConfig) {
        return EmbeddedApiFp(this.configuration).createDeviceShare(id, createShareRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the shares of an existing device.
     * @summary Get existing device shares.
     * @param {string} id Specifies the unique device ID (starts with dev_).
     * @param {string} [shareType] Specifies the type of the share ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedApi
     */
    public getDeviceShares(id: string, shareType?: string, options?: AxiosRequestConfig) {
        return EmbeddedApiFp(this.configuration).getDeviceShares(id, shareType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of devices for the given account.  This object represents the devices where the account owner has device share stored.  Devices are returned sorted by creation date, with the most recently created devices appearing first.  By default, a maximum of 10 devices are shown per page.
     * @summary List devices of account.
     * @param {string} account Specifies the unique account ID (starts with acc_)
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedApi
     */
    public getDevices(account: string, limit?: number, skip?: number, order?: SortOrder, options?: AxiosRequestConfig) {
        return EmbeddedApiFp(this.configuration).getDevices(account, limit, skip, order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InventoriesApi - axios parameter creator
 * @export
 */
export const InventoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Retrieves the cryptocurrency assets of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCryptoCurrencyInventory: async (id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountCryptoCurrencyInventory', 'id', id)
            const localVarPath = `/v1/accounts/{id}/inventory/cryptocurrency`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (contractId) {
                localVarQueryParameter['contractId'] = contractId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Retrieves the native asset of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountNativeInventory: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountNativeInventory', 'id', id)
            const localVarPath = `/v1/accounts/{id}/inventory/native`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Retrieves the NFT assets of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountNftInventory: async (id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccountNftInventory', 'id', id)
            const localVarPath = `/v1/accounts/{id}/inventory/nft`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (contractId) {
                localVarQueryParameter['contractId'] = contractId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Get cryptocurrency list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contract] Filter by contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerCryptoCurrencyInventory: async (id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contract?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlayerCryptoCurrencyInventory', 'id', id)
            // verify required parameter 'chainId' is not null or undefined
            assertParamExists('getPlayerCryptoCurrencyInventory', 'chainId', chainId)
            const localVarPath = `/v1/players/{id}/inventory/cryptocurrency`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (contract) {
                localVarQueryParameter['contract'] = contract;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Get native token list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerNativeInventory: async (id: string, chainId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlayerNativeInventory', 'id', id)
            // verify required parameter 'chainId' is not null or undefined
            assertParamExists('getPlayerNativeInventory', 'chainId', chainId)
            const localVarPath = `/v1/players/{id}/inventory/native`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Get NFTs list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contract] Filter by contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerNftInventory: async (id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contract?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlayerNftInventory', 'id', id)
            // verify required parameter 'chainId' is not null or undefined
            assertParamExists('getPlayerNftInventory', 'chainId', chainId)
            const localVarPath = `/v1/players/{id}/inventory/nft`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (contract) {
                localVarQueryParameter['contract'] = contract;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoriesApi - functional programming interface
 * @export
 */
export const InventoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InventoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Retrieves the cryptocurrency assets of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountCryptoCurrencyInventory(id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountCryptoCurrencyInventory(id, limit, skip, order, contractId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Retrieves the native asset of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountNativeInventory(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountNativeInventory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Retrieves the NFT assets of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountNftInventory(id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountNftInventory(id, limit, skip, order, contractId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Get cryptocurrency list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contract] Filter by contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerCryptoCurrencyInventory(id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contract?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerCryptoCurrencyInventory(id, chainId, limit, skip, order, contract, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Get native token list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerNativeInventory(id: string, chainId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerNativeInventory(id, chainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Get NFTs list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contract] Filter by contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerNftInventory(id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contract?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerNftInventory(id, chainId, limit, skip, order, contract, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InventoriesApi - factory interface
 * @export
 */
export const InventoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InventoriesApiFp(configuration)
    return {
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Retrieves the cryptocurrency assets of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCryptoCurrencyInventory(id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: any): AxiosPromise<InventoryListResponse> {
            return localVarFp.getAccountCryptoCurrencyInventory(id, limit, skip, order, contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Retrieves the native asset of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountNativeInventory(id: string, options?: any): AxiosPromise<InventoryResponse> {
            return localVarFp.getAccountNativeInventory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Retrieves the NFT assets of an existing account.
         * @param {string} id Specifies the unique account ID.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contractId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountNftInventory(id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: any): AxiosPromise<InventoryListResponse> {
            return localVarFp.getAccountNftInventory(id, limit, skip, order, contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Get cryptocurrency list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contract] Filter by contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerCryptoCurrencyInventory(id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contract?: Array<string>, options?: any): AxiosPromise<InventoryListResponse> {
            return localVarFp.getPlayerCryptoCurrencyInventory(id, chainId, limit, skip, order, contract, options).then((request) => request(axios, basePath));
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Get native token list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerNativeInventory(id: string, chainId: number, options?: any): AxiosPromise<InventoryResponse> {
            return localVarFp.getPlayerNativeInventory(id, chainId, options).then((request) => request(axios, basePath));
        },
        /**
         * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
         * @summary Get NFTs list of player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {number} chainId Filter by chain id.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<string>} [contract] Filter by contract ID (starts with con_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerNftInventory(id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contract?: Array<string>, options?: any): AxiosPromise<InventoryListResponse> {
            return localVarFp.getPlayerNftInventory(id, chainId, limit, skip, order, contract, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InventoriesApi - object-oriented interface
 * @export
 * @class InventoriesApi
 * @extends {BaseAPI}
 */
export class InventoriesApi extends BaseAPI {
    /**
     * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
     * @summary Retrieves the cryptocurrency assets of an existing account.
     * @param {string} id Specifies the unique account ID.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<string>} [contractId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getAccountCryptoCurrencyInventory(id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getAccountCryptoCurrencyInventory(id, limit, skip, order, contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
     * @summary Retrieves the native asset of an existing account.
     * @param {string} id Specifies the unique account ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getAccountNativeInventory(id: string, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getAccountNativeInventory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
     * @summary Retrieves the NFT assets of an existing account.
     * @param {string} id Specifies the unique account ID.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<string>} [contractId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getAccountNftInventory(id: string, limit?: number, skip?: number, order?: SortOrder, contractId?: Array<string>, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getAccountNftInventory(id, limit, skip, order, contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
     * @summary Get cryptocurrency list of player.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {number} chainId Filter by chain id.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<string>} [contract] Filter by contract ID (starts with con_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getPlayerCryptoCurrencyInventory(id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contract?: Array<string>, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getPlayerCryptoCurrencyInventory(id, chainId, limit, skip, order, contract, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
     * @summary Get native token list of player.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {number} chainId Filter by chain id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getPlayerNativeInventory(id: string, chainId: number, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getPlayerNativeInventory(id, chainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For development purposes only.  Under higher load scenarios, this endpoint may be rate limited.
     * @summary Get NFTs list of player.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {number} chainId Filter by chain id.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<string>} [contract] Filter by contract ID (starts with con_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoriesApi
     */
    public getPlayerNftInventory(id: string, chainId: number, limit?: number, skip?: number, order?: SortOrder, contract?: Array<string>, options?: AxiosRequestConfig) {
        return InventoriesApiFp(this.configuration).getPlayerNftInventory(id, chainId, limit, skip, order, contract, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationSubscriptionsApi - axios parameter creator
 * @export
 */
export const NotificationSubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a subscription for the provided notification.
         * @summary Create a notification subscription object.
         * @param {CreateNotificationSubscriptionRequest} createNotificationSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationSubscription: async (createNotificationSubscriptionRequest: CreateNotificationSubscriptionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createNotificationSubscriptionRequest' is not null or undefined
            assertParamExists('createNotificationSubscription', 'createNotificationSubscriptionRequest', createNotificationSubscriptionRequest)
            const localVarPath = `/v1/notification_subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNotificationSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a notification subscription by providing its notification subscription id.
         * @summary Deletes a notification subscription object.
         * @param {string} id Specifies the unique notification subscription ID (starts with ntr_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationSubscription: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNotificationSubscription', 'id', id)
            const localVarPath = `/v1/notification_subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing notification subscription.  Supply the unique notification subscription ID.
         * @summary Get existing notification subscription.
         * @param {string} id Specifies the unique notification subscription ID (starts with not_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscription: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNotificationSubscription', 'id', id)
            const localVarPath = `/v1/notification_subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of subscriptions of a notification.  Subscriptions define the the way you will get notified and the target of the notification.  Subscriptions are returned sorted by creation date, with the most recently created accounts appearing first.  By default, a maximum of 10 notification subscriptions are shown per page.
         * @summary List notification subscriptions of a notification.
         * @param {string} notification Specifies the unique notification ID (starts with not_).
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscriptions: async (notification: string, limit?: number, skip?: number, order?: SortOrder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notification' is not null or undefined
            assertParamExists('getNotificationSubscriptions', 'notification', notification)
            const localVarPath = `/v1/notification_subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (notification !== undefined) {
                localVarQueryParameter['notification'] = notification;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationSubscriptionsApi - functional programming interface
 * @export
 */
export const NotificationSubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationSubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a subscription for the provided notification.
         * @summary Create a notification subscription object.
         * @param {CreateNotificationSubscriptionRequest} createNotificationSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotificationSubscription(createNotificationSubscriptionRequest: CreateNotificationSubscriptionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotificationSubscription(createNotificationSubscriptionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a notification subscription by providing its notification subscription id.
         * @summary Deletes a notification subscription object.
         * @param {string} id Specifies the unique notification subscription ID (starts with ntr_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotificationSubscription(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSubscriptionDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotificationSubscription(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing notification subscription.  Supply the unique notification subscription ID.
         * @summary Get existing notification subscription.
         * @param {string} id Specifies the unique notification subscription ID (starts with not_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationSubscription(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationSubscription(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of subscriptions of a notification.  Subscriptions define the the way you will get notified and the target of the notification.  Subscriptions are returned sorted by creation date, with the most recently created accounts appearing first.  By default, a maximum of 10 notification subscriptions are shown per page.
         * @summary List notification subscriptions of a notification.
         * @param {string} notification Specifies the unique notification ID (starts with not_).
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationSubscriptions(notification: string, limit?: number, skip?: number, order?: SortOrder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationSubscriptionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationSubscriptions(notification, limit, skip, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationSubscriptionsApi - factory interface
 * @export
 */
export const NotificationSubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationSubscriptionsApiFp(configuration)
    return {
        /**
         * Create a subscription for the provided notification.
         * @summary Create a notification subscription object.
         * @param {CreateNotificationSubscriptionRequest} createNotificationSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationSubscription(createNotificationSubscriptionRequest: CreateNotificationSubscriptionRequest, options?: any): AxiosPromise<NotificationSubscription> {
            return localVarFp.createNotificationSubscription(createNotificationSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a notification subscription by providing its notification subscription id.
         * @summary Deletes a notification subscription object.
         * @param {string} id Specifies the unique notification subscription ID (starts with ntr_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationSubscription(id: string, options?: any): AxiosPromise<NotificationSubscriptionDeleteResponse> {
            return localVarFp.deleteNotificationSubscription(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing notification subscription.  Supply the unique notification subscription ID.
         * @summary Get existing notification subscription.
         * @param {string} id Specifies the unique notification subscription ID (starts with not_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscription(id: string, options?: any): AxiosPromise<NotificationSubscription> {
            return localVarFp.getNotificationSubscription(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of subscriptions of a notification.  Subscriptions define the the way you will get notified and the target of the notification.  Subscriptions are returned sorted by creation date, with the most recently created accounts appearing first.  By default, a maximum of 10 notification subscriptions are shown per page.
         * @summary List notification subscriptions of a notification.
         * @param {string} notification Specifies the unique notification ID (starts with not_).
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationSubscriptions(notification: string, limit?: number, skip?: number, order?: SortOrder, options?: any): AxiosPromise<NotificationSubscriptionListResponse> {
            return localVarFp.getNotificationSubscriptions(notification, limit, skip, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationSubscriptionsApi - object-oriented interface
 * @export
 * @class NotificationSubscriptionsApi
 * @extends {BaseAPI}
 */
export class NotificationSubscriptionsApi extends BaseAPI {
    /**
     * Create a subscription for the provided notification.
     * @summary Create a notification subscription object.
     * @param {CreateNotificationSubscriptionRequest} createNotificationSubscriptionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationSubscriptionsApi
     */
    public createNotificationSubscription(createNotificationSubscriptionRequest: CreateNotificationSubscriptionRequest, options?: AxiosRequestConfig) {
        return NotificationSubscriptionsApiFp(this.configuration).createNotificationSubscription(createNotificationSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a notification subscription by providing its notification subscription id.
     * @summary Deletes a notification subscription object.
     * @param {string} id Specifies the unique notification subscription ID (starts with ntr_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationSubscriptionsApi
     */
    public deleteNotificationSubscription(id: string, options?: AxiosRequestConfig) {
        return NotificationSubscriptionsApiFp(this.configuration).deleteNotificationSubscription(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing notification subscription.  Supply the unique notification subscription ID.
     * @summary Get existing notification subscription.
     * @param {string} id Specifies the unique notification subscription ID (starts with not_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationSubscriptionsApi
     */
    public getNotificationSubscription(id: string, options?: AxiosRequestConfig) {
        return NotificationSubscriptionsApiFp(this.configuration).getNotificationSubscription(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of subscriptions of a notification.  Subscriptions define the the way you will get notified and the target of the notification.  Subscriptions are returned sorted by creation date, with the most recently created accounts appearing first.  By default, a maximum of 10 notification subscriptions are shown per page.
     * @summary List notification subscriptions of a notification.
     * @param {string} notification Specifies the unique notification ID (starts with not_).
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationSubscriptionsApi
     */
    public getNotificationSubscriptions(notification: string, limit?: number, skip?: number, order?: SortOrder, options?: AxiosRequestConfig) {
        return NotificationSubscriptionsApiFp(this.configuration).getNotificationSubscriptions(notification, limit, skip, order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationTriggersApi - axios parameter creator
 * @export
 */
export const NotificationTriggersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a trigger for the provided notification.
         * @summary Create a notification trigger object.
         * @param {CreateNotificationTriggerRequest} createNotificationTriggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationTrigger: async (createNotificationTriggerRequest: CreateNotificationTriggerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createNotificationTriggerRequest' is not null or undefined
            assertParamExists('createNotificationTrigger', 'createNotificationTriggerRequest', createNotificationTriggerRequest)
            const localVarPath = `/v1/notification_triggers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNotificationTriggerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a notification trigger by providing its notification trigger id.
         * @summary Deletes a notification trigger object.
         * @param {string} id Specifies the unique notification trigger ID (starts with ntr_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationTrigger: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNotificationTrigger', 'id', id)
            const localVarPath = `/v1/notification_triggers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing notification trigger.  Supply the unique notification trigger ID.
         * @summary Get existing notification trigger.
         * @param {string} id Specifies the unique notification trigger ID (starts with ntr_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationTrigger: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNotificationTrigger', 'id', id)
            const localVarPath = `/v1/notification_triggers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of triggers of a notification.  Triggers define the conditions that will trigger a notification.  Triggers are returned sorted by creation date, with the most recently created accounts appearing first.  By default, a maximum of 10 notification triggers are shown per page.
         * @summary List notification triggers of a notification.
         * @param {string} notification Specifies the unique notification ID (starts with not_).
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationTriggers: async (notification: string, limit?: number, skip?: number, order?: SortOrder, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notification' is not null or undefined
            assertParamExists('getNotificationTriggers', 'notification', notification)
            const localVarPath = `/v1/notification_triggers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (notification !== undefined) {
                localVarQueryParameter['notification'] = notification;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationTriggersApi - functional programming interface
 * @export
 */
export const NotificationTriggersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationTriggersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a trigger for the provided notification.
         * @summary Create a notification trigger object.
         * @param {CreateNotificationTriggerRequest} createNotificationTriggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotificationTrigger(createNotificationTriggerRequest: CreateNotificationTriggerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationTriggerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotificationTrigger(createNotificationTriggerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a notification trigger by providing its notification trigger id.
         * @summary Deletes a notification trigger object.
         * @param {string} id Specifies the unique notification trigger ID (starts with ntr_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotificationTrigger(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationTriggerDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotificationTrigger(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing notification trigger.  Supply the unique notification trigger ID.
         * @summary Get existing notification trigger.
         * @param {string} id Specifies the unique notification trigger ID (starts with ntr_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationTrigger(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationTriggerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationTrigger(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of triggers of a notification.  Triggers define the conditions that will trigger a notification.  Triggers are returned sorted by creation date, with the most recently created accounts appearing first.  By default, a maximum of 10 notification triggers are shown per page.
         * @summary List notification triggers of a notification.
         * @param {string} notification Specifies the unique notification ID (starts with not_).
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationTriggers(notification: string, limit?: number, skip?: number, order?: SortOrder, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationTriggerListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationTriggers(notification, limit, skip, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationTriggersApi - factory interface
 * @export
 */
export const NotificationTriggersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationTriggersApiFp(configuration)
    return {
        /**
         * Create a trigger for the provided notification.
         * @summary Create a notification trigger object.
         * @param {CreateNotificationTriggerRequest} createNotificationTriggerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationTrigger(createNotificationTriggerRequest: CreateNotificationTriggerRequest, options?: any): AxiosPromise<NotificationTriggerResponse> {
            return localVarFp.createNotificationTrigger(createNotificationTriggerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a notification trigger by providing its notification trigger id.
         * @summary Deletes a notification trigger object.
         * @param {string} id Specifies the unique notification trigger ID (starts with ntr_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationTrigger(id: string, options?: any): AxiosPromise<NotificationTriggerDeleteResponse> {
            return localVarFp.deleteNotificationTrigger(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing notification trigger.  Supply the unique notification trigger ID.
         * @summary Get existing notification trigger.
         * @param {string} id Specifies the unique notification trigger ID (starts with ntr_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationTrigger(id: string, options?: any): AxiosPromise<NotificationTriggerResponse> {
            return localVarFp.getNotificationTrigger(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of triggers of a notification.  Triggers define the conditions that will trigger a notification.  Triggers are returned sorted by creation date, with the most recently created accounts appearing first.  By default, a maximum of 10 notification triggers are shown per page.
         * @summary List notification triggers of a notification.
         * @param {string} notification Specifies the unique notification ID (starts with not_).
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationTriggers(notification: string, limit?: number, skip?: number, order?: SortOrder, options?: any): AxiosPromise<NotificationTriggerListResponse> {
            return localVarFp.getNotificationTriggers(notification, limit, skip, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationTriggersApi - object-oriented interface
 * @export
 * @class NotificationTriggersApi
 * @extends {BaseAPI}
 */
export class NotificationTriggersApi extends BaseAPI {
    /**
     * Create a trigger for the provided notification.
     * @summary Create a notification trigger object.
     * @param {CreateNotificationTriggerRequest} createNotificationTriggerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationTriggersApi
     */
    public createNotificationTrigger(createNotificationTriggerRequest: CreateNotificationTriggerRequest, options?: AxiosRequestConfig) {
        return NotificationTriggersApiFp(this.configuration).createNotificationTrigger(createNotificationTriggerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a notification trigger by providing its notification trigger id.
     * @summary Deletes a notification trigger object.
     * @param {string} id Specifies the unique notification trigger ID (starts with ntr_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationTriggersApi
     */
    public deleteNotificationTrigger(id: string, options?: AxiosRequestConfig) {
        return NotificationTriggersApiFp(this.configuration).deleteNotificationTrigger(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing notification trigger.  Supply the unique notification trigger ID.
     * @summary Get existing notification trigger.
     * @param {string} id Specifies the unique notification trigger ID (starts with ntr_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationTriggersApi
     */
    public getNotificationTrigger(id: string, options?: AxiosRequestConfig) {
        return NotificationTriggersApiFp(this.configuration).getNotificationTrigger(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of triggers of a notification.  Triggers define the conditions that will trigger a notification.  Triggers are returned sorted by creation date, with the most recently created accounts appearing first.  By default, a maximum of 10 notification triggers are shown per page.
     * @summary List notification triggers of a notification.
     * @param {string} notification Specifies the unique notification ID (starts with not_).
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationTriggersApi
     */
    public getNotificationTriggers(notification: string, limit?: number, skip?: number, order?: SortOrder, options?: AxiosRequestConfig) {
        return NotificationTriggersApiFp(this.configuration).getNotificationTriggers(notification, limit, skip, order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a notification object.
         * @summary Create a notification object.
         * @param {CreateNotificationRequest} createNotificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification: async (createNotificationRequest: CreateNotificationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createNotificationRequest' is not null or undefined
            assertParamExists('createNotification', 'createNotificationRequest', createNotificationRequest)
            const localVarPath = `/v1/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNotificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a notification by providing its notification id.
         * @summary Deletes a notification object.
         * @param {string} id Specifies the unique notification ID (starts with not_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNotification', 'id', id)
            const localVarPath = `/v1/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing notification.  Supply the unique notification ID.
         * @summary Get existing notification.
         * @param {string} id Specifies the unique notification ID (starts with not_).
         * @param {Array<NotificationResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotification: async (id: string, expand?: Array<NotificationResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNotification', 'id', id)
            const localVarPath = `/v1/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of notifications.  Notifications are useful to get notified about events that happen on-chain or in your Openfort account.  Notifications are returned sorted by creation date, with the most recently created notifications appearing first.  By default, a maximum of 10 notifications are shown per page.
         * @summary List notifications.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<NotificationResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {boolean} [deleted] Specifies whether to include deleted notifications.
         * @param {string} [name] Specifies the name of the notifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (limit?: number, skip?: number, order?: SortOrder, expand?: Array<NotificationResponseExpandable>, deleted?: boolean, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a notification object.
         * @summary Create a notification object.
         * @param {CreateNotificationRequest} createNotificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotification(createNotificationRequest: CreateNotificationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotification(createNotificationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a notification by providing its notification id.
         * @summary Deletes a notification object.
         * @param {string} id Specifies the unique notification ID (starts with not_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotification(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotification(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing notification.  Supply the unique notification ID.
         * @summary Get existing notification.
         * @param {string} id Specifies the unique notification ID (starts with not_).
         * @param {Array<NotificationResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotification(id: string, expand?: Array<NotificationResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotification(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of notifications.  Notifications are useful to get notified about events that happen on-chain or in your Openfort account.  Notifications are returned sorted by creation date, with the most recently created notifications appearing first.  By default, a maximum of 10 notifications are shown per page.
         * @summary List notifications.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<NotificationResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {boolean} [deleted] Specifies whether to include deleted notifications.
         * @param {string} [name] Specifies the name of the notifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(limit?: number, skip?: number, order?: SortOrder, expand?: Array<NotificationResponseExpandable>, deleted?: boolean, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(limit, skip, order, expand, deleted, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * Create a notification object.
         * @summary Create a notification object.
         * @param {CreateNotificationRequest} createNotificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification(createNotificationRequest: CreateNotificationRequest, options?: any): AxiosPromise<NotificationResponse> {
            return localVarFp.createNotification(createNotificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a notification by providing its notification id.
         * @summary Deletes a notification object.
         * @param {string} id Specifies the unique notification ID (starts with not_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification(id: string, options?: any): AxiosPromise<NotificationDeleteResponse> {
            return localVarFp.deleteNotification(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing notification.  Supply the unique notification ID.
         * @summary Get existing notification.
         * @param {string} id Specifies the unique notification ID (starts with not_).
         * @param {Array<NotificationResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotification(id: string, expand?: Array<NotificationResponseExpandable>, options?: any): AxiosPromise<NotificationResponse> {
            return localVarFp.getNotification(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of notifications.  Notifications are useful to get notified about events that happen on-chain or in your Openfort account.  Notifications are returned sorted by creation date, with the most recently created notifications appearing first.  By default, a maximum of 10 notifications are shown per page.
         * @summary List notifications.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<NotificationResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {boolean} [deleted] Specifies whether to include deleted notifications.
         * @param {string} [name] Specifies the name of the notifications.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(limit?: number, skip?: number, order?: SortOrder, expand?: Array<NotificationResponseExpandable>, deleted?: boolean, name?: string, options?: any): AxiosPromise<NotificationListResponse> {
            return localVarFp.getNotifications(limit, skip, order, expand, deleted, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * Create a notification object.
     * @summary Create a notification object.
     * @param {CreateNotificationRequest} createNotificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public createNotification(createNotificationRequest: CreateNotificationRequest, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).createNotification(createNotificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a notification by providing its notification id.
     * @summary Deletes a notification object.
     * @param {string} id Specifies the unique notification ID (starts with not_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public deleteNotification(id: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).deleteNotification(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing notification.  Supply the unique notification ID.
     * @summary Get existing notification.
     * @param {string} id Specifies the unique notification ID (starts with not_).
     * @param {Array<NotificationResponseExpandable>} [expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotification(id: string, expand?: Array<NotificationResponseExpandable>, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).getNotification(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of notifications.  Notifications are useful to get notified about events that happen on-chain or in your Openfort account.  Notifications are returned sorted by creation date, with the most recently created notifications appearing first.  By default, a maximum of 10 notifications are shown per page.
     * @summary List notifications.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<NotificationResponseExpandable>} [expand] Specifies the fields to expand in the response.
     * @param {boolean} [deleted] Specifies whether to include deleted notifications.
     * @param {string} [name] Specifies the name of the notifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotifications(limit?: number, skip?: number, order?: SortOrder, expand?: Array<NotificationResponseExpandable>, deleted?: boolean, name?: string, options?: AxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).getNotifications(limit, skip, order, expand, deleted, name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayersApi - axios parameter creator
 * @export
 */
export const PlayersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows you to cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of a player.
         * @param {string} id 
         * @param {PlayerCancelTransferOwnershipRequest} playerCancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransferAccountOwnership: async (id: string, playerCancelTransferOwnershipRequest: PlayerCancelTransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelTransferAccountOwnership', 'id', id)
            // verify required parameter 'playerCancelTransferOwnershipRequest' is not null or undefined
            assertParamExists('cancelTransferAccountOwnership', 'playerCancelTransferOwnershipRequest', playerCancelTransferOwnershipRequest)
            const localVarPath = `/v1/players/{id}/cancel_transfer_ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerCancelTransferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Player.
         * @summary Create a player object.
         * @param {PlayerCreateRequest} playerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayer: async (playerCreateRequest: PlayerCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playerCreateRequest' is not null or undefined
            assertParamExists('createPlayer', 'playerCreateRequest', playerCreateRequest)
            const localVarPath = `/v1/players`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a player object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlayer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePlayer', 'id', id)
            const localVarPath = `/v1/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the details of an existing player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {Array<PlayerResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer: async (id: string, expand?: Array<PlayerResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlayer', 'id', id)
            const localVarPath = `/v1/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default, a maximum of ten players are shown.
         * @summary List players.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<PlayerResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {string} [name] Filter by player name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayers: async (limit?: number, skip?: number, order?: SortOrder, expand?: Array<PlayerResponseExpandable>, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/players`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTransferAccountOwnership: async (id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('requestTransferAccountOwnership', 'id', id)
            // verify required parameter 'playerTransferOwnershipRequest' is not null or undefined
            assertParamExists('requestTransferAccountOwnership', 'playerTransferOwnershipRequest', playerTransferOwnershipRequest)
            const localVarPath = `/v1/players/{id}/request_transfer_ownership`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerTransferOwnershipRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified Player by setting the values of the parameters passed.
         * @summary Updates a player object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerUpdateRequest} playerUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer: async (id: string, playerUpdateRequest: PlayerUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePlayer', 'id', id)
            // verify required parameter 'playerUpdateRequest' is not null or undefined
            assertParamExists('updatePlayer', 'playerUpdateRequest', playerUpdateRequest)
            const localVarPath = `/v1/players/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayersApi - functional programming interface
 * @export
 */
export const PlayersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayersApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows you to cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of a player.
         * @param {string} id 
         * @param {PlayerCancelTransferOwnershipRequest} playerCancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTransferAccountOwnership(id: string, playerCancelTransferOwnershipRequest: PlayerCancelTransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTransferAccountOwnership(id, playerCancelTransferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Player.
         * @summary Create a player object.
         * @param {PlayerCreateRequest} playerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlayer(playerCreateRequest: PlayerCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlayer(playerCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a player object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlayer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlayer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the details of an existing player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {Array<PlayerResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayer(id: string, expand?: Array<PlayerResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayer(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * By default, a maximum of ten players are shown.
         * @summary List players.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<PlayerResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {string} [name] Filter by player name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayers(limit?: number, skip?: number, order?: SortOrder, expand?: Array<PlayerResponseExpandable>, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayers(limit, skip, order, expand, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestTransferAccountOwnership(id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestTransferAccountOwnership(id, playerTransferOwnershipRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the specified Player by setting the values of the parameters passed.
         * @summary Updates a player object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerUpdateRequest} playerUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlayer(id: string, playerUpdateRequest: PlayerUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlayer(id, playerUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayersApi - factory interface
 * @export
 */
export const PlayersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayersApiFp(configuration)
    return {
        /**
         * This endpoint allows you to cancel a pending transfer of ownership.
         * @summary Cancel request to transfer ownership of a player.
         * @param {string} id 
         * @param {PlayerCancelTransferOwnershipRequest} playerCancelTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTransferAccountOwnership(id: string, playerCancelTransferOwnershipRequest: PlayerCancelTransferOwnershipRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.cancelTransferAccountOwnership(id, playerCancelTransferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Player.
         * @summary Create a player object.
         * @param {PlayerCreateRequest} playerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlayer(playerCreateRequest: PlayerCreateRequest, options?: any): AxiosPromise<PlayerResponse> {
            return localVarFp.createPlayer(playerCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a player object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlayer(id: string, options?: any): AxiosPromise<PlayerDeleteResponse> {
            return localVarFp.deletePlayer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the details of an existing player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {Array<PlayerResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayer(id: string, expand?: Array<PlayerResponseExpandable>, options?: any): AxiosPromise<PlayerResponse> {
            return localVarFp.getPlayer(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * By default, a maximum of ten players are shown.
         * @summary List players.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<PlayerResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {string} [name] Filter by player name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayers(limit?: number, skip?: number, order?: SortOrder, expand?: Array<PlayerResponseExpandable>, name?: string, options?: any): AxiosPromise<PlayerListResponse> {
            return localVarFp.getPlayers(limit, skip, order, expand, name, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
         * @summary Request transfer ownership of a player.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTransferAccountOwnership(id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.requestTransferAccountOwnership(id, playerTransferOwnershipRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified Player by setting the values of the parameters passed.
         * @summary Updates a player object.
         * @param {string} id Specifies the unique player ID (starts with pla_).
         * @param {PlayerUpdateRequest} playerUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlayer(id: string, playerUpdateRequest: PlayerUpdateRequest, options?: any): AxiosPromise<PlayerResponse> {
            return localVarFp.updatePlayer(id, playerUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayersApi - object-oriented interface
 * @export
 * @class PlayersApi
 * @extends {BaseAPI}
 */
export class PlayersApi extends BaseAPI {
    /**
     * This endpoint allows you to cancel a pending transfer of ownership.
     * @summary Cancel request to transfer ownership of a player.
     * @param {string} id 
     * @param {PlayerCancelTransferOwnershipRequest} playerCancelTransferOwnershipRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public cancelTransferAccountOwnership(id: string, playerCancelTransferOwnershipRequest: PlayerCancelTransferOwnershipRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).cancelTransferAccountOwnership(id, playerCancelTransferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Player.
     * @summary Create a player object.
     * @param {PlayerCreateRequest} playerCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public createPlayer(playerCreateRequest: PlayerCreateRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).createPlayer(playerCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a player object.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public deletePlayer(id: string, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).deletePlayer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the details of an existing player.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {Array<PlayerResponseExpandable>} [expand] Specifies the expandable fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public getPlayer(id: string, expand?: Array<PlayerResponseExpandable>, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).getPlayer(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * By default, a maximum of ten players are shown.
     * @summary List players.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<PlayerResponseExpandable>} [expand] Specifies the fields to expand in the response.
     * @param {string} [name] Filter by player name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public getPlayers(limit?: number, skip?: number, order?: SortOrder, expand?: Array<PlayerResponseExpandable>, name?: string, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).getPlayers(limit, skip, order, expand, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to perform a request to change the owner of an account. To perform an update on the owner of an account, first you must provide a new owner address. Once requested, the owner must accept to take ownership by calling `acceptOwnership()` in the smart contract account.
     * @summary Request transfer ownership of a player.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {PlayerTransferOwnershipRequest} playerTransferOwnershipRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public requestTransferAccountOwnership(id: string, playerTransferOwnershipRequest: PlayerTransferOwnershipRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).requestTransferAccountOwnership(id, playerTransferOwnershipRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified Player by setting the values of the parameters passed.
     * @summary Updates a player object.
     * @param {string} id Specifies the unique player ID (starts with pla_).
     * @param {PlayerUpdateRequest} playerUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public updatePlayer(id: string, playerUpdateRequest: PlayerUpdateRequest, options?: AxiosRequestConfig) {
        return PlayersApiFp(this.configuration).updatePlayer(id, playerUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a policy object.
         * @param {CreatePolicyRequest} createPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy: async (createPolicyRequest: CreatePolicyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPolicyRequest' is not null or undefined
            assertParamExists('createPolicy', 'createPolicyRequest', createPolicyRequest)
            const localVarPath = `/v1/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPolicyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfer ERC-20 tokens collected by policy.  When using a policy that includes payment of gas in ERC-20 tokens, this endpoint returns the amount of tokens paid for gas. This is specific to a policy that doesn\'t use your own deposited tokens in the paymaster.
         * @summary Withdraw tokens collected by policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {WithdrawalPolicyRequest} withdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyWithdrawal: async (id: string, withdrawalPolicyRequest: WithdrawalPolicyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPolicyWithdrawal', 'id', id)
            // verify required parameter 'withdrawalPolicyRequest' is not null or undefined
            assertParamExists('createPolicyWithdrawal', 'withdrawalPolicyRequest', withdrawalPolicyRequest)
            const localVarPath = `/v1/policies/{id}/withdraw`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawalPolicyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePolicy', 'id', id)
            const localVarPath = `/v1/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disablePolicy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('disablePolicy', 'id', id)
            const localVarPath = `/v1/policies/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enablePolicy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enablePolicy', 'id', id)
            const localVarPath = `/v1/policies/{id}/enable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Policies.
         * @summary List policies.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {string} [name] Specifies the name of the policy.
         * @param {boolean} [deleted] Specifies whether to include deleted policies.
         * @param {number} [chainId] The chain ID of the policy.
         * @param {boolean} [enabled] Specifies whether to include enabled policies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies: async (limit?: number, skip?: number, order?: SortOrder, expand?: Array<PolicyResponseExpandable>, name?: string, deleted?: boolean, chainId?: number, enabled?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a Policy that has previously been created.
         * @summary Get a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy: async (id: string, expand?: Array<PolicyResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPolicy', 'id', id)
            const localVarPath = `/v1/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the amount of ERC-20 tokens collected by policy.  When using a policy that includes payment of gas in ERC-20 tokens, this endpoint returns the amount of tokens paid for gas. This is specific to a policy that doesn\'t use your own deposited tokens in the paymaster.
         * @summary Get amount of tokens paid for gas policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyBalance: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPolicyBalance', 'id', id)
            const localVarPath = `/v1/policies/{id}/withdraw`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all gas reports of a policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyTotalGasUsage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPolicyTotalGasUsage', 'id', id)
            const localVarPath = `/v1/policies/{id}/reports`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {UpdatePolicyRequest} updatePolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy: async (id: string, updatePolicyRequest: UpdatePolicyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePolicy', 'id', id)
            // verify required parameter 'updatePolicyRequest' is not null or undefined
            assertParamExists('updatePolicy', 'updatePolicyRequest', updatePolicyRequest)
            const localVarPath = `/v1/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePolicyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a policy object.
         * @param {CreatePolicyRequest} createPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicy(createPolicyRequest: CreatePolicyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicy(createPolicyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Transfer ERC-20 tokens collected by policy.  When using a policy that includes payment of gas in ERC-20 tokens, this endpoint returns the amount of tokens paid for gas. This is specific to a policy that doesn\'t use your own deposited tokens in the paymaster.
         * @summary Withdraw tokens collected by policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {WithdrawalPolicyRequest} withdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicyWithdrawal(id: string, withdrawalPolicyRequest: WithdrawalPolicyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicyWithdrawal(id, withdrawalPolicyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Disable a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disablePolicy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disablePolicy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Enable a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enablePolicy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enablePolicy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Policies.
         * @summary List policies.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {string} [name] Specifies the name of the policy.
         * @param {boolean} [deleted] Specifies whether to include deleted policies.
         * @param {number} [chainId] The chain ID of the policy.
         * @param {boolean} [enabled] Specifies whether to include enabled policies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicies(limit?: number, skip?: number, order?: SortOrder, expand?: Array<PolicyResponseExpandable>, name?: string, deleted?: boolean, chainId?: number, enabled?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicies(limit, skip, order, expand, name, deleted, chainId, enabled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of a Policy that has previously been created.
         * @summary Get a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicy(id: string, expand?: Array<PolicyResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicy(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the amount of ERC-20 tokens collected by policy.  When using a policy that includes payment of gas in ERC-20 tokens, this endpoint returns the amount of tokens paid for gas. This is specific to a policy that doesn\'t use your own deposited tokens in the paymaster.
         * @summary Get amount of tokens paid for gas policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyBalance(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyBalanceWithdrawResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyBalance(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all gas reports of a policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyTotalGasUsage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GasReportListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyTotalGasUsage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {UpdatePolicyRequest} updatePolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicy(id: string, updatePolicyRequest: UpdatePolicyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicy(id, updatePolicyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a policy object.
         * @param {CreatePolicyRequest} createPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy(createPolicyRequest: CreatePolicyRequest, options?: any): AxiosPromise<PolicyResponse> {
            return localVarFp.createPolicy(createPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Transfer ERC-20 tokens collected by policy.  When using a policy that includes payment of gas in ERC-20 tokens, this endpoint returns the amount of tokens paid for gas. This is specific to a policy that doesn\'t use your own deposited tokens in the paymaster.
         * @summary Withdraw tokens collected by policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {WithdrawalPolicyRequest} withdrawalPolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyWithdrawal(id: string, withdrawalPolicyRequest: WithdrawalPolicyRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.createPolicyWithdrawal(id, withdrawalPolicyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(id: string, options?: any): AxiosPromise<PolicyDeleteResponse> {
            return localVarFp.deletePolicy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disable a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disablePolicy(id: string, options?: any): AxiosPromise<PolicyResponse> {
            return localVarFp.disablePolicy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enable a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enablePolicy(id: string, options?: any): AxiosPromise<PolicyResponse> {
            return localVarFp.enablePolicy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Policies.
         * @summary List policies.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {string} [name] Specifies the name of the policy.
         * @param {boolean} [deleted] Specifies whether to include deleted policies.
         * @param {number} [chainId] The chain ID of the policy.
         * @param {boolean} [enabled] Specifies whether to include enabled policies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies(limit?: number, skip?: number, order?: SortOrder, expand?: Array<PolicyResponseExpandable>, name?: string, deleted?: boolean, chainId?: number, enabled?: boolean, options?: any): AxiosPromise<PolicyListResponse> {
            return localVarFp.getPolicies(limit, skip, order, expand, name, deleted, chainId, enabled, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a Policy that has previously been created.
         * @summary Get a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(id: string, expand?: Array<PolicyResponseExpandable>, options?: any): AxiosPromise<PolicyResponse> {
            return localVarFp.getPolicy(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the amount of ERC-20 tokens collected by policy.  When using a policy that includes payment of gas in ERC-20 tokens, this endpoint returns the amount of tokens paid for gas. This is specific to a policy that doesn\'t use your own deposited tokens in the paymaster.
         * @summary Get amount of tokens paid for gas policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyBalance(id: string, options?: any): AxiosPromise<PolicyBalanceWithdrawResponse> {
            return localVarFp.getPolicyBalance(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all gas reports of a policy.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyTotalGasUsage(id: string, options?: any): AxiosPromise<GasReportListResponse> {
            return localVarFp.getPolicyTotalGasUsage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a policy object.
         * @param {string} id Specifies the unique policy ID (starts with pol_).
         * @param {UpdatePolicyRequest} updatePolicyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(id: string, updatePolicyRequest: UpdatePolicyRequest, options?: any): AxiosPromise<PolicyResponse> {
            return localVarFp.updatePolicy(id, updatePolicyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * 
     * @summary Create a policy object.
     * @param {CreatePolicyRequest} createPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createPolicy(createPolicyRequest: CreatePolicyRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createPolicy(createPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transfer ERC-20 tokens collected by policy.  When using a policy that includes payment of gas in ERC-20 tokens, this endpoint returns the amount of tokens paid for gas. This is specific to a policy that doesn\'t use your own deposited tokens in the paymaster.
     * @summary Withdraw tokens collected by policy.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {WithdrawalPolicyRequest} withdrawalPolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createPolicyWithdrawal(id: string, withdrawalPolicyRequest: WithdrawalPolicyRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createPolicyWithdrawal(id, withdrawalPolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a policy object.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public deletePolicy(id: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).deletePolicy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disable a policy object.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public disablePolicy(id: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).disablePolicy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enable a policy object.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public enablePolicy(id: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).enablePolicy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Policies.
     * @summary List policies.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand in the response.
     * @param {string} [name] Specifies the name of the policy.
     * @param {boolean} [deleted] Specifies whether to include deleted policies.
     * @param {number} [chainId] The chain ID of the policy.
     * @param {boolean} [enabled] Specifies whether to include enabled policies.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicies(limit?: number, skip?: number, order?: SortOrder, expand?: Array<PolicyResponseExpandable>, name?: string, deleted?: boolean, chainId?: number, enabled?: boolean, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicies(limit, skip, order, expand, name, deleted, chainId, enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a Policy that has previously been created.
     * @summary Get a policy object.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {Array<PolicyResponseExpandable>} [expand] Specifies the fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicy(id: string, expand?: Array<PolicyResponseExpandable>, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicy(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the amount of ERC-20 tokens collected by policy.  When using a policy that includes payment of gas in ERC-20 tokens, this endpoint returns the amount of tokens paid for gas. This is specific to a policy that doesn\'t use your own deposited tokens in the paymaster.
     * @summary Get amount of tokens paid for gas policy.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicyBalance(id: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicyBalance(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all gas reports of a policy.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicyTotalGasUsage(id: string, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicyTotalGasUsage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a policy object.
     * @param {string} id Specifies the unique policy ID (starts with pol_).
     * @param {UpdatePolicyRequest} updatePolicyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public updatePolicy(id: string, updatePolicyRequest: UpdatePolicyRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updatePolicy(id, updatePolicyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PolicyRulesApi - axios parameter creator
 * @export
 */
export const PolicyRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a policy rule object.
         * @param {CreatePolicyRuleRequest} createPolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyRule: async (createPolicyRuleRequest: CreatePolicyRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPolicyRuleRequest' is not null or undefined
            assertParamExists('createPolicyRule', 'createPolicyRuleRequest', createPolicyRuleRequest)
            const localVarPath = `/v1/policy_rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPolicyRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a policy rule object.
         * @param {string} id Specifies the unique policy rule ID (starts with afu_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicyRule: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePolicyRule', 'id', id)
            const localVarPath = `/v1/policy_rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of policy rules of a policy.  The policy rules are returned sorted by creation date, with the most recently created policy rules appearing first.  By default, a maximum of 10 policy rules are shown per page.
         * @summary List policy rules of a policy.
         * @param {string} policy Specifies the unique policy ID (starts with pol_).
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<'contract'>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyRules: async (policy: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<'contract'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policy' is not null or undefined
            assertParamExists('getPolicyRules', 'policy', policy)
            const localVarPath = `/v1/policy_rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (policy !== undefined) {
                localVarQueryParameter['policy'] = policy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a policy rule object.
         * @param {string} id Specifies the unique policy rule ID (starts with afu_).
         * @param {UpdatePolicyRuleRequest} updatePolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyRule: async (id: string, updatePolicyRuleRequest: UpdatePolicyRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePolicyRule', 'id', id)
            // verify required parameter 'updatePolicyRuleRequest' is not null or undefined
            assertParamExists('updatePolicyRule', 'updatePolicyRuleRequest', updatePolicyRuleRequest)
            const localVarPath = `/v1/policy_rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePolicyRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolicyRulesApi - functional programming interface
 * @export
 */
export const PolicyRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PolicyRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a policy rule object.
         * @param {CreatePolicyRuleRequest} createPolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicyRule(createPolicyRuleRequest: CreatePolicyRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicyRule(createPolicyRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a policy rule object.
         * @param {string} id Specifies the unique policy rule ID (starts with afu_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicyRule(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicyRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of policy rules of a policy.  The policy rules are returned sorted by creation date, with the most recently created policy rules appearing first.  By default, a maximum of 10 policy rules are shown per page.
         * @summary List policy rules of a policy.
         * @param {string} policy Specifies the unique policy ID (starts with pol_).
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<'contract'>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyRules(policy: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<'contract'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyRules(policy, limit, skip, order, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a policy rule object.
         * @param {string} id Specifies the unique policy rule ID (starts with afu_).
         * @param {UpdatePolicyRuleRequest} updatePolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicyRule(id: string, updatePolicyRuleRequest: UpdatePolicyRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicyRule(id, updatePolicyRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PolicyRulesApi - factory interface
 * @export
 */
export const PolicyRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PolicyRulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a policy rule object.
         * @param {CreatePolicyRuleRequest} createPolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyRule(createPolicyRuleRequest: CreatePolicyRuleRequest, options?: any): AxiosPromise<PolicyRuleResponse> {
            return localVarFp.createPolicyRule(createPolicyRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a policy rule object.
         * @param {string} id Specifies the unique policy rule ID (starts with afu_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicyRule(id: string, options?: any): AxiosPromise<PolicyRuleDeleteResponse> {
            return localVarFp.deletePolicyRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of policy rules of a policy.  The policy rules are returned sorted by creation date, with the most recently created policy rules appearing first.  By default, a maximum of 10 policy rules are shown per page.
         * @summary List policy rules of a policy.
         * @param {string} policy Specifies the unique policy ID (starts with pol_).
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<'contract'>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyRules(policy: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<'contract'>, options?: any): AxiosPromise<PolicyRuleListResponse> {
            return localVarFp.getPolicyRules(policy, limit, skip, order, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a policy rule object.
         * @param {string} id Specifies the unique policy rule ID (starts with afu_).
         * @param {UpdatePolicyRuleRequest} updatePolicyRuleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyRule(id: string, updatePolicyRuleRequest: UpdatePolicyRuleRequest, options?: any): AxiosPromise<PolicyRuleResponse> {
            return localVarFp.updatePolicyRule(id, updatePolicyRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PolicyRulesApi - object-oriented interface
 * @export
 * @class PolicyRulesApi
 * @extends {BaseAPI}
 */
export class PolicyRulesApi extends BaseAPI {
    /**
     * 
     * @summary Create a policy rule object.
     * @param {CreatePolicyRuleRequest} createPolicyRuleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyRulesApi
     */
    public createPolicyRule(createPolicyRuleRequest: CreatePolicyRuleRequest, options?: AxiosRequestConfig) {
        return PolicyRulesApiFp(this.configuration).createPolicyRule(createPolicyRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a policy rule object.
     * @param {string} id Specifies the unique policy rule ID (starts with afu_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyRulesApi
     */
    public deletePolicyRule(id: string, options?: AxiosRequestConfig) {
        return PolicyRulesApiFp(this.configuration).deletePolicyRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of policy rules of a policy.  The policy rules are returned sorted by creation date, with the most recently created policy rules appearing first.  By default, a maximum of 10 policy rules are shown per page.
     * @summary List policy rules of a policy.
     * @param {string} policy Specifies the unique policy ID (starts with pol_).
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<'contract'>} [expand] Specifies the fields to expand in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyRulesApi
     */
    public getPolicyRules(policy: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<'contract'>, options?: AxiosRequestConfig) {
        return PolicyRulesApiFp(this.configuration).getPolicyRules(policy, limit, skip, order, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a policy rule object.
     * @param {string} id Specifies the unique policy rule ID (starts with afu_).
     * @param {UpdatePolicyRuleRequest} updatePolicyRuleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyRulesApi
     */
    public updatePolicyRule(id: string, updatePolicyRuleRequest: UpdatePolicyRuleRequest, options?: AxiosRequestConfig) {
        return PolicyRulesApiFp(this.configuration).updatePolicyRule(id, updatePolicyRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a Session.
         * @summary Create a session key.
         * @param {CreateSessionRequest} createSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession: async (createSessionRequest: CreateSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSessionRequest' is not null or undefined
            assertParamExists('createSession', 'createSessionRequest', createSessionRequest)
            const localVarPath = `/v1/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Sessions.
         * @summary List session keys of a player.
         * @param {string} player The player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerSessions: async (player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<SessionResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'player' is not null or undefined
            assertParamExists('getPlayerSessions', 'player', player)
            const localVarPath = `/v1/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a Session that has previously been created.
         * @summary Returns a player session by session id
         * @param {string} id Specifies the unique session ID (starts with ses_).
         * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (id: string, expand?: Array<SessionResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSession', 'id', id)
            const localVarPath = `/v1/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke the session session key.
         * @param {RevokeSessionRequest} revokeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeSession: async (revokeSessionRequest: RevokeSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'revokeSessionRequest' is not null or undefined
            assertParamExists('revokeSession', 'revokeSessionRequest', revokeSessionRequest)
            const localVarPath = `/v1/sessions/revoke`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revokeSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send signed userOperationHash to create session.
         * @param {string} id Specifies the unique session ID (starts with ses_).
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signatureSession: async (id: string, signatureRequest: SignatureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signatureSession', 'id', id)
            // verify required parameter 'signatureRequest' is not null or undefined
            assertParamExists('signatureSession', 'signatureRequest', signatureRequest)
            const localVarPath = `/v1/sessions/{id}/signature`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a Session.
         * @summary Create a session key.
         * @param {CreateSessionRequest} createSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSession(createSessionRequest: CreateSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(createSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Sessions.
         * @summary List session keys of a player.
         * @param {string} player The player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayerSessions(player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<SessionResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlayerSessions(player, limit, skip, order, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of a Session that has previously been created.
         * @summary Returns a player session by session id
         * @param {string} id Specifies the unique session ID (starts with ses_).
         * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(id: string, expand?: Array<SessionResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Revoke the session session key.
         * @param {RevokeSessionRequest} revokeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeSession(revokeSessionRequest: RevokeSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeSession(revokeSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send signed userOperationHash to create session.
         * @param {string} id Specifies the unique session ID (starts with ses_).
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signatureSession(id: string, signatureRequest: SignatureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signatureSession(id, signatureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * Creates a Session.
         * @summary Create a session key.
         * @param {CreateSessionRequest} createSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(createSessionRequest: CreateSessionRequest, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.createSession(createSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Sessions.
         * @summary List session keys of a player.
         * @param {string} player The player ID (starts with pla_)
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayerSessions(player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<SessionResponseExpandable>, options?: any): AxiosPromise<SessionListResponse> {
            return localVarFp.getPlayerSessions(player, limit, skip, order, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a Session that has previously been created.
         * @summary Returns a player session by session id
         * @param {string} id Specifies the unique session ID (starts with ses_).
         * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(id: string, expand?: Array<SessionResponseExpandable>, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.getSession(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke the session session key.
         * @param {RevokeSessionRequest} revokeSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeSession(revokeSessionRequest: RevokeSessionRequest, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.revokeSession(revokeSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send signed userOperationHash to create session.
         * @param {string} id Specifies the unique session ID (starts with ses_).
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signatureSession(id: string, signatureRequest: SignatureRequest, options?: any): AxiosPromise<SessionResponse> {
            return localVarFp.signatureSession(id, signatureRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * Creates a Session.
     * @summary Create a session key.
     * @param {CreateSessionRequest} createSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public createSession(createSessionRequest: CreateSessionRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).createSession(createSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Sessions.
     * @summary List session keys of a player.
     * @param {string} player The player ID (starts with pla_)
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getPlayerSessions(player: string, limit?: number, skip?: number, order?: SortOrder, expand?: Array<SessionResponseExpandable>, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getPlayerSessions(player, limit, skip, order, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a Session that has previously been created.
     * @summary Returns a player session by session id
     * @param {string} id Specifies the unique session ID (starts with ses_).
     * @param {Array<SessionResponseExpandable>} [expand] Specifies the fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getSession(id: string, expand?: Array<SessionResponseExpandable>, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).getSession(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke the session session key.
     * @param {RevokeSessionRequest} revokeSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public revokeSession(revokeSessionRequest: RevokeSessionRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).revokeSession(revokeSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send signed userOperationHash to create session.
     * @param {string} id Specifies the unique session ID (starts with ses_).
     * @param {SignatureRequest} signatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public signatureSession(id: string, signatureRequest: SignatureRequest, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).signatureSession(id, signatureRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create or add a developer account. Developer accounts can be used as for escrow, minting and transferring assets. To add your own external account, add a signature and the address of the account. This verified account can then be used as a verified depositor
         * @summary Create a developer account.
         * @param {DeveloperAccountCreateRequest} developerAccountCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeveloperAccount: async (developerAccountCreateRequest: DeveloperAccountCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'developerAccountCreateRequest' is not null or undefined
            assertParamExists('createDeveloperAccount', 'developerAccountCreateRequest', developerAccountCreateRequest)
            const localVarPath = `/v1/settings/developer_accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(developerAccountCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a developer account from the current project.
         * @summary Delete a developer account.
         * @param {string} id Specifies a unique developer account (starts with dac_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeveloperAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDeveloperAccount', 'id', id)
            const localVarPath = `/v1/settings/developer_accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a developer account.
         * @summary Get existing developer account.
         * @param {string} id Specifies the unique developer account ID (starts with dac_).
         * @param {Array<DeveloperAccountResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperAccount: async (id: string, expand?: Array<DeveloperAccountResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeveloperAccount', 'id', id)
            const localVarPath = `/v1/settings/developer_accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the list of the developer accounts for the current project.  By default, a maximum of 10 accounts are shown per page.
         * @summary List of developer accounts.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<DeveloperAccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {boolean} [deleted] Specifies whether to include deleted dev accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperAccounts: async (limit?: number, skip?: number, order?: SortOrder, expand?: Array<DeveloperAccountResponseExpandable>, deleted?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/settings/developer_accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate message, which should be signed by the account your want to add as a developer account.
         * @summary Generate message to sign
         * @param {string} address Specifies the address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationPayload: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getVerificationPayload', 'address', address)
            const localVarPath = `/v1/settings/developer_accounts/message_to_sign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updated the current project environment settings by removing the webhook address. After that system will stop sending events of the transaction intent state changes
         * @summary Removes webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/settings/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updated the current project environment settings by assigning the webhook address. This address is used to send events about the changes of the transaction intent state.
         * @summary Update webhook.
         * @param {SettingsWebhookUpdateRequest} settingsWebhookUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (settingsWebhookUpdateRequest: SettingsWebhookUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingsWebhookUpdateRequest' is not null or undefined
            assertParamExists('updateWebhook', 'settingsWebhookUpdateRequest', settingsWebhookUpdateRequest)
            const localVarPath = `/v1/settings/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsWebhookUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create or add a developer account. Developer accounts can be used as for escrow, minting and transferring assets. To add your own external account, add a signature and the address of the account. This verified account can then be used as a verified depositor
         * @summary Create a developer account.
         * @param {DeveloperAccountCreateRequest} developerAccountCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeveloperAccount(developerAccountCreateRequest: DeveloperAccountCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeveloperAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeveloperAccount(developerAccountCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a developer account from the current project.
         * @summary Delete a developer account.
         * @param {string} id Specifies a unique developer account (starts with dac_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeveloperAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeveloperAccountDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeveloperAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a developer account.
         * @summary Get existing developer account.
         * @param {string} id Specifies the unique developer account ID (starts with dac_).
         * @param {Array<DeveloperAccountResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeveloperAccount(id: string, expand?: Array<DeveloperAccountResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeveloperAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeveloperAccount(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the list of the developer accounts for the current project.  By default, a maximum of 10 accounts are shown per page.
         * @summary List of developer accounts.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<DeveloperAccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {boolean} [deleted] Specifies whether to include deleted dev accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeveloperAccounts(limit?: number, skip?: number, order?: SortOrder, expand?: Array<DeveloperAccountResponseExpandable>, deleted?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeveloperAccountListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeveloperAccounts(limit, skip, order, expand, deleted, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate message, which should be signed by the account your want to add as a developer account.
         * @summary Generate message to sign
         * @param {string} address Specifies the address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerificationPayload(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeveloperAccountGetMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVerificationPayload(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updated the current project environment settings by removing the webhook address. After that system will stop sending events of the transaction intent state changes
         * @summary Removes webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeWebhook(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeWebhook(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updated the current project environment settings by assigning the webhook address. This address is used to send events about the changes of the transaction intent state.
         * @summary Update webhook.
         * @param {SettingsWebhookUpdateRequest} settingsWebhookUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(settingsWebhookUpdateRequest: SettingsWebhookUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(settingsWebhookUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * Create or add a developer account. Developer accounts can be used as for escrow, minting and transferring assets. To add your own external account, add a signature and the address of the account. This verified account can then be used as a verified depositor
         * @summary Create a developer account.
         * @param {DeveloperAccountCreateRequest} developerAccountCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeveloperAccount(developerAccountCreateRequest: DeveloperAccountCreateRequest, options?: any): AxiosPromise<DeveloperAccountResponse> {
            return localVarFp.createDeveloperAccount(developerAccountCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a developer account from the current project.
         * @summary Delete a developer account.
         * @param {string} id Specifies a unique developer account (starts with dac_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeveloperAccount(id: string, options?: any): AxiosPromise<DeveloperAccountDeleteResponse> {
            return localVarFp.deleteDeveloperAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a developer account.
         * @summary Get existing developer account.
         * @param {string} id Specifies the unique developer account ID (starts with dac_).
         * @param {Array<DeveloperAccountResponseExpandable>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperAccount(id: string, expand?: Array<DeveloperAccountResponseExpandable>, options?: any): AxiosPromise<DeveloperAccountResponse> {
            return localVarFp.getDeveloperAccount(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the list of the developer accounts for the current project.  By default, a maximum of 10 accounts are shown per page.
         * @summary List of developer accounts.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<DeveloperAccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {boolean} [deleted] Specifies whether to include deleted dev accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeveloperAccounts(limit?: number, skip?: number, order?: SortOrder, expand?: Array<DeveloperAccountResponseExpandable>, deleted?: boolean, options?: any): AxiosPromise<DeveloperAccountListResponse> {
            return localVarFp.getDeveloperAccounts(limit, skip, order, expand, deleted, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate message, which should be signed by the account your want to add as a developer account.
         * @summary Generate message to sign
         * @param {string} address Specifies the address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationPayload(address: string, options?: any): AxiosPromise<DeveloperAccountGetMessageResponse> {
            return localVarFp.getVerificationPayload(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Updated the current project environment settings by removing the webhook address. After that system will stop sending events of the transaction intent state changes
         * @summary Removes webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(options?: any): AxiosPromise<void> {
            return localVarFp.removeWebhook(options).then((request) => request(axios, basePath));
        },
        /**
         * Updated the current project environment settings by assigning the webhook address. This address is used to send events about the changes of the transaction intent state.
         * @summary Update webhook.
         * @param {SettingsWebhookUpdateRequest} settingsWebhookUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(settingsWebhookUpdateRequest: SettingsWebhookUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateWebhook(settingsWebhookUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * Create or add a developer account. Developer accounts can be used as for escrow, minting and transferring assets. To add your own external account, add a signature and the address of the account. This verified account can then be used as a verified depositor
     * @summary Create a developer account.
     * @param {DeveloperAccountCreateRequest} developerAccountCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public createDeveloperAccount(developerAccountCreateRequest: DeveloperAccountCreateRequest, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).createDeveloperAccount(developerAccountCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a developer account from the current project.
     * @summary Delete a developer account.
     * @param {string} id Specifies a unique developer account (starts with dac_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public deleteDeveloperAccount(id: string, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).deleteDeveloperAccount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a developer account.
     * @summary Get existing developer account.
     * @param {string} id Specifies the unique developer account ID (starts with dac_).
     * @param {Array<DeveloperAccountResponseExpandable>} [expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getDeveloperAccount(id: string, expand?: Array<DeveloperAccountResponseExpandable>, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getDeveloperAccount(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the list of the developer accounts for the current project.  By default, a maximum of 10 accounts are shown per page.
     * @summary List of developer accounts.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<DeveloperAccountResponseExpandable>} [expand] Specifies the fields to expand in the response.
     * @param {boolean} [deleted] Specifies whether to include deleted dev accounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getDeveloperAccounts(limit?: number, skip?: number, order?: SortOrder, expand?: Array<DeveloperAccountResponseExpandable>, deleted?: boolean, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getDeveloperAccounts(limit, skip, order, expand, deleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate message, which should be signed by the account your want to add as a developer account.
     * @summary Generate message to sign
     * @param {string} address Specifies the address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getVerificationPayload(address: string, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).getVerificationPayload(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updated the current project environment settings by removing the webhook address. After that system will stop sending events of the transaction intent state changes
     * @summary Removes webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public removeWebhook(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).removeWebhook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updated the current project environment settings by assigning the webhook address. This address is used to send events about the changes of the transaction intent state.
     * @summary Update webhook.
     * @param {SettingsWebhookUpdateRequest} settingsWebhookUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public updateWebhook(settingsWebhookUpdateRequest: SettingsWebhookUpdateRequest, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).updateWebhook(settingsWebhookUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionIntentsApi - axios parameter creator
 * @export
 */
export const TransactionIntentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a TransactionIntent.  A pending TransactionIntent has the `response` attribute as undefined.  After the TransactionIntent is created and broadcasted to the blockchain, `response` will be populated with the transaction hash and a status (1 success, 0 fail).  When using a non-custodial account, a `nextAction` attribute is returned with the `userOperationHash` that must be signed by the owner of the account.
         * @summary Create a transaction intent object.
         * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionIntent: async (createTransactionIntentRequest: CreateTransactionIntentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransactionIntentRequest' is not null or undefined
            assertParamExists('createTransactionIntent', 'createTransactionIntentRequest', createTransactionIntentRequest)
            const localVarPath = `/v1/transaction_intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransactionIntentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Estimate the gas cost of broadcasting a TransactionIntent.  This is a simulation, it does not send the transaction on-chain.  If a Policy ID is used that includes payment of gas in ERC-20 tokens, an extra field `estimatedTXGasFeeToken` is returned with the estimated amount of tokens that will be used.
         * @summary Estimate gas cost of creating a transaction
         * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateTransactionIntentCost: async (createTransactionIntentRequest: CreateTransactionIntentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransactionIntentRequest' is not null or undefined
            assertParamExists('estimateTransactionIntentCost', 'createTransactionIntentRequest', createTransactionIntentRequest)
            const localVarPath = `/v1/transaction_intents/estimate_gas_cost`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransactionIntentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a TransactionIntent that has previously been created.
         * @summary Get a transaction intent object.
         * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
         * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionIntent: async (id: string, expand?: Array<TransactionIntentResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransactionIntent', 'id', id)
            const localVarPath = `/v1/transaction_intents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of TransactionIntents.
         * @summary List transaction intents.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {number} [chainId] The chain ID. Must be a [supported chain](/chains).
         * @param {Array<string>} [account] Filter by account ID or developer account (starts with acc_ or dac_ respectively).
         * @param {Array<string>} [player] Filter by player ID (starts with pla_).
         * @param {number} [status] Filter by successful (1) or failed (0) transaction intents.
         * @param {Array<string>} [policy] Filter by policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionIntents: async (limit?: number, skip?: number, order?: SortOrder, expand?: Array<TransactionIntentResponseExpandable>, chainId?: number, account?: Array<string>, player?: Array<string>, status?: number, policy?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/transaction_intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (account) {
                localVarQueryParameter['account'] = account;
            }

            if (player) {
                localVarQueryParameter['player'] = player;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (policy) {
                localVarQueryParameter['policy'] = policy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Broadcasts a signed TransactionIntent to the blockchain.  Use this endpoint to send the signed `userOperationHash`. Openfort will then put it on-chain.
         * @summary Send a signed transaction userOperationHash.
         * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signature: async (id: string, signatureRequest: SignatureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('signature', 'id', id)
            // verify required parameter 'signatureRequest' is not null or undefined
            assertParamExists('signature', 'signatureRequest', signatureRequest)
            const localVarPath = `/v1/transaction_intents/{id}/signature`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication pk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signatureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionIntentsApi - functional programming interface
 * @export
 */
export const TransactionIntentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionIntentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a TransactionIntent.  A pending TransactionIntent has the `response` attribute as undefined.  After the TransactionIntent is created and broadcasted to the blockchain, `response` will be populated with the transaction hash and a status (1 success, 0 fail).  When using a non-custodial account, a `nextAction` attribute is returned with the `userOperationHash` that must be signed by the owner of the account.
         * @summary Create a transaction intent object.
         * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransactionIntent(createTransactionIntentRequest: CreateTransactionIntentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransactionIntent(createTransactionIntentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Estimate the gas cost of broadcasting a TransactionIntent.  This is a simulation, it does not send the transaction on-chain.  If a Policy ID is used that includes payment of gas in ERC-20 tokens, an extra field `estimatedTXGasFeeToken` is returned with the estimated amount of tokens that will be used.
         * @summary Estimate gas cost of creating a transaction
         * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateTransactionIntentCost(createTransactionIntentRequest: CreateTransactionIntentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EstimateTransactionIntentGasResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateTransactionIntentCost(createTransactionIntentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of a TransactionIntent that has previously been created.
         * @summary Get a transaction intent object.
         * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
         * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionIntent(id: string, expand?: Array<TransactionIntentResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionIntent(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of TransactionIntents.
         * @summary List transaction intents.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {number} [chainId] The chain ID. Must be a [supported chain](/chains).
         * @param {Array<string>} [account] Filter by account ID or developer account (starts with acc_ or dac_ respectively).
         * @param {Array<string>} [player] Filter by player ID (starts with pla_).
         * @param {number} [status] Filter by successful (1) or failed (0) transaction intents.
         * @param {Array<string>} [policy] Filter by policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionIntents(limit?: number, skip?: number, order?: SortOrder, expand?: Array<TransactionIntentResponseExpandable>, chainId?: number, account?: Array<string>, player?: Array<string>, status?: number, policy?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionIntents(limit, skip, order, expand, chainId, account, player, status, policy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Broadcasts a signed TransactionIntent to the blockchain.  Use this endpoint to send the signed `userOperationHash`. Openfort will then put it on-chain.
         * @summary Send a signed transaction userOperationHash.
         * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signature(id: string, signatureRequest: SignatureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signature(id, signatureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionIntentsApi - factory interface
 * @export
 */
export const TransactionIntentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionIntentsApiFp(configuration)
    return {
        /**
         * Creates a TransactionIntent.  A pending TransactionIntent has the `response` attribute as undefined.  After the TransactionIntent is created and broadcasted to the blockchain, `response` will be populated with the transaction hash and a status (1 success, 0 fail).  When using a non-custodial account, a `nextAction` attribute is returned with the `userOperationHash` that must be signed by the owner of the account.
         * @summary Create a transaction intent object.
         * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionIntent(createTransactionIntentRequest: CreateTransactionIntentRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.createTransactionIntent(createTransactionIntentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Estimate the gas cost of broadcasting a TransactionIntent.  This is a simulation, it does not send the transaction on-chain.  If a Policy ID is used that includes payment of gas in ERC-20 tokens, an extra field `estimatedTXGasFeeToken` is returned with the estimated amount of tokens that will be used.
         * @summary Estimate gas cost of creating a transaction
         * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateTransactionIntentCost(createTransactionIntentRequest: CreateTransactionIntentRequest, options?: any): AxiosPromise<EstimateTransactionIntentGasResult> {
            return localVarFp.estimateTransactionIntentCost(createTransactionIntentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a TransactionIntent that has previously been created.
         * @summary Get a transaction intent object.
         * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
         * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the expandable fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionIntent(id: string, expand?: Array<TransactionIntentResponseExpandable>, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.getTransactionIntent(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of TransactionIntents.
         * @summary List transaction intents.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the fields to expand in the response.
         * @param {number} [chainId] The chain ID. Must be a [supported chain](/chains).
         * @param {Array<string>} [account] Filter by account ID or developer account (starts with acc_ or dac_ respectively).
         * @param {Array<string>} [player] Filter by player ID (starts with pla_).
         * @param {number} [status] Filter by successful (1) or failed (0) transaction intents.
         * @param {Array<string>} [policy] Filter by policy ID (starts with pol_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionIntents(limit?: number, skip?: number, order?: SortOrder, expand?: Array<TransactionIntentResponseExpandable>, chainId?: number, account?: Array<string>, player?: Array<string>, status?: number, policy?: Array<string>, options?: any): AxiosPromise<TransactionIntentListResponse> {
            return localVarFp.getTransactionIntents(limit, skip, order, expand, chainId, account, player, status, policy, options).then((request) => request(axios, basePath));
        },
        /**
         * Broadcasts a signed TransactionIntent to the blockchain.  Use this endpoint to send the signed `userOperationHash`. Openfort will then put it on-chain.
         * @summary Send a signed transaction userOperationHash.
         * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
         * @param {SignatureRequest} signatureRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signature(id: string, signatureRequest: SignatureRequest, options?: any): AxiosPromise<TransactionIntentResponse> {
            return localVarFp.signature(id, signatureRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionIntentsApi - object-oriented interface
 * @export
 * @class TransactionIntentsApi
 * @extends {BaseAPI}
 */
export class TransactionIntentsApi extends BaseAPI {
    /**
     * Creates a TransactionIntent.  A pending TransactionIntent has the `response` attribute as undefined.  After the TransactionIntent is created and broadcasted to the blockchain, `response` will be populated with the transaction hash and a status (1 success, 0 fail).  When using a non-custodial account, a `nextAction` attribute is returned with the `userOperationHash` that must be signed by the owner of the account.
     * @summary Create a transaction intent object.
     * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public createTransactionIntent(createTransactionIntentRequest: CreateTransactionIntentRequest, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).createTransactionIntent(createTransactionIntentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Estimate the gas cost of broadcasting a TransactionIntent.  This is a simulation, it does not send the transaction on-chain.  If a Policy ID is used that includes payment of gas in ERC-20 tokens, an extra field `estimatedTXGasFeeToken` is returned with the estimated amount of tokens that will be used.
     * @summary Estimate gas cost of creating a transaction
     * @param {CreateTransactionIntentRequest} createTransactionIntentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public estimateTransactionIntentCost(createTransactionIntentRequest: CreateTransactionIntentRequest, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).estimateTransactionIntentCost(createTransactionIntentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a TransactionIntent that has previously been created.
     * @summary Get a transaction intent object.
     * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
     * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the expandable fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public getTransactionIntent(id: string, expand?: Array<TransactionIntentResponseExpandable>, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).getTransactionIntent(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of TransactionIntents.
     * @summary List transaction intents.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {Array<TransactionIntentResponseExpandable>} [expand] Specifies the fields to expand in the response.
     * @param {number} [chainId] The chain ID. Must be a [supported chain](/chains).
     * @param {Array<string>} [account] Filter by account ID or developer account (starts with acc_ or dac_ respectively).
     * @param {Array<string>} [player] Filter by player ID (starts with pla_).
     * @param {number} [status] Filter by successful (1) or failed (0) transaction intents.
     * @param {Array<string>} [policy] Filter by policy ID (starts with pol_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public getTransactionIntents(limit?: number, skip?: number, order?: SortOrder, expand?: Array<TransactionIntentResponseExpandable>, chainId?: number, account?: Array<string>, player?: Array<string>, status?: number, policy?: Array<string>, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).getTransactionIntents(limit, skip, order, expand, chainId, account, player, status, policy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Broadcasts a signed TransactionIntent to the blockchain.  Use this endpoint to send the signed `userOperationHash`. Openfort will then put it on-chain.
     * @summary Send a signed transaction userOperationHash.
     * @param {string} id Specifies the unique transaction intent ID (starts with tin_).
     * @param {SignatureRequest} signatureRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionIntentsApi
     */
    public signature(id: string, signatureRequest: SignatureRequest, options?: AxiosRequestConfig) {
        return TransactionIntentsApiFp(this.configuration).signature(id, signatureRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Web3ConnectionsApi - axios parameter creator
 * @export
 */
export const Web3ConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows you to create a new web3 connection to your Openfort player. Together with the player ID (pla_), you need to provide a chain ID. The chain to use is required because Openfort needs to make sure the account is deployed, as counterfactual addresses cannot use web3 connections. The `uri` body parameter must contain a [WalletConnect pairing URI](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-uri).
         * @summary Create a Web3 Connection object.
         * @param {CreateWeb3ConnectionRequest} createWeb3ConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWeb3Connection: async (createWeb3ConnectionRequest: CreateWeb3ConnectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWeb3ConnectionRequest' is not null or undefined
            assertParamExists('createWeb3Connection', 'createWeb3ConnectionRequest', createWeb3ConnectionRequest)
            const localVarPath = `/v1/web3_connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWeb3ConnectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of web3 actions for the given web3 connection. The actions are returned sorted by creation date, with the most recently received action appearing first. By default, a maximum of ten actions are shown per page.
         * @summary List Web3 actions from a web3 connection.
         * @param {string} id Specifies the web3Connection ID (starts with web3_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeb3Actions: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWeb3Actions', 'id', id)
            const localVarPath = `/v1/web3_connections/{id}/actions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing web3 connection. Supply the unique web3 connection ID from either a web3 connection creation request or the web3 connection list. Openfort will return the corresponding web3 connection information.
         * @summary Get a web3Connection object.
         * @param {string} id Specifies the unique web3Connection ID (starts with web3_).
         * @param {Array<Web3ConnectionResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeb3Connection: async (id: string, expand?: Array<Web3ConnectionResponseExpandable>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWeb3Connection', 'id', id)
            const localVarPath = `/v1/web3_connections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of web3 connections for the given player. The connections are returned sorted by creation date, with the most recently created connections appearing first. By default, a maximum of ten connections are shown per page.
         * @summary List Web3 connections.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [player] Specifies the unique player ID (starts with pla_)
         * @param {boolean} [disconnected] Specifies connection status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeb3Connections: async (limit?: number, skip?: number, order?: SortOrder, player?: string, disconnected?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/web3_connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (player !== undefined) {
                localVarQueryParameter['player'] = player;
            }

            if (disconnected !== undefined) {
                localVarQueryParameter['disconnected'] = disconnected;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Approve or Reject a web3 action for the given web3 connection.
         * @summary Approve or Reject a web3 action
         * @param {string} id Specifies the web3Connection ID (starts with web3_).
         * @param {string} web3Action Specifies web3_action (starts with act_).
         * @param {SubmitWeb3ActionRequest} submitWeb3ActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWeb3Action: async (id: string, web3Action: string, submitWeb3ActionRequest: SubmitWeb3ActionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submitWeb3Action', 'id', id)
            // verify required parameter 'web3Action' is not null or undefined
            assertParamExists('submitWeb3Action', 'web3Action', web3Action)
            // verify required parameter 'submitWeb3ActionRequest' is not null or undefined
            assertParamExists('submitWeb3Action', 'submitWeb3ActionRequest', submitWeb3ActionRequest)
            const localVarPath = `/v1/web3_connections/{id}/actions/{web3_action}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"web3_action"}}`, encodeURIComponent(String(web3Action)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sk required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitWeb3ActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Web3ConnectionsApi - functional programming interface
 * @export
 */
export const Web3ConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Web3ConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows you to create a new web3 connection to your Openfort player. Together with the player ID (pla_), you need to provide a chain ID. The chain to use is required because Openfort needs to make sure the account is deployed, as counterfactual addresses cannot use web3 connections. The `uri` body parameter must contain a [WalletConnect pairing URI](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-uri).
         * @summary Create a Web3 Connection object.
         * @param {CreateWeb3ConnectionRequest} createWeb3ConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWeb3Connection(createWeb3ConnectionRequest: CreateWeb3ConnectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Web3ConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWeb3Connection(createWeb3ConnectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of web3 actions for the given web3 connection. The actions are returned sorted by creation date, with the most recently received action appearing first. By default, a maximum of ten actions are shown per page.
         * @summary List Web3 actions from a web3 connection.
         * @param {string} id Specifies the web3Connection ID (starts with web3_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWeb3Actions(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Web3ActionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWeb3Actions(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing web3 connection. Supply the unique web3 connection ID from either a web3 connection creation request or the web3 connection list. Openfort will return the corresponding web3 connection information.
         * @summary Get a web3Connection object.
         * @param {string} id Specifies the unique web3Connection ID (starts with web3_).
         * @param {Array<Web3ConnectionResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWeb3Connection(id: string, expand?: Array<Web3ConnectionResponseExpandable>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Web3ConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWeb3Connection(id, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of web3 connections for the given player. The connections are returned sorted by creation date, with the most recently created connections appearing first. By default, a maximum of ten connections are shown per page.
         * @summary List Web3 connections.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [player] Specifies the unique player ID (starts with pla_)
         * @param {boolean} [disconnected] Specifies connection status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWeb3Connections(limit?: number, skip?: number, order?: SortOrder, player?: string, disconnected?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Web3ConnectionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWeb3Connections(limit, skip, order, player, disconnected, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Approve or Reject a web3 action for the given web3 connection.
         * @summary Approve or Reject a web3 action
         * @param {string} id Specifies the web3Connection ID (starts with web3_).
         * @param {string} web3Action Specifies web3_action (starts with act_).
         * @param {SubmitWeb3ActionRequest} submitWeb3ActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitWeb3Action(id: string, web3Action: string, submitWeb3ActionRequest: SubmitWeb3ActionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Web3ActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitWeb3Action(id, web3Action, submitWeb3ActionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Web3ConnectionsApi - factory interface
 * @export
 */
export const Web3ConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Web3ConnectionsApiFp(configuration)
    return {
        /**
         * This endpoint allows you to create a new web3 connection to your Openfort player. Together with the player ID (pla_), you need to provide a chain ID. The chain to use is required because Openfort needs to make sure the account is deployed, as counterfactual addresses cannot use web3 connections. The `uri` body parameter must contain a [WalletConnect pairing URI](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-uri).
         * @summary Create a Web3 Connection object.
         * @param {CreateWeb3ConnectionRequest} createWeb3ConnectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWeb3Connection(createWeb3ConnectionRequest: CreateWeb3ConnectionRequest, options?: any): AxiosPromise<Web3ConnectionResponse> {
            return localVarFp.createWeb3Connection(createWeb3ConnectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of web3 actions for the given web3 connection. The actions are returned sorted by creation date, with the most recently received action appearing first. By default, a maximum of ten actions are shown per page.
         * @summary List Web3 actions from a web3 connection.
         * @param {string} id Specifies the web3Connection ID (starts with web3_).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeb3Actions(id: string, options?: any): AxiosPromise<Web3ActionListResponse> {
            return localVarFp.getWeb3Actions(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing web3 connection. Supply the unique web3 connection ID from either a web3 connection creation request or the web3 connection list. Openfort will return the corresponding web3 connection information.
         * @summary Get a web3Connection object.
         * @param {string} id Specifies the unique web3Connection ID (starts with web3_).
         * @param {Array<Web3ConnectionResponseExpandable>} [expand] Specifies the fields to expand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeb3Connection(id: string, expand?: Array<Web3ConnectionResponseExpandable>, options?: any): AxiosPromise<Web3ConnectionResponse> {
            return localVarFp.getWeb3Connection(id, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of web3 connections for the given player. The connections are returned sorted by creation date, with the most recently created connections appearing first. By default, a maximum of ten connections are shown per page.
         * @summary List Web3 connections.
         * @param {number} [limit] Specifies the maximum number of records to return.
         * @param {number} [skip] Specifies the offset for the first records to return.
         * @param {SortOrder} [order] Specifies the order in which to sort the results.
         * @param {string} [player] Specifies the unique player ID (starts with pla_)
         * @param {boolean} [disconnected] Specifies connection status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeb3Connections(limit?: number, skip?: number, order?: SortOrder, player?: string, disconnected?: boolean, options?: any): AxiosPromise<Web3ConnectionListResponse> {
            return localVarFp.getWeb3Connections(limit, skip, order, player, disconnected, options).then((request) => request(axios, basePath));
        },
        /**
         * Approve or Reject a web3 action for the given web3 connection.
         * @summary Approve or Reject a web3 action
         * @param {string} id Specifies the web3Connection ID (starts with web3_).
         * @param {string} web3Action Specifies web3_action (starts with act_).
         * @param {SubmitWeb3ActionRequest} submitWeb3ActionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWeb3Action(id: string, web3Action: string, submitWeb3ActionRequest: SubmitWeb3ActionRequest, options?: any): AxiosPromise<Web3ActionResponse> {
            return localVarFp.submitWeb3Action(id, web3Action, submitWeb3ActionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Web3ConnectionsApi - object-oriented interface
 * @export
 * @class Web3ConnectionsApi
 * @extends {BaseAPI}
 */
export class Web3ConnectionsApi extends BaseAPI {
    /**
     * This endpoint allows you to create a new web3 connection to your Openfort player. Together with the player ID (pla_), you need to provide a chain ID. The chain to use is required because Openfort needs to make sure the account is deployed, as counterfactual addresses cannot use web3 connections. The `uri` body parameter must contain a [WalletConnect pairing URI](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-uri).
     * @summary Create a Web3 Connection object.
     * @param {CreateWeb3ConnectionRequest} createWeb3ConnectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Web3ConnectionsApi
     */
    public createWeb3Connection(createWeb3ConnectionRequest: CreateWeb3ConnectionRequest, options?: AxiosRequestConfig) {
        return Web3ConnectionsApiFp(this.configuration).createWeb3Connection(createWeb3ConnectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of web3 actions for the given web3 connection. The actions are returned sorted by creation date, with the most recently received action appearing first. By default, a maximum of ten actions are shown per page.
     * @summary List Web3 actions from a web3 connection.
     * @param {string} id Specifies the web3Connection ID (starts with web3_).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Web3ConnectionsApi
     */
    public getWeb3Actions(id: string, options?: AxiosRequestConfig) {
        return Web3ConnectionsApiFp(this.configuration).getWeb3Actions(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing web3 connection. Supply the unique web3 connection ID from either a web3 connection creation request or the web3 connection list. Openfort will return the corresponding web3 connection information.
     * @summary Get a web3Connection object.
     * @param {string} id Specifies the unique web3Connection ID (starts with web3_).
     * @param {Array<Web3ConnectionResponseExpandable>} [expand] Specifies the fields to expand.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Web3ConnectionsApi
     */
    public getWeb3Connection(id: string, expand?: Array<Web3ConnectionResponseExpandable>, options?: AxiosRequestConfig) {
        return Web3ConnectionsApiFp(this.configuration).getWeb3Connection(id, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of web3 connections for the given player. The connections are returned sorted by creation date, with the most recently created connections appearing first. By default, a maximum of ten connections are shown per page.
     * @summary List Web3 connections.
     * @param {number} [limit] Specifies the maximum number of records to return.
     * @param {number} [skip] Specifies the offset for the first records to return.
     * @param {SortOrder} [order] Specifies the order in which to sort the results.
     * @param {string} [player] Specifies the unique player ID (starts with pla_)
     * @param {boolean} [disconnected] Specifies connection status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Web3ConnectionsApi
     */
    public getWeb3Connections(limit?: number, skip?: number, order?: SortOrder, player?: string, disconnected?: boolean, options?: AxiosRequestConfig) {
        return Web3ConnectionsApiFp(this.configuration).getWeb3Connections(limit, skip, order, player, disconnected, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Approve or Reject a web3 action for the given web3 connection.
     * @summary Approve or Reject a web3 action
     * @param {string} id Specifies the web3Connection ID (starts with web3_).
     * @param {string} web3Action Specifies web3_action (starts with act_).
     * @param {SubmitWeb3ActionRequest} submitWeb3ActionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Web3ConnectionsApi
     */
    public submitWeb3Action(id: string, web3Action: string, submitWeb3ActionRequest: SubmitWeb3ActionRequest, options?: AxiosRequestConfig) {
        return Web3ConnectionsApiFp(this.configuration).submitWeb3Action(id, web3Action, submitWeb3ActionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


